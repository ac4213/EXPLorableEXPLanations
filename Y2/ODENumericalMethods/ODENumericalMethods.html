<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ODE Numerical Methods - Interactive Lecture</title>
    <meta name="description" content="Interactive lecture on numerical methods for solving ordinary differential equations including Euler and Runge-Kutta methods">
    <meta name="keywords" content="ODE, numerical methods, Euler method, Runge-Kutta, RK4, error analysis, stability, differential equations">

    <!-- External CSS -->
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="/assets/css/problems.css">
    <link rel="stylesheet" href="/assets/css/quizzes.css">
    <link rel="stylesheet" href="/assets/css/simulations.css">
    <link rel="stylesheet" href="/assets/css/uicontrols.css">

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
    <!-- Header -->
    <header>
        <h1>Numerical Methods for Ordinary Differential Equations</h1>
        <p class="subtitle">Euler Method, Runge-Kutta Methods, Error Analysis, and Stability</p>
    </header>

    <!-- Navigation breadcrumb -->
    <nav class="breadcrumb">
        <a href="/">Home</a> &gt;
        <a href="/">Y2</a> &gt;
        <span>ODE Numerical Methods</span>
    </nav>

    <!-- Introduction & Theory Section -->
    <div class="content-section">
        <h2>Introduction to ODE Numerical Methods</h2>

        <p>Many engineering problems involve <strong>ordinary differential equations (ODEs)</strong> that cannot be solved analytically. Numerical methods provide approximate solutions by discretizing the continuous problem into a sequence of algebraic calculations.</p>

        <div class="key-point">
            <p><strong>Core Concept:</strong> Numerical ODE solvers approximate the solution by taking small steps in time, using the differential equation to predict how the solution evolves. The accuracy and stability of these methods depend on the step size and the mathematical properties of the algorithm.</p>
        </div>

        <h3>The Initial Value Problem</h3>
        <p>We seek to solve differential equations of the form:</p>

        <div class="equation-box">
            <p>\[\frac{dy}{dt} = f(t, y), \quad y(t_0) = y_0\]</p>
            <p>Where:</p>
            <ul>
                <li>\(y(t)\) is the unknown function we want to find</li>
                <li>\(f(t, y)\) is a known function defining the derivative</li>
                <li>\(y_0\) is the initial condition at time \(t_0\)</li>
            </ul>
        </div>

        <h3>1. Euler's Method (Forward Euler)</h3>
        <p>The <strong>Euler method</strong> is the simplest numerical method, based on a first-order Taylor series approximation.</p>

        <div class="equation-box">
            <p><strong>Algorithm:</strong></p>
            <p>\[y_{n+1} = y_n + h \cdot f(t_n, y_n)\]</p>
            <p>Where:</p>
            <ul>
                <li>\(h = t_{n+1} - t_n\) is the time step size</li>
                <li>\(y_n\) is the approximate solution at time \(t_n\)</li>
                <li>\(f(t_n, y_n)\) is the derivative at the current point</li>
            </ul>
            <p><strong>Geometric Interpretation:</strong> The method follows the tangent line at \((t_n, y_n)\) for a distance \(h\).</p>
            <p><strong>Local Truncation Error:</strong> \(O(h^2)\)</p>
            <p><strong>Global Error:</strong> \(O(h)\) - first-order accurate</p>
        </div>

        <div class="key-point">
            <p><strong>Limitations:</strong> Euler's method is simple but has poor accuracy and stability. It requires very small step sizes for acceptable results and can be unstable for stiff equations.</p>
        </div>

        <h3>2. Modified Euler Method (Heun's Method)</h3>
        <p>An improvement over Euler's method that uses a predictor-corrector approach:</p>

        <div class="equation-box">
            <p><strong>Predictor:</strong></p>
            <p>\[\tilde{y}_{n+1} = y_n + h \cdot f(t_n, y_n)\]</p>
            <p><strong>Corrector:</strong></p>
            <p>\[y_{n+1} = y_n + \frac{h}{2}\left[f(t_n, y_n) + f(t_{n+1}, \tilde{y}_{n+1})\right]\]</p>
            <p><strong>Global Error:</strong> \(O(h^2)\) - second-order accurate</p>
        </div>

        <h3>3. Runge-Kutta Methods</h3>
        <p><strong>Runge-Kutta (RK) methods</strong> achieve higher accuracy by evaluating the derivative at multiple intermediate points.</p>

        <div class="equation-box">
            <p><strong>Second-Order Runge-Kutta (RK2):</strong></p>
            <p>\[k_1 = h \cdot f(t_n, y_n)\]</p>
            <p>\[k_2 = h \cdot f\left(t_n + \frac{h}{2}, y_n + \frac{k_1}{2}\right)\]</p>
            <p>\[y_{n+1} = y_n + k_2\]</p>
            <p><strong>Global Error:</strong> \(O(h^2)\)</p>
        </div>

        <h3>4. Fourth-Order Runge-Kutta (RK4)</h3>
        <p>The most widely used method, offering an excellent balance of accuracy and computational cost:</p>

        <div class="equation-box">
            <p><strong>RK4 Algorithm:</strong></p>
            <p>\[k_1 = h \cdot f(t_n, y_n)\]</p>
            <p>\[k_2 = h \cdot f\left(t_n + \frac{h}{2}, y_n + \frac{k_1}{2}\right)\]</p>
            <p>\[k_3 = h \cdot f\left(t_n + \frac{h}{2}, y_n + \frac{k_2}{2}\right)\]</p>
            <p>\[k_4 = h \cdot f(t_n + h, y_n + k_3)\]</p>
            <p>\[y_{n+1} = y_n + \frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)\]</p>
            <p><strong>Global Error:</strong> \(O(h^4)\) - fourth-order accurate</p>
        </div>

        <div class="key-point">
            <p><strong>Interpretation:</strong> RK4 evaluates the derivative at four points: the start, two midpoints, and the end of the interval. It then takes a weighted average, giving more weight to the midpoint evaluations. This provides excellent accuracy with reasonable computational cost.</p>
        </div>

        <h3>Error Analysis</h3>
        <p>Understanding and quantifying errors is crucial for reliable numerical solutions:</p>

        <div class="equation-box">
            <p><strong>Local Truncation Error (LTE):</strong> Error introduced in a single step</p>
            <p><strong>Global Error:</strong> Accumulated error over many steps</p>
            <p><strong>Order of Accuracy:</strong></p>
            <ul>
                <li>Euler: \(O(h)\) - Global error halves when step size halves</li>
                <li>RK2: \(O(h^2)\) - Global error reduces by factor of 4</li>
                <li>RK4: \(O(h^4)\) - Global error reduces by factor of 16</li>
            </ul>
            <p><strong>Absolute Error:</strong> \(|y_{true} - y_{numerical}|\)</p>
            <p><strong>Relative Error:</strong> \(\frac{|y_{true} - y_{numerical}|}{|y_{true}|}\)</p>
        </div>

        <h3>Stability Analysis</h3>
        <p>Stability determines whether errors grow or decay as the solution progresses:</p>

        <div class="equation-box">
            <p><strong>Test Equation:</strong> \(\frac{dy}{dt} = \lambda y\) where \(\lambda < 0\)</p>
            <p><strong>Stability Criterion:</strong> For Euler's method:</p>
            <p>\[|1 + h\lambda| \leq 1 \implies h \leq \frac{2}{|\lambda|}\]</p>
            <p><strong>Stiff Equations:</strong> Equations with widely different time scales (large negative \(\lambda\)) require very small step sizes for explicit methods or implicit methods for stability.</p>
        </div>

        <h3>Adaptive Step Size Control</h3>
        <p>Modern ODE solvers adjust step size automatically to maintain accuracy:</p>

        <div class="equation-box">
            <p><strong>Embedded RK Methods:</strong> Use two approximations of different orders</p>
            <p>Error estimate: \(\epsilon = |y_{higher} - y_{lower}|\)</p>
            <p>If \(\epsilon > \text{tolerance}\): reduce \(h\)</p>
            <p>If \(\epsilon < \text{tolerance}\): increase \(h\)</p>
        </div>

        <h3>Systems of ODEs</h3>
        <p>All methods extend naturally to systems of equations:</p>

        <div class="equation-box">
            <p>\[\frac{d\mathbf{y}}{dt} = \mathbf{f}(t, \mathbf{y}), \quad \mathbf{y}(t_0) = \mathbf{y}_0\]</p>
            <p>where \(\mathbf{y}\) and \(\mathbf{f}\) are vectors. Apply the method component-wise.</p>
            <p><strong>Example:</strong> Second-order ODE \(\frac{d^2y}{dt^2} = g(t, y, \frac{dy}{dt})\)</p>
            <p>Convert to system: \(y_1 = y, \quad y_2 = \frac{dy}{dt}\)</p>
            <p>\[\frac{dy_1}{dt} = y_2, \quad \frac{dy_2}{dt} = g(t, y_1, y_2)\]</p>
        </div>
    </div>

    <!-- Interactive Simulation Section -->
    <div class="content-section">
        <h2>Interactive Simulation: Comparing ODE Solvers</h2>

        <p>Compare different numerical methods solving the same differential equation. Observe how accuracy varies with step size and method choice.</p>

        <div class="simulation-container">
            <!-- Control Panel -->
            <div class="controls-panel" style="margin-bottom: 20px;">
                <div class="slider-container">
                    <label for="ode-type">Differential Equation:</label>
                    <select id="ode-type" style="padding: 5px; font-size: 14px;">
                        <option value="exponential">Exponential Decay: dy/dt = -y</option>
                        <option value="oscillator">Harmonic Oscillator: d²y/dt² = -ω²y</option>
                        <option value="nonlinear">Nonlinear: dy/dt = y(1-y)</option>
                        <option value="vanderpol">Van der Pol: d²y/dt² - μ(1-y²)dy/dt + y = 0</option>
                    </select>
                </div>

                <div class="slider-container">
                    <label for="step-size">Step Size (h): <span id="step-size-value">0.10</span></label>
                    <input type="range" id="step-size" min="0.01" max="0.5" step="0.01" value="0.1">
                </div>

                <div class="slider-container">
                    <label for="param-slider">Parameter: <span id="param-value">1.0</span></label>
                    <input type="range" id="param-slider" min="0.1" max="5" step="0.1" value="1">
                </div>
            </div>

            <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 20px;">
                <label style="display: flex; align-items: center; gap: 5px;">
                    <input type="checkbox" id="show-euler" checked> Euler
                </label>
                <label style="display: flex; align-items: center; gap: 5px;">
                    <input type="checkbox" id="show-rk2" checked> RK2
                </label>
                <label style="display: flex; align-items: center; gap: 5px;">
                    <input type="checkbox" id="show-rk4" checked> RK4
                </label>
                <label style="display: flex; align-items: center; gap: 5px;">
                    <input type="checkbox" id="show-exact" checked> Exact
                </label>
            </div>

            <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 20px;">
                <button id="solve-btn">Solve</button>
                <button id="reset-sim-btn">Reset</button>
            </div>

            <!-- Simulation Canvas -->
            <div id="sketch-holder"></div>

            <!-- Error Display -->
            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-top: 20px;">
                <h4 style="margin-top: 0;">Accuracy Comparison (at final time):</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                    <div>
                        <strong>Euler Error:</strong> <span id="error-euler">-</span>
                    </div>
                    <div>
                        <strong>RK2 Error:</strong> <span id="error-rk2">-</span>
                    </div>
                    <div>
                        <strong>RK4 Error:</strong> <span id="error-rk4">-</span>
                    </div>
                </div>
                <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #dee2e6; font-size: 14px;">
                    <strong>Computational Cost:</strong>
                    <div style="margin-top: 8px;">
                        <div>Euler: 1 function evaluation per step</div>
                        <div>RK2: 2 function evaluations per step</div>
                        <div>RK4: 4 function evaluations per step</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Engineering Applications Section -->
    <div class="content-section">
        <h2>Engineering Applications</h2>

        <h3>1. Structural Dynamics and Vibrations</h3>
        <p>ODE solvers are essential for analyzing dynamic structural response:</p>
        <ul>
            <li><strong>Equation of motion:</strong> \(m\ddot{x} + c\dot{x} + kx = F(t)\)</li>
            <li><strong>Earthquake response:</strong> Time history analysis using RK4 or Newmark-beta</li>
            <li><strong>Wind-induced vibrations:</strong> Solving coupled equations for tall structures</li>
            <li><strong>Vehicle suspension:</strong> Quarter-car and full-car models</li>
        </ul>

        <h3>2. Circuit Analysis and Control Systems</h3>
        <p>Transient analysis of electrical and control systems:</p>
        <ul>
            <li><strong>RC/RLC circuits:</strong> \(\frac{dV}{dt} + \frac{V}{RC} = \frac{V_{in}}{RC}\)</li>
            <li><strong>Control system response:</strong> Feedback loops with transfer functions</li>
            <li><strong>Motor dynamics:</strong> Speed and torque transients</li>
            <li><strong>Power system stability:</strong> Generator swing equations</li>
        </ul>

        <h3>3. Aerospace and Orbital Mechanics</h3>
        <p>Trajectory simulation and guidance:</p>
        <ul>
            <li><strong>Projectile motion:</strong> With air resistance and varying gravity</li>
            <li><strong>Rocket trajectories:</strong> Variable mass systems</li>
            <li><strong>Satellite orbits:</strong> N-body gravitational problems</li>
            <li><strong>Attitude dynamics:</strong> Euler's equations for rigid body rotation</li>
        </ul>

        <h3>4. Chemical Reaction Kinetics</h3>
        <p>Modeling concentration changes in chemical processes:</p>
        <ul>
            <li><strong>Reaction rates:</strong> \(\frac{dC}{dt} = -kC^n\)</li>
            <li><strong>Batch reactors:</strong> Multiple species concentration evolution</li>
            <li><strong>Pharmacokinetics:</strong> Drug concentration in compartment models</li>
            <li><strong>Enzyme kinetics:</strong> Michaelis-Menten equations</li>
        </ul>

        <h3>5. Fluid Dynamics and Heat Transfer</h3>
        <p>Time-dependent thermal and flow problems:</p>
        <ul>
            <li><strong>Transient heat conduction:</strong> Lumped capacity models</li>
            <li><strong>Cooling/heating processes:</strong> Newton's law of cooling</li>
            <li><strong>Unsteady flow:</strong> Simplified fluid momentum equations</li>
            <li><strong>Thermal systems:</strong> HVAC transient response</li>
        </ul>
    </div>

    <!-- Summary of Key Equations Section -->
    <div class="content-section">
        <h2>Summary of Key Equations</h2>

        <div class="equation-table">
            <table>
                <thead>
                    <tr>
                        <th>Method</th>
                        <th>Algorithm</th>
                        <th>Order</th>
                        <th>Evaluations/Step</th>
                        <th>Stability</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Euler</strong></td>
                        <td>\(y_{n+1} = y_n + hf(t_n, y_n)\)</td>
                        <td>1st</td>
                        <td>1</td>
                        <td>Conditionally stable</td>
                    </tr>
                    <tr>
                        <td><strong>Modified Euler</strong></td>
                        <td>\(y_{n+1} = y_n + \frac{h}{2}[f_n + f_{n+1}^*]\)</td>
                        <td>2nd</td>
                        <td>2</td>
                        <td>Better than Euler</td>
                    </tr>
                    <tr>
                        <td><strong>RK2</strong></td>
                        <td>Midpoint method</td>
                        <td>2nd</td>
                        <td>2</td>
                        <td>Good</td>
                    </tr>
                    <tr>
                        <td><strong>RK4</strong></td>
                        <td>\(y_{n+1} = y_n + \frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\)</td>
                        <td>4th</td>
                        <td>4</td>
                        <td>Excellent</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div style="margin-top: 20px;">
            <h3>Important Concepts</h3>
            <ul>
                <li><strong>Local Truncation Error:</strong> Error in single step (Euler: \(O(h^2)\), RK4: \(O(h^5)\))</li>
                <li><strong>Global Error:</strong> Accumulated error (Euler: \(O(h)\), RK4: \(O(h^4)\))</li>
                <li><strong>Convergence:</strong> Solution approaches exact as \(h \to 0\)</li>
                <li><strong>Stability:</strong> Errors don't grow unboundedly; depends on \(h\lambda\)</li>
                <li><strong>Consistency:</strong> Local error \(\to 0\) as \(h \to 0\)</li>
                <li><strong>Stiff Equations:</strong> Require implicit methods or very small \(h\)</li>
            </ul>
        </div>
    </div>

    <!-- Practice Problems Section -->
    <div class="content-section">
        <h2>Practice Problems</h2>

        <div class="practice-problems">
            <h3>Problem 1: Euler's Method Application</h3>
            <p>Use Euler's method with step size \(h = 0.2\) to solve \(\frac{dy}{dt} = -2y\) with \(y(0) = 1\) from \(t = 0\) to \(t = 0.4\). Compare with the exact solution \(y(t) = e^{-2t}\).</p>

            <p class="toggle-section" onclick="toggleSolution('sol1')">Show Solution</p>
            <div id="sol1" class="hidden">
                <p><strong>Given:</strong></p>
                <ul>
                    <li>\(f(t, y) = -2y\)</li>
                    <li>\(y_0 = 1\) at \(t_0 = 0\)</li>
                    <li>\(h = 0.2\)</li>
                    <li>Exact: \(y(t) = e^{-2t}\)</li>
                </ul>

                <p><strong>Euler's Method:</strong> \(y_{n+1} = y_n + h \cdot f(t_n, y_n) = y_n + 0.2(-2y_n) = y_n(1 - 0.4)\)</p>

                <p><strong>Step 1:</strong> \(t_1 = 0.2\)</p>
                <p>\[y_1 = y_0(1 - 0.4) = 1(0.6) = 0.600\]</p>
                <p>Exact: \(y(0.2) = e^{-0.4} = 0.6703\)</p>
                <p>Error: \(|0.6703 - 0.600| = 0.0703\)</p>

                <p><strong>Step 2:</strong> \(t_2 = 0.4\)</p>
                <p>\[y_2 = y_1(1 - 0.4) = 0.6(0.6) = 0.360\]</p>
                <p>Exact: \(y(0.4) = e^{-0.8} = 0.4493\)</p>
                <p>Error: \(|0.4493 - 0.360| = 0.0893\)</p>

                <p><strong>Summary Table:</strong></p>
                <table style="border-collapse: collapse; margin: 10px 0;">
                    <tr><th style="border: 1px solid #ddd; padding: 8px;">\(t\)</th><th style="border: 1px solid #ddd; padding: 8px;">Euler \(y_n\)</th><th style="border: 1px solid #ddd; padding: 8px;">Exact</th><th style="border: 1px solid #ddd; padding: 8px;">Error</th></tr>
                    <tr><td style="border: 1px solid #ddd; padding: 8px;">0.0</td><td style="border: 1px solid #ddd; padding: 8px;">1.0000</td><td style="border: 1px solid #ddd; padding: 8px;">1.0000</td><td style="border: 1px solid #ddd; padding: 8px;">0.0000</td></tr>
                    <tr><td style="border: 1px solid #ddd; padding: 8px;">0.2</td><td style="border: 1px solid #ddd; padding: 8px;">0.6000</td><td style="border: 1px solid #ddd; padding: 8px;">0.6703</td><td style="border: 1px solid #ddd; padding: 8px;">0.0703</td></tr>
                    <tr><td style="border: 1px solid #ddd; padding: 8px;">0.4</td><td style="border: 1px solid #ddd; padding: 8px;">0.3600</td><td style="border: 1px solid #ddd; padding: 8px;">0.4493</td><td style="border: 1px solid #ddd; padding: 8px;">0.0893</td></tr>
                </table>

                <p><strong>Observation:</strong> Error grows with time. Smaller step size would improve accuracy.</p>
            </div>
        </div>

        <div class="practice-problems">
            <h3>Problem 2: RK4 Method</h3>
            <p>Apply one step of RK4 with \(h = 0.5\) to solve \(\frac{dy}{dt} = t + y\) with \(y(0) = 1\).</p>

            <p class="toggle-section" onclick="toggleSolution('sol2')">Show Solution</p>
            <div id="sol2" class="hidden">
                <p><strong>Given:</strong></p>
                <ul>
                    <li>\(f(t, y) = t + y\)</li>
                    <li>\(y_0 = 1\), \(t_0 = 0\), \(h = 0.5\)</li>
                </ul>

                <p><strong>Calculate \(k_1\):</strong></p>
                <p>\[k_1 = h \cdot f(t_0, y_0) = 0.5(0 + 1) = 0.5\]</p>

                <p><strong>Calculate \(k_2\):</strong></p>
                <p>\[k_2 = h \cdot f\left(t_0 + \frac{h}{2}, y_0 + \frac{k_1}{2}\right) = 0.5 \cdot f(0.25, 1.25)\]</p>
                <p>\[k_2 = 0.5(0.25 + 1.25) = 0.5(1.5) = 0.75\]</p>

                <p><strong>Calculate \(k_3\):</strong></p>
                <p>\[k_3 = h \cdot f\left(t_0 + \frac{h}{2}, y_0 + \frac{k_2}{2}\right) = 0.5 \cdot f(0.25, 1.375)\]</p>
                <p>\[k_3 = 0.5(0.25 + 1.375) = 0.5(1.625) = 0.8125\]</p>

                <p><strong>Calculate \(k_4\):</strong></p>
                <p>\[k_4 = h \cdot f(t_0 + h, y_0 + k_3) = 0.5 \cdot f(0.5, 1.8125)\]</p>
                <p>\[k_4 = 0.5(0.5 + 1.8125) = 0.5(2.3125) = 1.15625\]</p>

                <p><strong>Final Update:</strong></p>
                <p>\[y_1 = y_0 + \frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)\]</p>
                <p>\[y_1 = 1 + \frac{1}{6}(0.5 + 2(0.75) + 2(0.8125) + 1.15625)\]</p>
                <p>\[y_1 = 1 + \frac{1}{6}(0.5 + 1.5 + 1.625 + 1.15625)\]</p>
                <p>\[y_1 = 1 + \frac{4.78125}{6} = 1 + 0.7969 = 1.7969\]</p>

                <p><strong>Result:</strong> \(y(0.5) \approx 1.797\)</p>
                <p>(The exact solution is \(y = 2e^t - t - 1\), giving \(y(0.5) = 1.7974\), error ≈ 0.0005)</p>
            </div>
        </div>

        <div class="practice-problems">
            <h3>Problem 3: Error Analysis and Step Size Selection</h3>
            <p>For the equation \(\frac{dy}{dt} = -10y\) with \(y(0) = 1\):</p>
            <p>(a) What is the maximum step size for Euler's method to be stable?<br>
               (b) If we want global error < 0.01 at \(t = 1\) using Euler's method, estimate the required step size.</p>

            <p class="toggle-section" onclick="toggleSolution('sol3')">Show Solution</p>
            <div id="sol3" class="hidden">
                <p><strong>Given:</strong></p>
                <ul>
                    <li>\(f(y) = -10y\), so \(\lambda = -10\)</li>
                    <li>Initial condition: \(y(0) = 1\)</li>
                    <li>Exact solution: \(y(t) = e^{-10t}\)</li>
                </ul>

                <p><strong>(a) Stability Condition:</strong></p>
                <p>For Euler's method to be stable: \(|1 + h\lambda| \leq 1\)</p>
                <p>\[|1 + h(-10)| \leq 1\]</p>
                <p>\[|1 - 10h| \leq 1\]</p>
                <p>This gives: \(-1 \leq 1 - 10h \leq 1\)</p>
                <p>From the left inequality: \(-1 \leq 1 - 10h \implies 10h \leq 2 \implies h \leq 0.2\)</p>
                <p>From the right inequality: \(1 - 10h \leq 1\) (always satisfied for \(h > 0\))</p>
                <p><strong>Maximum stable step size:</strong> \(h_{max} = 0.2\)</p>

                <p><strong>(b) Step Size for Desired Accuracy:</strong></p>
                <p>For Euler's method, global error is \(O(h)\). Empirically, for this problem:</p>
                <p>Error at \(t = 1\) is approximately proportional to \(h\).</p>
                <p>From analysis, error ≈ \(\frac{C \cdot h \cdot |y(1)|}{1}\) where \(C\) depends on \(\lambda\)</p>
                <p>For \(\lambda = -10\), the error coefficient is large.</p>
                <p>Trial: With \(h = 0.1\), number of steps = 10</p>
                <p>Euler gives: \(y_{10} = (1 - 1)^{10} = 0\)</p>
                <p>Exact: \(y(1) = e^{-10} \approx 0.0000454\)</p>
                <p>Error ≈ 0.0000454 (acceptable!)</p>
                <p>Actually, with \(h = 0.2\) (at stability limit):</p>
                <p>\(y_5 = (1-2)^5 = -1\) (unstable oscillation!)</p>
                <p><strong>Safe choice:</strong> \(h \leq 0.1\) for both stability and accuracy</p>
            </div>
        </div>

        <div class="practice-problems">
            <h3>Problem 4: System of ODEs</h3>
            <p>Use RK4 with \(h = 0.1\) to take one step for the system:</p>
            <p>\[\frac{dx}{dt} = y, \quad \frac{dy}{dt} = -x, \quad x(0) = 1, \quad y(0) = 0\]</p>

            <p class="toggle-section" onclick="toggleSolution('sol4')">Show Solution</p>
            <div id="sol4" class="hidden">
                <p><strong>Given:</strong></p>
                <ul>
                    <li>\(f_1(x, y) = y\)</li>
                    <li>\(f_2(x, y) = -x\)</li>
                    <li>\(x_0 = 1\), \(y_0 = 0\), \(h = 0.1\)</li>
                    <li>Exact: \(x(t) = \cos(t)\), \(y(t) = \sin(t)\)</li>
                </ul>

                <p><strong>For x-component:</strong></p>
                <p>\[k_1^x = h \cdot f_1(x_0, y_0) = 0.1(0) = 0\]</p>
                <p>\[k_2^x = h \cdot f_1(x_0 + k_1^x/2, y_0 + k_1^y/2) = 0.1(-0.05) = -0.005\]</p>
                <p>where \(k_1^y = h \cdot f_2(x_0, y_0) = 0.1(-1) = -0.1\)</p>
                <p>\[k_2^y = h \cdot f_2(1, -0.05) = 0.1(-1) = -0.1\]</p>
                <p>\[k_3^x = h \cdot f_1(1 - 0.05/2, -0.05) = 0.1(-0.05) = -0.005\]</p>
                <p>\[k_3^y = h \cdot f_2(0.975, -0.05) = 0.1(-0.975) = -0.0975\]</p>
                <p>\[k_4^x = h \cdot f_1(1 - 0.005, -0.0975) = 0.1(-0.0975) = -0.00975\]</p>
                <p>\[k_4^y = h \cdot f_2(0.995, -0.0975) = 0.1(-0.995) = -0.0995\]</p>

                <p><strong>Update:</strong></p>
                <p>\[x_1 = 1 + \frac{1}{6}(0 + 2(-0.005) + 2(-0.005) + (-0.00975))\]</p>
                <p>\[x_1 = 1 - 0.00496 = 0.99504\]</p>
                <p>\[y_1 = 0 + \frac{1}{6}(-0.1 + 2(-0.1) + 2(-0.0975) + (-0.0995))\]</p>
                <p>\[y_1 = -0.09958\]</p>

                <p><strong>Exact Solution:</strong></p>
                <p>\[x(0.1) = \cos(0.1) = 0.99500\]</p>
                <p>\[y(0.1) = \sin(0.1) = 0.09983\]</p>

                <p><strong>Errors:</strong> \(|0.99500 - 0.99504| = 0.00004\), excellent!</p>
            </div>
        </div>
    </div>

    <!-- Knowledge Check Quiz Section -->
    <div class="content-section">
        <h2>Knowledge Check Quiz</h2>

        <div class="quiz-container">
            <div class="quiz-question">
                <h3>Q1: Euler's method is a:</h3>
                <div class="quiz-options">
                    <label><input type="radio" name="q1" value="a"> (a) First-order method</label>
                    <label><input type="radio" name="q1" value="b"> (b) Second-order method</label>
                    <label><input type="radio" name="q1" value="c"> (c) Fourth-order method</label>
                    <label><input type="radio" name="q1" value="d"> (d) Implicit method</label>
                </div>
            </div>

            <div class="quiz-question">
                <h3>Q2: How many function evaluations does RK4 require per time step?</h3>
                <div class="quiz-options">
                    <label><input type="radio" name="q2" value="a"> (a) 1</label>
                    <label><input type="radio" name="q2" value="b"> (b) 2</label>
                    <label><input type="radio" name="q2" value="c"> (c) 3</label>
                    <label><input type="radio" name="q2" value="d"> (d) 4</label>
                </div>
            </div>

            <div class="quiz-question">
                <h3>Q3: If the step size is halved, the global error in RK4 is reduced by approximately:</h3>
                <div class="quiz-options">
                    <label><input type="radio" name="q3" value="a"> (a) Factor of 2</label>
                    <label><input type="radio" name="q3" value="b"> (b) Factor of 4</label>
                    <label><input type="radio" name="q3" value="c"> (c) Factor of 8</label>
                    <label><input type="radio" name="q3" value="d"> (d) Factor of 16</label>
                </div>
            </div>

            <div class="quiz-question">
                <h3>Q4: Stiff equations are characterized by:</h3>
                <div class="quiz-options">
                    <label><input type="radio" name="q4" value="a"> (a) Nonlinearity</label>
                    <label><input type="radio" name="q4" value="b"> (b) Multiple time scales</label>
                    <label><input type="radio" name="q4" value="c"> (c) Discontinuities</label>
                    <label><input type="radio" name="q4" value="d"> (d) High order</label>
                </div>
            </div>

            <div class="quiz-question">
                <h3>Q5: The local truncation error for Euler's method is:</h3>
                <div class="quiz-options">
                    <label><input type="radio" name="q5" value="a"> (a) \(O(h)\)</label>
                    <label><input type="radio" name="q5" value="b"> (b) \(O(h^2)\)</label>
                    <label><input type="radio" name="q5" value="c"> (c) \(O(h^3)\)</label>
                    <label><input type="radio" name="q5" value="d"> (d) \(O(h^4)\)</label>
                </div>
            </div>

            <div class="quiz-question">
                <h3>Q6: Which method generally provides the best balance of accuracy and computational cost?</h3>
                <div class="quiz-options">
                    <label><input type="radio" name="q6" value="a"> (a) Euler</label>
                    <label><input type="radio" name="q6" value="b"> (b) Modified Euler</label>
                    <label><input type="radio" name="q6" value="c"> (c) RK2</label>
                    <label><input type="radio" name="q6" value="d"> (d) RK4</label>
                </div>
            </div>

            <div class="quiz-question">
                <h3>Q7: To convert a second-order ODE to a system of first-order ODEs, we:</h3>
                <div class="quiz-options">
                    <label><input type="radio" name="q7" value="a"> (a) Integrate twice</label>
                    <label><input type="radio" name="q7" value="b"> (b) Introduce a new variable for the first derivative</label>
                    <label><input type="radio" name="q7" value="c"> (c) Use finite differences</label>
                    <label><input type="radio" name="q7" value="d"> (d) Apply Laplace transform</label>
                </div>
            </div>

            <div class="quiz-question">
                <h3>Q8: Adaptive step size methods adjust h based on:</h3>
                <div class="quiz-options">
                    <label><input type="radio" name="q8" value="a"> (a) The magnitude of y</label>
                    <label><input type="radio" name="q8" value="b"> (b) Error estimates</label>
                    <label><input type="radio" name="q8" value="c"> (c) The sign of dy/dt</label>
                    <label><input type="radio" name="q8" value="d"> (d) User preference</label>
                </div>
            </div>

            <button id="submit-quiz">Submit Quiz</button>
            <div id="quiz-results"></div>
        </div>
    </div>

    <!-- Footer -->
    <footer>
        <script src="/assets/common/footer.js"></script>
    </footer>

    <!-- Common JavaScript -->
    <script src="/assets/common/problems.js"></script>
    <script src="/assets/common/quizzes.js"></script>

    <!-- Page-specific JavaScript for Simulation -->
    <script>
        // ODE Numerical Methods Simulation
        let sketch = new p5(function(p) {
            let odeType = 'exponential';
            let stepSize = 0.1;
            let parameter = 1.0;

            let showEuler = true;
            let showRK2 = true;
            let showRK4 = true;
            let showExact = true;

            let solutions = {
                euler: [],
                rk2: [],
                rk4: [],
                exact: []
            };

            let errors = {euler: 0, rk2: 0, rk4: 0};

            let canvasWidth, canvasHeight;
            let solved = false;

            p.setup = function() {
                canvasWidth = Math.min(1000, p.windowWidth - 40);
                canvasHeight = 500;
                let canvas = p.createCanvas(canvasWidth, canvasHeight);
                canvas.parent('sketch-holder');

                setupEventListeners();
                solveSystems();
            };

            function setupEventListeners() {
                document.getElementById('ode-type').addEventListener('change', function() {
                    odeType = this.value;
                    updateParamLabel();
                    solved = false;
                });

                document.getElementById('step-size').addEventListener('input', function() {
                    stepSize = parseFloat(this.value);
                    document.getElementById('step-size-value').textContent = stepSize.toFixed(2);
                    solved = false;
                });

                document.getElementById('param-slider').addEventListener('input', function() {
                    parameter = parseFloat(this.value);
                    document.getElementById('param-value').textContent = parameter.toFixed(1);
                    solved = false;
                });

                document.getElementById('show-euler').addEventListener('change', function() {
                    showEuler = this.checked;
                });

                document.getElementById('show-rk2').addEventListener('change', function() {
                    showRK2 = this.checked;
                });

                document.getElementById('show-rk4').addEventListener('change', function() {
                    showRK4 = this.checked;
                });

                document.getElementById('show-exact').addEventListener('change', function() {
                    showExact = this.checked;
                });

                document.getElementById('solve-btn').addEventListener('click', function() {
                    solveSystems();
                });

                document.getElementById('reset-sim-btn').addEventListener('click', function() {
                    resetSimulation();
                });
            }

            function updateParamLabel() {
                let label = 'Parameter: ';
                if (odeType === 'exponential') label = 'Decay rate: ';
                else if (odeType === 'oscillator') label = 'Angular freq (ω): ';
                else if (odeType === 'nonlinear') label = 'Growth rate: ';
                else if (odeType === 'vanderpol') label = 'Damping (μ): ';

                let elem = document.querySelector('label[for="param-slider"]');
                elem.innerHTML = label + '<span id="param-value">' + parameter.toFixed(1) + '</span>';
            }

            function resetSimulation() {
                stepSize = 0.1;
                parameter = 1.0;
                odeType = 'exponential';
                document.getElementById('step-size').value = stepSize;
                document.getElementById('param-slider').value = parameter;
                document.getElementById('ode-type').value = odeType;
                document.getElementById('step-size-value').textContent = stepSize.toFixed(2);
                document.getElementById('param-value').textContent = parameter.toFixed(1);
                updateParamLabel();
                solved = false;
                solveSystems();
            }

            function getODEFunction() {
                // Returns [f1, f2] for system dy1/dt = f1, dy2/dt = f2
                // y1 is main variable, y2 is derivative for 2nd order

                if (odeType === 'exponential') {
                    return function(t, y) {
                        return [-parameter * y[0], 0];
                    };
                } else if (odeType === 'oscillator') {
                    return function(t, y) {
                        return [y[1], -parameter * parameter * y[0]];
                    };
                } else if (odeType === 'nonlinear') {
                    return function(t, y) {
                        return [parameter * y[0] * (1 - y[0]), 0];
                    };
                } else if (odeType === 'vanderpol') {
                    return function(t, y) {
                        return [y[1], parameter * (1 - y[0]*y[0]) * y[1] - y[0]];
                    };
                }
            }

            function getExactSolution() {
                if (odeType === 'exponential') {
                    return function(t) {
                        return [Math.exp(-parameter * t), 0];
                    };
                } else if (odeType === 'oscillator') {
                    return function(t) {
                        let y0 = Math.cos(parameter * t);
                        let y1 = -parameter * Math.sin(parameter * t);
                        return [y0, y1];
                    };
                } else if (odeType === 'nonlinear') {
                    return function(t) {
                        return [1 / (1 + (1 - 1) * Math.exp(-parameter * t)), 0];
                    };
                }
                return null; // No exact for Van der Pol
            }

            function getInitialCondition() {
                if (odeType === 'oscillator' || odeType === 'vanderpol') {
                    return [1, 0];
                }
                return [1, 0];
            }

            function solveEuler(f, y0, tMax, h) {
                let result = [{t: 0, y: [...y0]}];
                let y = [...y0];
                let t = 0;

                while (t < tMax) {
                    let dy = f(t, y);
                    y = [y[0] + h * dy[0], y[1] + h * dy[1]];
                    t += h;
                    result.push({t: t, y: [...y]});
                }
                return result;
            }

            function solveRK2(f, y0, tMax, h) {
                let result = [{t: 0, y: [...y0]}];
                let y = [...y0];
                let t = 0;

                while (t < tMax) {
                    let k1 = f(t, y);
                    let yMid = [y[0] + 0.5 * h * k1[0], y[1] + 0.5 * h * k1[1]];
                    let k2 = f(t + 0.5 * h, yMid);
                    y = [y[0] + h * k2[0], y[1] + h * k2[1]];
                    t += h;
                    result.push({t: t, y: [...y]});
                }
                return result;
            }

            function solveRK4(f, y0, tMax, h) {
                let result = [{t: 0, y: [...y0]}];
                let y = [...y0];
                let t = 0;

                while (t < tMax) {
                    let k1 = f(t, y);
                    let y2 = [y[0] + 0.5 * h * k1[0], y[1] + 0.5 * h * k1[1]];
                    let k2 = f(t + 0.5 * h, y2);
                    let y3 = [y[0] + 0.5 * h * k2[0], y[1] + 0.5 * h * k2[1]];
                    let k3 = f(t + 0.5 * h, y3);
                    let y4 = [y[0] + h * k3[0], y[1] + h * k3[1]];
                    let k4 = f(t + h, y4);

                    y = [
                        y[0] + (h/6) * (k1[0] + 2*k2[0] + 2*k3[0] + k4[0]),
                        y[1] + (h/6) * (k1[1] + 2*k2[1] + 2*k3[1] + k4[1])
                    ];
                    t += h;
                    result.push({t: t, y: [...y]});
                }
                return result;
            }

            function solveExact(exactFunc, tMax, h) {
                if (!exactFunc) return [];
                let result = [];
                let t = 0;
                while (t <= tMax) {
                    result.push({t: t, y: exactFunc(t)});
                    t += h * 0.1; // Finer for smooth curve
                }
                return result;
            }

            function solveSystems() {
                let tMax = 5;
                let f = getODEFunction();
                let y0 = getInitialCondition();
                let exactFunc = getExactSolution();

                solutions.euler = solveEuler(f, y0, tMax, stepSize);
                solutions.rk2 = solveRK2(f, y0, tMax, stepSize);
                solutions.rk4 = solveRK4(f, y0, tMax, stepSize);
                solutions.exact = solveExact(exactFunc, tMax, stepSize);

                // Calculate errors
                if (exactFunc) {
                    let yExactFinal = exactFunc(tMax)[0];
                    errors.euler = Math.abs(yExactFinal - solutions.euler[solutions.euler.length-1].y[0]);
                    errors.rk2 = Math.abs(yExactFinal - solutions.rk2[solutions.rk2.length-1].y[0]);
                    errors.rk4 = Math.abs(yExactFinal - solutions.rk4[solutions.rk4.length-1].y[0]);

                    document.getElementById('error-euler').textContent = errors.euler.toExponential(3);
                    document.getElementById('error-rk2').textContent = errors.rk2.toExponential(3);
                    document.getElementById('error-rk4').textContent = errors.rk4.toExponential(3);
                } else {
                    document.getElementById('error-euler').textContent = 'N/A';
                    document.getElementById('error-rk2').textContent = 'N/A';
                    document.getElementById('error-rk4').textContent = 'N/A';
                }

                solved = true;
            }

            p.draw = function() {
                p.background(250);

                if (!solved) {
                    p.fill(100);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(16);
                    p.text('Click "Solve" to generate solutions', canvasWidth/2, canvasHeight/2);
                    return;
                }

                drawPlot();
            };

            function drawPlot() {
                let margin = {left: 70, right: 30, top: 50, bottom: 60};
                let plotW = canvasWidth - margin.left - margin.right;
                let plotH = canvasHeight - margin.top - margin.bottom;
                let plotX = margin.left;
                let plotY = margin.top;

                // Title
                p.fill(0);
                p.textAlign(p.CENTER);
                p.textSize(16);
                p.text('Solution Comparison', canvasWidth/2, 25);

                // Find data ranges
                let tMax = 5;
                let yMin = -2, yMax = 2;

                if (odeType === 'exponential') {
                    yMin = 0; yMax = 1.2;
                } else if (odeType === 'nonlinear') {
                    yMin = 0; yMax = 1.2;
                }

                // Draw axes
                p.stroke(0);
                p.strokeWeight(2);
                p.line(plotX, plotY + plotH, plotX + plotW, plotY + plotH);
                p.line(plotX, plotY, plotX, plotY + plotH);

                // Axis labels
                p.fill(0);
                p.noStroke();
                p.textSize(14);
                p.textAlign(p.CENTER);
                p.text('Time (t)', plotX + plotW/2, plotY + plotH + 45);

                p.push();
                p.translate(plotX - 50, plotY + plotH/2);
                p.rotate(-p.PI/2);
                p.text('y(t)', 0, 0);
                p.pop();

                // Grid
                p.stroke(230);
                p.strokeWeight(1);
                for (let t = 0; t <= tMax; t += 1) {
                    let x = plotX + p.map(t, 0, tMax, 0, plotW);
                    p.line(x, plotY, x, plotY + plotH);
                }

                // Tick marks and labels
                p.fill(0);
                p.textAlign(p.CENTER);
                p.textSize(11);
                for (let t = 0; t <= tMax; t += 1) {
                    let x = plotX + p.map(t, 0, tMax, 0, plotW);
                    p.stroke(0);
                    p.line(x, plotY + plotH, x, plotY + plotH + 5);
                    p.noStroke();
                    p.text(t, x, plotY + plotH + 20);
                }

                p.textAlign(p.RIGHT);
                let yStep = (yMax - yMin) / 4;
                for (let i = 0; i <= 4; i++) {
                    let yVal = yMin + i * yStep;
                    let y = plotY + plotH - p.map(yVal, yMin, yMax, 0, plotH);
                    p.stroke(0);
                    p.line(plotX - 5, y, plotX, y);
                    p.noStroke();
                    p.text(yVal.toFixed(1), plotX - 10, y + 4);
                }

                // Plot solutions
                if (showExact && solutions.exact.length > 0) {
                    plotSolution(solutions.exact, plotX, plotY, plotW, plotH, 0, tMax, yMin, yMax,
                                p.color(0, 150, 0), 2, false);
                }
                if (showEuler) {
                    plotSolution(solutions.euler, plotX, plotY, plotW, plotH, 0, tMax, yMin, yMax,
                                p.color(255, 0, 0), 2, true);
                }
                if (showRK2) {
                    plotSolution(solutions.rk2, plotX, plotY, plotW, plotH, 0, tMax, yMin, yMax,
                                p.color(0, 0, 255), 2, true);
                }
                if (showRK4) {
                    plotSolution(solutions.rk4, plotX, plotY, plotW, plotH, 0, tMax, yMin, yMax,
                                p.color(200, 0, 200), 2, true);
                }

                // Legend
                drawLegend(plotX + plotW - 150, plotY + 10);
            }

            function plotSolution(data, plotX, plotY, plotW, plotH, tMin, tMax, yMin, yMax, color, weight, showPoints) {
                if (data.length === 0) return;

                p.stroke(color);
                p.strokeWeight(weight);
                p.noFill();
                p.beginShape();
                for (let pt of data) {
                    let x = plotX + p.map(pt.t, tMin, tMax, 0, plotW);
                    let y = plotY + plotH - p.map(pt.y[0], yMin, yMax, 0, plotH);
                    p.vertex(x, y);
                }
                p.endShape();

                if (showPoints) {
                    p.fill(color);
                    p.noStroke();
                    for (let pt of data) {
                        let x = plotX + p.map(pt.t, tMin, tMax, 0, plotW);
                        let y = plotY + plotH - p.map(pt.y[0], yMin, yMax, 0, plotH);
                        p.circle(x, y, 4);
                    }
                }
            }

            function drawLegend(x, y) {
                let items = [];
                if (showExact) items.push({label: 'Exact', color: p.color(0, 150, 0)});
                if (showEuler) items.push({label: 'Euler', color: p.color(255, 0, 0)});
                if (showRK2) items.push({label: 'RK2', color: p.color(0, 0, 255)});
                if (showRK4) items.push({label: 'RK4', color: p.color(200, 0, 200)});

                p.fill(255, 255, 255, 230);
                p.stroke(100);
                p.strokeWeight(1);
                p.rect(x, y, 140, 20 + items.length * 20);

                p.textAlign(p.LEFT);
                p.textSize(12);
                items.forEach((item, i) => {
                    p.stroke(item.color);
                    p.strokeWeight(2);
                    p.line(x + 10, y + 15 + i * 20, x + 30, y + 15 + i * 20);
                    p.fill(0);
                    p.noStroke();
                    p.text(item.label, x + 35, y + 19 + i * 20);
                });
            }

            p.windowResized = function() {
                if (p.width > 100) {
                    canvasWidth = Math.min(1000, p.windowWidth - 40);
                    p.resizeCanvas(canvasWidth, canvasHeight);
                }
            };

        }, 'sketch-holder');

        // Quiz submission
        document.getElementById('submit-quiz').addEventListener('click', function() {
            const answers = {
                q1: 'a',
                q2: 'd',
                q3: 'd',
                q4: 'b',
                q5: 'b',
                q6: 'd',
                q7: 'b',
                q8: 'b'
            };

            submitQuiz(
                Object.entries(answers).map(([name, correct]) => ({name, correctAnswer: correct})),
                'quiz-results'
            );
        });
    </script>
</body>
</html>
