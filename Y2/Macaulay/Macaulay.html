<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Macaulay's Method - Interactive Lecture</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="stylesheet" href="/assets/css/simulations.css">
  <link rel="stylesheet" href="/assets/css/uicontrols.css">
  <style>
    :root { --primary: #ffd700; --secondary:#ffb300; --bg:#fffbeb; --text:#222; }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,Arial,sans-serif;background:var(--bg);color:var(--text)}
    header{background:var(--primary);padding:16px 20px}
    header h1{margin:0;font-variant:small-caps}
    .wrap{max-width:1120px;margin:0 auto;padding:16px}
    .panel{background:#fff;border-radius:10px;box-shadow:0 2px 8px rgba(0,0,0,.08);padding:16px}
    #controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(230px,1fr));gap:12px;margin-bottom:12px}
    .control{display:grid;gap:6px}
    select,input[type=range]{width:100%}
    button{background:var(--primary);border:0;border-radius:8px;padding:8px 12px;font-weight:700;cursor:pointer}
    button.toggled{background:#b8860b;color:#fff}
    .muted{opacity:.45;pointer-events:none}
    #sketch-holder{border:1px solid #ddd;border-radius:10px;background:#f9f9f9;overflow:hidden}
    .note{font-size:12px;color:#555}
  </style>
</head>
<body>
  <header>
    <h1>Macaulay's Method</h1>
    <p class="subtitle">Interactive Lecture & Simulation</p>
  </header>

  <div class="content-section">
    <h2>Understanding Macaulay's Method</h2>
    <p>Macaulay's Method, also known as the Macaulay bracket method, is a powerful technique for determining deflections and slopes in beams subjected to various loading conditions. Developed by W. H. Macaulay in 1919, this method provides a systematic approach to handling discontinuous loads.</p>

    <div class="key-point">
      <p><strong>Core Insight:</strong> Macaulay's method uses discontinuity functions (bracket functions) to write a single equation for bending moment that is valid over the entire length of the beam, even when loads change position.</p>
    </div>

    <h3>The Macaulay Bracket Notation</h3>
    <p>The Macaulay bracket is defined as:</p>
    <div class="equation-box">
      <p>\[\langle x - a \rangle^n = \begin{cases}
      (x-a)^n & \text{if } x \geq a \\
      0 & \text{if } x < a
      \end{cases}\]</p>
      <p>where \(a\) is the position where a load or discontinuity occurs.</p>
    </div>

    <h3>Sign Conventions</h3>
    <ul>
      <li><strong>Deflection (v):</strong> Positive downward</li>
      <li><strong>Shear Force (V):</strong> Positive when causing clockwise rotation</li>
      <li><strong>Bending Moment (M):</strong> Positive when causing sagging (tension at bottom)</li>
      <li><strong>Distributed loads (w):</strong> Positive downward</li>
    </ul>

    <h3>Beam Differential Equations</h3>
    <div class="equation-box">
      <p>The fundamental beam relationships are:</p>
      <p>\[\frac{d^2M}{dx^2} = -w(x)\]</p>
      <p>\[\frac{dM}{dx} = V(x)\]</p>
      <p>\[EI\frac{d^2v}{dx^2} = M(x)\]</p>
      <p>where \(E\) is the Young's modulus, \(I\) is the second moment of area, and \(v\) is the deflection.</p>
    </div>

    <h3>Types of Loads in Macaulay's Method for Bending Moment M(x)</h3>
    <p>Macaulay's method is most commonly used to calculate the bending moment diagram M(x). Each type of load contributes to M(x) with a specific exponent:</p>
    <ol>
      <li><strong>Concentrated Moment \(M_0\) at position a:</strong> Contributes \(M_0\langle x - a \rangle^0\) to M(x)
        <br><span class="note">Exponent = 0 (the bracket acts as a step function)</span>
      </li>
      <li><strong>Concentrated Force P at position a:</strong> Contributes \(P\langle x - a \rangle^1\) to M(x)
        <br><span class="note">Exponent = 1 (linear contribution to moment)</span>
      </li>
      <li><strong>Uniformly Distributed Load (UDL) w starting at position a:</strong> Contributes \(\frac{w}{2}\langle x - a \rangle^2\) to M(x)
        <br><span class="note">Exponent = 2 (parabolic contribution to moment)</span>
      </li>
    </ol>

    <div class="key-point">
      <p><strong>Important Note on Partial UDLs:</strong> If a UDL does not extend to the end of the beam, you need to add a <em>compensating</em> term. For example, a downward UDL of magnitude w starting at position a and ending at position b contributes:</p>
      <p>\[M(x) = -\frac{w}{2}\langle x - a \rangle^2 + \frac{w}{2}\langle x - b \rangle^2\]</p>
      <p>The first term "turns on" the UDL at a, and the second term "turns it off" at b by adding an equal and opposite UDL.</p>
    </div>

    <h3>General Procedure</h3>
    <div class="equation-box">
      <ol>
        <li>Determine support reactions using equilibrium equations</li>
        <li>Write the bending moment equation using Macaulay brackets</li>
        <li>Integrate once to get slope: \(EI\frac{dv}{dx} = \int M \, dx + C_1\)</li>
        <li>Integrate again to get deflection: \(EIv = \int\int M \, dx^2 + C_1x + C_2\)</li>
        <li>Apply boundary conditions to find constants \(C_1\) and \(C_2\)</li>
        <li>Calculate slopes and deflections at any point</li>
      </ol>
    </div>

    <div class="key-point">
      <p><strong>Important:</strong> When integrating Macaulay brackets, maintain the bracket notation throughout. Only evaluate when the argument is positive (i.e., when \(x > a\)).</p>
    </div>
  </div>

  <div class="simulation-container">
    <h2>Interactive Beam Simulation</h2>
    <p>Explore how different loading configurations affect beam deflection, shear force, and bending moment diagrams. The simulation uses Macaulay's method for determinate beams and the stiffness method for indeterminate cases.</p>
    <div class="panel">
      <div id="controls">
        <div class="control">
          <label for="beam-type">Beam & Loading</label>
          <select id="beam-type">
            <option value="ss-point">Simply Supported – Point at a</option>
            <option value="ss-udl">Simply Supported – UDL (0→L)</option>
            <option value="ss-combined">Simply Supported – UDL + Point at a</option>
            <option value="cantilever-point">Cantilever – Point at a</option>
            <option value="overhang-right">Overhang (right) – supports at x=0 and x=s, free overhang to L</option>
            <option value="fixed-fixed">Fixed–Fixed – UDL/Point/Combined</option>
            <option value="continuous-3">Continuous (3 supports) – UDL/Point/Combined</option>
          </select>
        </div>
        <div class="control">
          <label for="load-mag">Point Load P (kN)</label>
          <input type="range" id="load-mag" min="0" max="120" step="1" value="20" />
          <div><span id="load-mag-val">20</span> kN</div>
        </div>
        <div class="control" id="pos-ctl">
          <label for="load-pos">Load Position a/L</label>
          <input type="range" id="load-pos" min="0" max="100" step="1" value="50" />
          <div><span id="load-pos-val">0.50</span> L</div>
        </div>
        <div class="control" id="overhang-ctl">
          <label for="support-b">Overhang support position s/L (right support)</label>
          <input type="range" id="support-b" min="40" max="95" step="1" value="80" />
          <div>s = <span id="support-b-val">0.80</span> L</div>
        </div>
        <div class="control">
          <label for="udl-mag">UDL w (kN/m)</label>
          <input type="range" id="udl-mag" min="0" max="60" step="1" value="10" />
          <div><span id="udl-mag-val">10</span> kN/m</div>
          <div class="note">Applies across entire span.</div>
        </div>
        <div class="control">
          <label>Display</label>
          <div>
            <button id="btn-defl" class="toggled">Deflection</button>
            <button id="btn-shear" class="toggled">Shear</button>
            <button id="btn-moment" class="toggled">Moment</button>
          </div>
        </div>
        <div class="control">
          <label for="scale">Deflection Scale (×)</label>
          <input type="range" id="scale" min="10" max="250" step="5" value="70" />
          <div><span id="scale-val">70</span>×</div>
        </div>
      </div>

      <div id="sketch-holder"></div>
      <p class="note" id="msg"></p>
    </div>
  </div>

<script>
// ===================== State =====================
const cfg = {
  beamType:'ss-point', P:20, w:10, a:0.5, s:0.8, L:1.0,
  showDefl:true, showShear:true, showMoment:true, scale:70,
  // Diagram scaling factors (adjust these to change SFD/BMD appearance)
  sfdScale: 2,   // Shear Force Diagram scaling factor
  bmdScale: 6,   // Bending Moment Diagram scaling factor (2x larger than SFD)
};

// UI
const beamSel = document.getElementById('beam-type');
const pSlider = document.getElementById('load-mag'); const pVal=document.getElementById('load-mag-val');
const aSlider = document.getElementById('load-pos'); const aVal=document.getElementById('load-pos-val');
const sSlider = document.getElementById('support-b'); const sVal=document.getElementById('support-b-val');
const posCtl = document.getElementById('pos-ctl'); const overCtl=document.getElementById('overhang-ctl');
const wSlider = document.getElementById('udl-mag'); const wVal=document.getElementById('udl-mag-val');
const btnDefl=document.getElementById('btn-defl'); const btnShear=document.getElementById('btn-shear'); const btnMoment=document.getElementById('btn-moment');
const sScale=document.getElementById('scale'); const sScaleVal=document.getElementById('scale-val');
const msgEl=document.getElementById('msg');

beamSel.onchange = e=>{ cfg.beamType=e.target.value; updateCtl(); };
pSlider.oninput = e=>{ cfg.P=+e.target.value; pVal.textContent=cfg.P; };
aSlider.oninput = e=>{ cfg.a=(+e.target.value)/100; aVal.textContent=cfg.a.toFixed(2);} ;
sSlider.oninput = e=>{ cfg.s=(+e.target.value)/100; if(cfg.s<0.4) cfg.s=0.4; sSlider.value=Math.round(cfg.s*100); sVal.textContent=cfg.s.toFixed(2);} ;
wSlider.oninput = e=>{ cfg.w=+e.target.value; wVal.textContent=cfg.w; };
btnDefl.onclick=()=>{ cfg.showDefl=!cfg.showDefl; btnDefl.classList.toggle('toggled',cfg.showDefl); };
btnShear.onclick=()=>{ cfg.showShear=!cfg.showShear; btnShear.classList.toggle('toggled',cfg.showShear); };
btnMoment.onclick=()=>{ cfg.showMoment=!cfg.showMoment; btnMoment.classList.toggle('toggled',cfg.showMoment); };
sScale.oninput = e=>{ cfg.scale=+e.target.value; sScaleVal.textContent=cfg.scale; };

function updateCtl(){
  // Position slider relevant when point load exists
  const usesPoint = ['ss-point','cantilever-point','ss-combined','overhang-right','fixed-fixed','continuous-3'].includes(cfg.beamType);
  posCtl.classList.toggle('muted', !usesPoint);
  aSlider.disabled=!usesPoint;
  // Overhang slider only for overhang
  overCtl.classList.toggle('muted', cfg.beamType!=='overhang-right');
  sSlider.disabled = cfg.beamType!=='overhang-right';
  // Message
  if(['fixed-fixed','continuous-3'].includes(cfg.beamType)){
    msgEl.textContent = 'Indeterminate: solved via compatibility (stiffness method).';
  } else { msgEl.textContent=''; }
}

// ===================== FE utilities =====================
// Macaulay helpers
function bracket(x,a,p){ if(x<a) return 0; const d=x-a; return p===0?1:Math.pow(d,p); }

// DOF per node: v (vertical), theta (rotation)
function assemble(nodes, supports, loads, wUDL){
  const nN = nodes.length; const ndof=2*nN; const K = Array.from({length:ndof},()=>Array(ndof).fill(0));
  const F = Array(ndof).fill(0);
  // Element assembly with EI=1
  for(let e=0;e<nN-1;e++){
    const x1=nodes[e], x2=nodes[e+1]; const Le=x2-x1; const L3=Math.pow(Le,3);
    const k = [
      [ 12/L3,  6/Math.pow(Le,2), -12/L3,  6/Math.pow(Le,2)],
      [  6/Math.pow(Le,2), 4/Le,   -6/Math.pow(Le,2), 2/Le   ],
      [ -12/L3, -6/Math.pow(Le,2), 12/L3, -6/Math.pow(Le,2)],
      [  6/Math.pow(Le,2), 2/Le,   -6/Math.pow(Le,2), 4/Le   ],
    ];
    const dofs=[2*e,2*e+1,2*(e+1),2*(e+1)+1];
    for(let i=0;i<4;i++) for(let j=0;j<4;j++) K[dofs[i]][dofs[j]] += k[i][j];
    // Equivalent nodal loads for uniform downward wUDL over this element (if any)
    if (wUDL>0){
      const fe = [ wUDL*Le/2,  wUDL*Le*Le/12,  wUDL*Le/2, -wUDL*Le*Le/12 ];
      F[dofs[0]] += -fe[0]; F[dofs[1]] += -fe[1]; F[dofs[2]] += -fe[2]; F[dofs[3]] += -fe[3]; // convert to upward-positive
    }
  }
  // Node point loads (downward)
  for(const pl of loads){ F[2*pl.node] += -pl.P; }

  // Apply supports
  const fixed = new Set();
  supports.forEach(s=>{
    const i = nodes.indexOf(s.x);
    if (i<0) return;
    if (s.v===0){ fixed.add(2*i); }
    if (s.theta===0){ fixed.add(2*i+1); }
  });

  // Reduce and solve
  const free = []; for(let i=0;i<ndof;i++) if(!fixed.has(i)) free.push(i);
  const Kff = free.map(i=>free.map(j=>K[i][j]));
  const Ff = free.map(i=>F[i]);
  const df = solveLinear(Kff, Ff);
  const d = Array(ndof).fill(0); free.forEach((dof,idx)=>{ d[dof]=df[idx]; });

  // Reactions R = K d − F (signs consistent with assembly)
  const R = Array(ndof).fill(0);
  for(let i=0;i<ndof;i++){ let s=0; for(let j=0;j<ndof;j++) s += K[i][j]*d[j]; R[i]=s - F[i]; }
  return {d,R,K,F};
}

function solveLinear(A,b){
  const n=A.length; const M=A.map(r=>r.slice()); const x=b.slice();
  for(let k=0;k<n;k++){
    let piv=k; for(let i=k+1;i<n;i++) if (Math.abs(M[i][k])>Math.abs(M[piv][k])) piv=i;
    if (Math.abs(M[piv][k])<1e-12) continue;
    if (piv!==k){ [M[k],M[piv]]=[M[piv],M[k]]; [x[k],x[piv]]=[x[piv],x[k]]; }
    const akk=M[k][k];
    for(let j=k;j<n;j++) M[k][j]/=akk; x[k]/=akk;
    for(let i=0;i<n;i++) if(i!==k){ const f=M[i][k]; if(Math.abs(f)>0){ for(let j=k;j<n;j++) M[i][j]-=f*M[k][j]; x[i]-=f*x[k]; } }
  }
  return x;
}

// Build model per case
function buildModel(){
  // nodes in [0,1]; include point load location as a node if used
  let nodes=[0,1];
  const usePoint = cfg.P>0 && ['ss-point','cantilever-point','ss-combined','overhang-right','fixed-fixed','continuous-3'].includes(cfg.beamType);
  if (usePoint && cfg.a>0 && cfg.a<1) nodes.push(cfg.a);
  if (cfg.beamType==='overhang-right'){ if (cfg.s>0 && cfg.s<1) nodes.push(cfg.s); }
  if (cfg.beamType==='continuous-3'){ nodes=[0,0.5,1]; if (usePoint && cfg.a!==0 && cfg.a!==0.5 && cfg.a!==1) nodes.push(cfg.a); }
  nodes = Array.from(new Set(nodes)).sort((a,b)=>a-b);

  // supports
  const supports=[];
  if (cfg.beamType==='ss-point' || cfg.beamType==='ss-udl' || cfg.beamType==='ss-combined'){
    supports.push({x:0, v:0}); supports.push({x:1, v:0});
  } else if (cfg.beamType==='cantilever-point'){
    supports.push({x:0, v:0, theta:0});
  } else if (cfg.beamType==='overhang-right'){
    supports.push({x:0, v:0}); supports.push({x:cfg.s, v:0});
  } else if (cfg.beamType==='fixed-fixed'){
    supports.push({x:0, v:0, theta:0}); supports.push({x:1, v:0, theta:0});
  } else if (cfg.beamType==='continuous-3'){
    supports.push({x:0, v:0}); supports.push({x:0.5, v:0}); supports.push({x:1, v:0});
  }

  // loads
  const loads=[];
  if (usePoint){
    const idx = nodes.indexOf(cfg.a);
    if (idx>=0) loads.push({node:idx, P:cfg.P});
  }
  const wUDL = cfg.w>0 ? cfg.w : 0; // kN/m (over full span)
  return {nodes,supports,loads,wUDL};
}

// Build global V(x), M(x) using Macaulay sums and reactions from compatibility solve
function buildVM_Macaulay(model, sol){
  const {nodes} = model;

  // ===== Special case: cantilever (free end at x = 1) =====
  // Compute internal forces from the RIGHT so M(1)=0 and M(x>=a)=0 for point-load-only cases.
  if (cfg.beamType === 'cantilever-point') {
    const P = cfg.P > 0 ? cfg.P : 0;
    const a = cfg.a; // load position from fixed end (0..1)
    const w = model.wUDL > 0 ? model.wUDL : 0; // UDL over 0→1 if toggled

    return {
      // Shear from the right: contributions of loads on the segment (x→1)
      V: function(x){
        let v = 0;
        if (P > 0 && x < a) v -= P;          // point load lies to the right of the cut
        if (w > 0) v -= w * (1 - x);         // UDL on (x→1)
        return v;
      },
      // Moment from the right: zero at the free end by definition
      M: function(x){
        let m = 0;
        if (P > 0 && x < a) m -= P * (a - x);                // linear up to the load
        if (w > 0) m -= 0.5 * w * (1 - x) * (1 - x);         // parabolic from UDL
        return m;
      }
    };
  }

  // ===== Generic Macaulay (existing) for other beam types =====
  const forces=[]; const couples=[];
  for(let i=0;i<nodes.length;i++){
    const atX = nodes[i];
    const hasVfixed = (model.supports||[]).some(s=>s.x===atX && s.v===0);
    if (hasVfixed){ forces.push({x:atX, Q: sol.R[2*i]}); }
    const hasThFixed = (model.supports||[]).some(s=>s.x===atX && s.theta===0);
    if (hasThFixed){ couples.push({x:atX, M: sol.R[2*i+1]}); }
  }
  if (cfg.P>0 && ['ss-point','cantilever-point','ss-combined','overhang-right','fixed-fixed','continuous-3'].includes(cfg.beamType)){
    forces.push({x:cfg.a, Q: -cfg.P}); // downward point load
  }
  const w = model.wUDL>0 ? model.wUDL : 0;

  return {
    V: function(x){
      let V=0; for(const f of forces){ if (x>=f.x) V += f.Q; }
      V += - w * bracket(x,0,1) + w * bracket(x,1,1); // uniform w over [0,1]
      return V;
    },
    M: function(x){
      let M=0; for(const f of forces){ if (x>=f.x) M += f.Q * (x - f.x); }
      for(const c of couples){ if (x>=c.x) M += c.M; }
      M += - (w/2) * bracket(x,0,2) + (w/2) * bracket(x,1,2); // UDL contribution
      return M;
    }
  };
}

// Sampling
function sampler(model, sol){
  const {nodes}=model; const nEl=nodes.length-1; const samples=[];
  const VM = buildVM_Macaulay(model, sol);
  for(let e=0;e<nEl;e++){
    const x1=nodes[e], x2=nodes[e+1]; const Le=x2-x1; const dofs=[2*e,2*e+1,2*(e+1),2*(e+1)+1];
    const d_e=[ sol.d[dofs[0]], sol.d[dofs[1]], sol.d[dofs[2]], sol.d[dofs[3]] ];
    const N=500; for(let i=0;i<=N;i++){
      const s=i/N*Le; const gx=x1 + s;
      const V = VM.V(gx), M = VM.M(gx);
      const v = shapeDisp(Le, d_e, s);
      samples.push({x:gx, V, M, v});
    }
  }
  return samples.sort((a,b)=>a.x-b.x);
}

// Cubic shape function deflection within an element
function shapeDisp(Le, d_e, s){
  const xi = s/Le;
  const N1 = 1 - 3*xi*xi + 2*xi*xi*xi;
  const N2 = Le*(xi - 2*xi*xi + xi*xi*xi);
  const N3 = 3*xi*xi - 2*xi*xi*xi;
  const N4 = Le*(-xi*xi + xi*xi*xi);
  return N1*d_e[0] + N2*d_e[1] + N3*d_e[2] + N4*d_e[3];
}

// ===================== Drawing =====================
let beamY, beamStartX, beamEndX, beamLenPx;

function setup(){ const c=createCanvas(940,650); c.parent('sketch-holder'); updateCtl(); }

function drawSupports(y){
  stroke(0); strokeWeight(2); fill(120); const s=12;
  if (cfg.beamType==='cantilever-point' || cfg.beamType==='fixed-fixed'){
    // left fixed
    rect(beamStartX-12, y-24, 12, 48);
  } else { // left pin
    triangle(beamStartX-s, y+s, beamStartX+s, y+s, beamStartX, y);
  }
  // middle support for continuous-3 at 0.5L
  if (cfg.beamType==='continuous-3'){
    const xm = beamStartX + 0.5*beamLenPx; triangle(xm- s, y+s, xm+ s, y+s, xm, y);
  }
  // right support
  if (cfg.beamType==='fixed-fixed'){
    rect(beamEndX, y-24, 12, 48);
  } else if (cfg.beamType==='cantilever-point'){
    // free end → draw nothing
  } else if (cfg.beamType==='overhang-right'){
    const xr = beamStartX + cfg.s*beamLenPx;
    triangle(xr- s, y+s, xr+ s, y+s, xr, y);
    ellipse(xr-6,y+s+6,8,8); ellipse(xr+6,y+s+6,8,8);
  } else { // simply supported & continuous right
    triangle(beamEndX- s, y+s, beamEndX+ s, y+s, beamEndX, y);
    ellipse(beamEndX-6,y+s+6,8,8); ellipse(beamEndX+6,y+s+6,8,8);
  }
}

function drawArrow(x1,y1,x2,y2){
  strokeWeight(3); line(x1,y1,x2,y2);
  const ang=Math.atan2(y2-y1,x2-x1);
  push(); translate(x2,y2); rotate(ang); line(0,0,-8,-5); line(0,0,-8,5); pop();
}

function drawLoads(y){
  const aPx = beamStartX + cfg.a*beamLenPx;
  if (cfg.w>0){
    stroke(220,0,0);
    // Draw UDL arrows aligned with vertical grid ticks (every beamLenPx/50)
    const tickSpacing = beamLenPx/50;
    for(let i=0; i<=50; i++){
      const x = beamStartX + i*tickSpacing;
      drawArrow(x,y-30,x,y);
    }
    noStroke(); fill(180,0,0); text(`w=${cfg.w} kN/m`, (beamStartX+beamEndX)/2-100, y-40);
  }
  if (cfg.P>0) {stroke(0,200,0); drawArrow(aPx,y-60,aPx,y); noStroke(); fill(0,200,0); text(`${cfg.P} kN`, aPx+25, y-50); }
}

// DEFLECTION
function drawDeflection(samples, yBase){
  stroke(0,0,255); strokeWeight(2); noFill();
  beginShape();
  for(let i=0;i<samples.length;i++){
    const px = beamStartX + samples[i].x*beamLenPx;
    const py = yBase - cfg.scale*samples[i].v; // flipped convention
    vertex(px, py);
  }
  endShape();
  noStroke(); fill(0,0,255);
  const vmax = samples.reduce((m,s)=>Math.max(m,Math.abs(s.v)),0);
  textAlign(CENTER); text(`Max |EIv| (scaled): ${(cfg.scale*vmax).toFixed(2)}`, (beamStartX+beamEndX)/2, height-26);
}

// GENERIC DIAGRAM DRAWER
function drawDiagram(samples, yBase, what){
  const n=samples.length; noFill(); strokeWeight(2);
  if (what==='V'){ stroke(0,120,0); fill(0,120,0,40);} else { stroke(220,0,0); fill(220,0,0,40);}
  // Use separate scaling factors for SFD and BMD
  const scaleFactor = (what==='V') ? cfg.sfdScale : cfg.bmdScale;
  beginShape(); vertex(beamStartX, yBase);
  for(let i=0;i<n;i++){
    const px = beamStartX + samples[i].x*beamLenPx;
    const val = (what==='V') ? samples[i].V : samples[i].M;
    vertex(px, yBase - val*scaleFactor);
  }
  vertex(beamEndX, yBase); endShape(CLOSE);
  noStroke(); fill(what==='V'?color(0,120,0):color(220,0,0));
  textAlign(LEFT); text(what==='V'?'Shear V(x)':'Moment M(x)', beamStartX+8, yBase+18);
}

function draw(){
  background(249);
  beamY = height*0.32; beamStartX = width*0.08; beamEndX = width*0.92; beamLenPx = beamEndX - beamStartX;

  // grid
  stroke(230); for(let i=0;i<=50;i++){ const x=beamStartX + i*beamLenPx/50; line(x, 40, x, height-40); }

  // beam axis
  stroke(150); strokeWeight(3); line(beamStartX, beamY, beamEndX, beamY);
  drawSupports(beamY); drawLoads(beamY);

  // Solve & sample
  const model = buildModel();
  const sol = assemble(model.nodes, model.supports, model.loads, model.wUDL);
  const samples = sampler(model, sol);

  if (cfg.showDefl) drawDeflection(samples, beamY);

  // Shear panel then moment panel below
  const y1 = height * 0.60, y2 = height * 0.82;
  if (cfg.showShear)  drawDiagram(samples, y1, 'V');
  if (cfg.showMoment) drawDiagram(samples, y2, 'M');

  // title
  noStroke(); fill(0); textAlign(CENTER); textSize(14); text(titleText(), width/2, 24);
}

function titleText(){
  switch(cfg.beamType){
    case 'ss-point': return 'Simply Supported – Point at a (Macaulay-compatible)';
    case 'ss-udl': return 'Simply Supported – UDL (Macaulay-compatible)';
    case 'ss-combined': return 'Simply Supported – UDL + Point (Macaulay-compatible)';
    case 'cantilever-point': return 'Cantilever – Point at a';
    case 'overhang-right': return 'Overhang Right – Supports at x=0 & x=s, free end at L';
    case 'fixed-fixed': return 'Fixed–Fixed – Compatibility (stiffness)';
    case 'continuous-3': return 'Continuous (3 supports) – Compatibility (stiffness)';
    default: return 'Beam';
  }
}
</script>

</div> <!-- End simulation-container -->

<div class="content-section">
  <h2>Practice Problems</h2>

  <div class="practice-problems">
    <h3>Problem 1: Simply Supported Beam with Point Load</h3>
    <p>A simply supported beam of length L = 6 m carries a point load P = 10 kN at a distance a = 2 m from the left support. The beam has EI = 12000 kNm². Calculate:</p>
    <ol type="a">
      <li>The maximum deflection and its location</li>
      <li>The slope at the left support</li>
      <li>The slope at the right support</li>
    </ol>

    <p class="toggle-section" onclick="toggleSolution('solution1')">Show Solution</p>
    <div id="solution1" class="hidden">
      <p><strong>Solution:</strong></p>
      <p>First, find reactions: \(R_A = \frac{P(L-a)}{L} = \frac{10(6-2)}{6} = 6.67\) kN</p>
      <p>\(R_B = \frac{Pa}{L} = \frac{10 \times 2}{6} = 3.33\) kN</p>

      <p>Bending moment equation:</p>
      <p>\(M(x) = R_A x - P\langle x - a \rangle^1 = 6.67x - 10\langle x - 2 \rangle^1\)</p>

      <p>Integrate to get slope:</p>
      <p>\(EI\frac{dv}{dx} = \frac{6.67x^2}{2} - \frac{10\langle x - 2 \rangle^2}{2} + C_1\)</p>

      <p>Integrate again for deflection:</p>
      <p>\(EIv = \frac{6.67x^3}{6} - \frac{10\langle x - 2 \rangle^3}{6} + C_1x + C_2\)</p>

      <p>Apply boundary conditions: At \(x = 0\), \(v = 0\) → \(C_2 = 0\)</p>
      <p>At \(x = 6\) m, \(v = 0\) → \(C_1 = -26.67\) kNm²</p>

      <p>Maximum deflection occurs where slope = 0, at approximately x = 2.67 m</p>
      <p>\(v_{max} = -9.88\) mm (downward)</p>
      <p>Slope at left support: \(\theta_A = -2.22 \times 10^{-3}\) rad</p>
      <p>Slope at right support: \(\theta_B = 1.11 \times 10^{-3}\) rad</p>
    </div>
  </div>

  <div class="practice-problems">
    <h3>Problem 2: Cantilever with UDL</h3>
    <p>A cantilever beam of length L = 4 m is fixed at the left end and carries a uniformly distributed load w = 5 kN/m over its entire length. EI = 8000 kNm². Find the deflection and slope at the free end.</p>

    <p class="toggle-section" onclick="toggleSolution('solution2')">Show Solution</p>
    <div id="solution2" class="hidden">
      <p><strong>Solution:</strong></p>
      <p>For a cantilever with UDL over entire length, moment from right end:</p>
      <p>\(M(x) = -\frac{w(L-x)^2}{2} = -\frac{5(4-x)^2}{2}\)</p>

      <p>Or using Macaulay notation from left:</p>
      <p>\(M(x) = -wL(x) + \frac{w}{2}\langle x - 0 \rangle^2 + \frac{wL^2}{2}\)</p>

      <p>Integrating twice and applying boundary conditions at x = 0:</p>
      <p>\(v(0) = 0\) and \(\frac{dv}{dx}(0) = 0\)</p>

      <p>At the free end (x = L = 4 m):</p>
      <p>Deflection: \(v(L) = \frac{wL^4}{8EI} = \frac{5 \times 4^4}{8 \times 8000} = 0.020\) m = 20 mm (downward)</p>
      <p>Slope: \(\theta(L) = \frac{wL^3}{6EI} = \frac{5 \times 4^3}{6 \times 8000} = 0.00667\) rad</p>
    </div>
  </div>

  <div class="practice-problems">
    <h3>Problem 3: Simply Supported Beam with Partial UDL</h3>
    <p>A simply supported beam of length L = 8 m carries a uniformly distributed load w = 12 kN/m that starts at x = 2 m and ends at x = 6 m. The beam has EI = 15000 kNm². Calculate:</p>
    <ol type="a">
      <li>The support reactions at A (x = 0) and B (x = 8 m)</li>
      <li>The bending moment equation using Macaulay's method</li>
      <li>The maximum bending moment and its location</li>
    </ol>

    <p class="toggle-section" onclick="toggleSolution('solution3')">Show Solution</p>
    <div id="solution3" class="hidden">
      <p><strong>Solution:</strong></p>
      <p><em>Part (a): Support Reactions</em></p>
      <p>Total load: \(W = w \times (6-2) = 12 \times 4 = 48\) kN acting at midpoint x = 4 m</p>
      <p>Taking moments about A:</p>
      <p>\(R_B \times 8 = 48 \times 4\) → \(R_B = 24\) kN</p>
      <p>\(R_A = 48 - 24 = 24\) kN</p>

      <p><em>Part (b): Bending Moment Equation</em></p>
      <p>Using Macaulay's method with the partial UDL notation:</p>
      <p>\(M(x) = R_A x - \frac{w}{2}\langle x - 2 \rangle^2 + \frac{w}{2}\langle x - 6 \rangle^2\)</p>
      <p>\(M(x) = 24x - 6\langle x - 2 \rangle^2 + 6\langle x - 6 \rangle^2\)</p>

      <p><em>Part (c): Maximum Bending Moment</em></p>
      <p>The maximum moment occurs where shear force V = 0.</p>
      <p>\(\frac{dM}{dx} = V(x) = 24 - 12\langle x - 2 \rangle^1 + 12\langle x - 6 \rangle^1 = 0\)</p>
      <p>For \(2 < x < 6\): \(24 - 12(x-2) = 0\) → \(x = 4\) m</p>
      <p>\(M_{max} = M(4) = 24(4) - 6(4-2)^2 = 96 - 24 = 72\) kNm</p>
      <p>The maximum bending moment is 72 kNm at x = 4 m (the center of the beam).</p>
    </div>
  </div>
</div>

<div class="content-section">
  <h2>Applications and Examples</h2>
  <p>Macaulay's method is an essential tool in structural beam analysis:</p>
  <ul>
    <li><strong>Building Design:</strong> Analyzing floor beams with multiple point loads from columns, walls, and distributed loads from occupants and equipment.</li>
    <li><strong>Bridge Engineering:</strong> Calculating deflections in bridge girders subjected to concentrated wheel loads and distributed traffic loads.</li>
    <li><strong>Crane Design:</strong> Determining deflections in crane beams under moving loads to ensure safe operation and prevent excessive sway.</li>
    <li><strong>Aircraft Structures:</strong> Analyzing wing spars with discrete attachment points and distributed aerodynamic loads.</li>
    <li><strong>Machine Frames:</strong> Evaluating deflections in machine beds and frames supporting concentrated equipment loads.</li>
    <li><strong>Formwork Design:</strong> Calculating temporary support beam deflections under construction loads with multiple support points.</li>
  </ul>
</div>

<div class="content-section">
  <h2>Knowledge Check Quiz</h2>

  <div class="quiz-container">
    <div class="quiz-question">
      <p><strong>Question 1:</strong> What is the key advantage of Macaulay's method over traditional integration methods?</p>
      <form id="q1">
        <input type="radio" id="q1a" name="q1" value="a">
        <label for="q1a">a) It is computationally faster</label><br>
        <input type="radio" id="q1b" name="q1" value="b">
        <label for="q1b">b) It allows writing a single equation valid for the entire beam length</label><br>
        <input type="radio" id="q1c" name="q1" value="c">
        <label for="q1c">c) It only works for determinate beams</label><br>
        <input type="radio" id="q1d" name="q1" value="d">
        <label for="q1d">d) It eliminates the need for boundary conditions</label><br>
        <button type="button" onclick="checkAnswer('q1', 'b')">Check Answer</button>
      </form>
      <div id="q1-feedback" class="feedback"></div>
    </div>

    <div class="quiz-question">
      <p><strong>Question 2:</strong> For a point load P at position 'a', how is it represented in Macaulay notation?</p>
      <form id="q2">
        <input type="radio" id="q2a" name="q2" value="a">
        <label for="q2a">a) \(P(x - a)\)</label><br>
        <input type="radio" id="q2b" name="q2" value="b">
        <label for="q2b">b) \(P\langle x - a \rangle^0\)</label><br>
        <input type="radio" id="q2c" name="q2" value="c">
        <label for="q2c">c) \(P\langle x - a \rangle^1\)</label><br>
        <input type="radio" id="q2d" name="q2" value="d">
        <label for="q2d">d) \(P\langle x - a \rangle^2\)</label><br>
        <button type="button" onclick="checkAnswer('q2', 'b')">Check Answer</button>
      </form>
      <div id="q2-feedback" class="feedback"></div>
    </div>

    <div class="quiz-question">
      <p><strong>Question 3:</strong> What happens to a Macaulay bracket \(\langle x - a \rangle^n\) when \(x < a\)?</p>
      <form id="q3">
        <input type="radio" id="q3a" name="q3" value="a">
        <label for="q3a">a) It equals \((x-a)^n\)</label><br>
        <input type="radio" id="q3b" name="q3" value="b">
        <label for="q3b">b) It equals zero</label><br>
        <input type="radio" id="q3c" name="q3" value="c">
        <label for="q3c">c) It equals \(a^n\)</label><br>
        <input type="radio" id="q3d" name="q3" value="d">
        <label for="q3d">d) It is undefined</label><br>
        <button type="button" onclick="checkAnswer('q3', 'b')">Check Answer</button>
      </form>
      <div id="q3-feedback" class="feedback"></div>
    </div>

    <div class="quiz-question">
      <p><strong>Question 4:</strong> In Macaulay's method for calculating bending moment M(x), what exponent is used for a concentrated moment \(M_0\) at position a?</p>
      <form id="q4">
        <input type="radio" id="q4a" name="q4" value="a">
        <label for="q4a">a) Exponent = -1</label><br>
        <input type="radio" id="q4b" name="q4" value="b">
        <label for="q4b">b) Exponent = 0</label><br>
        <input type="radio" id="q4c" name="q4" value="c">
        <label for="q4c">c) Exponent = 1</label><br>
        <input type="radio" id="q4d" name="q4" value="d">
        <label for="q4d">d) Exponent = 2</label><br>
        <button type="button" onclick="checkAnswer('q4', 'b')">Check Answer</button>
      </form>
      <div id="q4-feedback" class="feedback"></div>
    </div>

    <div class="quiz-question">
      <p><strong>Question 5:</strong> A UDL of magnitude w starts at x = a and ends at x = b (where b < L). How is this represented in the bending moment equation M(x)?</p>
      <form id="q5">
        <input type="radio" id="q5a" name="q5" value="a">
        <label for="q5a">a) \(M(x) = -\frac{w}{2}\langle x - a \rangle^2\)</label><br>
        <input type="radio" id="q5b" name="q5" value="b">
        <label for="q5b">b) \(M(x) = -\frac{w}{2}\langle x - a \rangle^2 + \frac{w}{2}\langle x - b \rangle^2\)</label><br>
        <input type="radio" id="q5c" name="q5" value="c">
        <label for="q5c">c) \(M(x) = -\frac{w}{2}\langle x - b \rangle^2\)</label><br>
        <input type="radio" id="q5d" name="q5" value="d">
        <label for="q5d">d) \(M(x) = -w\langle x - a \rangle^1 + w\langle x - b \rangle^1\)</label><br>
        <button type="button" onclick="checkAnswer('q5', 'b')">Check Answer</button>
      </form>
      <div id="q5-feedback" class="feedback"></div>
    </div>
  </div>
</div>

<div class="content-section">
  <h2>Summary of Key Equations</h2>
  <div class="key-point">
    <h3>Key Takeaways</h3>
    <ol>
      <li>Macaulay's method uses bracket notation to handle discontinuities in beam loading</li>
      <li>A single equation can describe bending moment over the entire beam length</li>
      <li>The method is particularly efficient for beams with multiple point loads</li>
      <li>Boundary conditions are applied after integration to find constants</li>
      <li>For indeterminate beams, the stiffness (compatibility) method is required</li>
    </ol>
  </div>
</div>

<script>
// toggleSolution function now loaded from /assets/common/problems.js
// checkAnswer function now loaded from /assets/common/quizzes.js
</script>

<footer>
  <script src="/assets/common/footer.js"></script>
</footer>

<!-- Common JavaScript functions -->
<script src="/assets/common/problems.js"></script>
<script src="/assets/common/quizzes.js"></script>
</body>
</html>
