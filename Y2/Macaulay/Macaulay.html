<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Macaulay's Method</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="stylesheet" href="/assets/css/simulations.css">
  <style>
    :root { --primary: #ffd700; --secondary:#ffb300; --bg:#fffbeb; --text:#222; }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,Arial,sans-serif;background:var(--bg);color:var(--text)}
    header{background:var(--primary);padding:16px 20px}
    header h1{margin:0;font-variant:small-caps}
    .wrap{max-width:1120px;margin:0 auto;padding:16px}
    .panel{background:#fff;border-radius:10px;box-shadow:0 2px 8px rgba(0,0,0,.08);padding:16px}
    #controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(230px,1fr));gap:12px;margin-bottom:12px}
    .control{display:grid;gap:6px}
    select,input[type=range]{width:100%}
    button{background:var(--primary);border:0;border-radius:8px;padding:8px 12px;font-weight:700;cursor:pointer}
    button.toggled{background:#b8860b;color:#fff}
    .muted{opacity:.45;pointer-events:none}
    #sketch-holder{border:1px solid #ddd;border-radius:10px;background:#f9f9f9;overflow:hidden}
    .note{font-size:12px;color:#555}
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>Macaulay's Method – Interactive Beam</h1>
      <div class="note">Determinate diagrams use Macaulay. Indeterminate cases solved by compatibility (stiffness), not the force method.</div>
    </div>
  </header>

  <div class="wrap">
    <div class="panel">
      <div id="controls">
        <div class="control">
          <label for="beam-type">Beam & Loading</label>
          <select id="beam-type">
            <option value="ss-point">Simply Supported – Point at a</option>
            <option value="ss-udl">Simply Supported – UDL (0→L)</option>
            <option value="ss-combined">Simply Supported – UDL + Point at a</option>
            <option value="cantilever-point">Cantilever – Point at a</option>
            <option value="overhang-right">Overhang (right) – supports at x=0 and x=s, free overhang to L</option>
            <option value="fixed-fixed">Fixed–Fixed – UDL/Point/Combined</option>
            <option value="continuous-3">Continuous (3 supports) – UDL/Point/Combined</option>
          </select>
        </div>
        <div class="control">
          <label for="load-mag">Point Load P (kN)</label>
          <input type="range" id="load-mag" min="0" max="120" step="1" value="20" />
          <div><span id="load-mag-val">20</span> kN</div>
        </div>
        <div class="control" id="pos-ctl">
          <label for="load-pos">Load Position a/L</label>
          <input type="range" id="load-pos" min="0" max="100" step="1" value="50" />
          <div><span id="load-pos-val">0.50</span> L</div>
        </div>
        <div class="control" id="overhang-ctl">
          <label for="support-b">Overhang support position s/L (right support)</label>
          <input type="range" id="support-b" min="40" max="95" step="1" value="80" />
          <div>s = <span id="support-b-val">0.80</span> L</div>
        </div>
        <div class="control">
          <label for="udl-mag">UDL w (kN/m)</label>
          <input type="range" id="udl-mag" min="0" max="60" step="1" value="10" />
          <div><span id="udl-mag-val">10</span> kN/m</div>
          <div class="note">Applies across entire span.</div>
        </div>
        <div class="control">
          <label>Display</label>
          <div>
            <button id="btn-defl" class="toggled">Deflection</button>
            <button id="btn-shear" class="toggled">Shear</button>
            <button id="btn-moment" class="toggled">Moment</button>
          </div>
        </div>
        <div class="control">
          <label for="scale">Deflection Scale (×)</label>
          <input type="range" id="scale" min="10" max="250" step="5" value="70" />
          <div><span id="scale-val">70</span>×</div>
        </div>
      </div>

      <div id="sketch-holder"></div>
      <p class="note" id="msg"></p>
    </div>
  </div>

<script>
// ===================== State =====================
const cfg = {
  beamType:'ss-point', P:20, w:10, a:0.5, s:0.8, L:1.0,
  showDefl:true, showShear:true, showMoment:true, scale:70,
  // Diagram scaling factors (adjust these to change SFD/BMD appearance)
  sfdScale: 2,   // Shear Force Diagram scaling factor
  bmdScale: 6,   // Bending Moment Diagram scaling factor (2x larger than SFD)
};

// UI
const beamSel = document.getElementById('beam-type');
const pSlider = document.getElementById('load-mag'); const pVal=document.getElementById('load-mag-val');
const aSlider = document.getElementById('load-pos'); const aVal=document.getElementById('load-pos-val');
const sSlider = document.getElementById('support-b'); const sVal=document.getElementById('support-b-val');
const posCtl = document.getElementById('pos-ctl'); const overCtl=document.getElementById('overhang-ctl');
const wSlider = document.getElementById('udl-mag'); const wVal=document.getElementById('udl-mag-val');
const btnDefl=document.getElementById('btn-defl'); const btnShear=document.getElementById('btn-shear'); const btnMoment=document.getElementById('btn-moment');
const sScale=document.getElementById('scale'); const sScaleVal=document.getElementById('scale-val');
const msgEl=document.getElementById('msg');

beamSel.onchange = e=>{ cfg.beamType=e.target.value; updateCtl(); };
pSlider.oninput = e=>{ cfg.P=+e.target.value; pVal.textContent=cfg.P; };
aSlider.oninput = e=>{ cfg.a=(+e.target.value)/100; aVal.textContent=cfg.a.toFixed(2);} ;
sSlider.oninput = e=>{ cfg.s=(+e.target.value)/100; if(cfg.s<0.4) cfg.s=0.4; sSlider.value=Math.round(cfg.s*100); sVal.textContent=cfg.s.toFixed(2);} ;
wSlider.oninput = e=>{ cfg.w=+e.target.value; wVal.textContent=cfg.w; };
btnDefl.onclick=()=>{ cfg.showDefl=!cfg.showDefl; btnDefl.classList.toggle('toggled',cfg.showDefl); };
btnShear.onclick=()=>{ cfg.showShear=!cfg.showShear; btnShear.classList.toggle('toggled',cfg.showShear); };
btnMoment.onclick=()=>{ cfg.showMoment=!cfg.showMoment; btnMoment.classList.toggle('toggled',cfg.showMoment); };
sScale.oninput = e=>{ cfg.scale=+e.target.value; sScaleVal.textContent=cfg.scale; };

function updateCtl(){
  // Position slider relevant when point load exists
  const usesPoint = ['ss-point','cantilever-point','ss-combined','overhang-right','fixed-fixed','continuous-3'].includes(cfg.beamType);
  posCtl.classList.toggle('muted', !usesPoint);
  aSlider.disabled=!usesPoint;
  // Overhang slider only for overhang
  overCtl.classList.toggle('muted', cfg.beamType!=='overhang-right');
  sSlider.disabled = cfg.beamType!=='overhang-right';
  // Message
  if(['fixed-fixed','continuous-3'].includes(cfg.beamType)){
    msgEl.textContent = 'Indeterminate: solved via compatibility (stiffness method).';
  } else { msgEl.textContent=''; }
}

// ===================== FE utilities =====================
// Macaulay helpers
function bracket(x,a,p){ if(x<a) return 0; const d=x-a; return p===0?1:Math.pow(d,p); }

// DOF per node: v (vertical), theta (rotation)
function assemble(nodes, supports, loads, wUDL){
  const nN = nodes.length; const ndof=2*nN; const K = Array.from({length:ndof},()=>Array(ndof).fill(0));
  const F = Array(ndof).fill(0);
  // Element assembly with EI=1
  for(let e=0;e<nN-1;e++){
    const x1=nodes[e], x2=nodes[e+1]; const Le=x2-x1; const L3=Math.pow(Le,3);
    const k = [
      [ 12/L3,  6/Math.pow(Le,2), -12/L3,  6/Math.pow(Le,2)],
      [  6/Math.pow(Le,2), 4/Le,   -6/Math.pow(Le,2), 2/Le   ],
      [ -12/L3, -6/Math.pow(Le,2), 12/L3, -6/Math.pow(Le,2)],
      [  6/Math.pow(Le,2), 2/Le,   -6/Math.pow(Le,2), 4/Le   ],
    ];
    const dofs=[2*e,2*e+1,2*(e+1),2*(e+1)+1];
    for(let i=0;i<4;i++) for(let j=0;j<4;j++) K[dofs[i]][dofs[j]] += k[i][j];
    // Equivalent nodal loads for uniform downward wUDL over this element (if any)
    if (wUDL>0){
      const fe = [ wUDL*Le/2,  wUDL*Le*Le/12,  wUDL*Le/2, -wUDL*Le*Le/12 ];
      F[dofs[0]] += -fe[0]; F[dofs[1]] += -fe[1]; F[dofs[2]] += -fe[2]; F[dofs[3]] += -fe[3]; // convert to upward-positive
    }
  }
  // Node point loads (downward)
  for(const pl of loads){ F[2*pl.node] += -pl.P; }

  // Apply supports
  const fixed = new Set();
  supports.forEach(s=>{
    const i = nodes.indexOf(s.x);
    if (i<0) return;
    if (s.v===0){ fixed.add(2*i); }
    if (s.theta===0){ fixed.add(2*i+1); }
  });

  // Reduce and solve
  const free = []; for(let i=0;i<ndof;i++) if(!fixed.has(i)) free.push(i);
  const Kff = free.map(i=>free.map(j=>K[i][j]));
  const Ff = free.map(i=>F[i]);
  const df = solveLinear(Kff, Ff);
  const d = Array(ndof).fill(0); free.forEach((dof,idx)=>{ d[dof]=df[idx]; });

  // Reactions R = K d − F (signs consistent with assembly)
  const R = Array(ndof).fill(0);
  for(let i=0;i<ndof;i++){ let s=0; for(let j=0;j<ndof;j++) s += K[i][j]*d[j]; R[i]=s - F[i]; }
  return {d,R,K,F};
}

function solveLinear(A,b){
  const n=A.length; const M=A.map(r=>r.slice()); const x=b.slice();
  for(let k=0;k<n;k++){
    let piv=k; for(let i=k+1;i<n;i++) if (Math.abs(M[i][k])>Math.abs(M[piv][k])) piv=i;
    if (Math.abs(M[piv][k])<1e-12) continue;
    if (piv!==k){ [M[k],M[piv]]=[M[piv],M[k]]; [x[k],x[piv]]=[x[piv],x[k]]; }
    const akk=M[k][k];
    for(let j=k;j<n;j++) M[k][j]/=akk; x[k]/=akk;
    for(let i=0;i<n;i++) if(i!==k){ const f=M[i][k]; if(Math.abs(f)>0){ for(let j=k;j<n;j++) M[i][j]-=f*M[k][j]; x[i]-=f*x[k]; } }
  }
  return x;
}

// Build model per case
function buildModel(){
  // nodes in [0,1]; include point load location as a node if used
  let nodes=[0,1];
  const usePoint = cfg.P>0 && ['ss-point','cantilever-point','ss-combined','overhang-right','fixed-fixed','continuous-3'].includes(cfg.beamType);
  if (usePoint && cfg.a>0 && cfg.a<1) nodes.push(cfg.a);
  if (cfg.beamType==='overhang-right'){ if (cfg.s>0 && cfg.s<1) nodes.push(cfg.s); }
  if (cfg.beamType==='continuous-3'){ nodes=[0,0.5,1]; if (usePoint && cfg.a!==0 && cfg.a!==0.5 && cfg.a!==1) nodes.push(cfg.a); }
  nodes = Array.from(new Set(nodes)).sort((a,b)=>a-b);

  // supports
  const supports=[];
  if (cfg.beamType==='ss-point' || cfg.beamType==='ss-udl' || cfg.beamType==='ss-combined'){
    supports.push({x:0, v:0}); supports.push({x:1, v:0});
  } else if (cfg.beamType==='cantilever-point'){
    supports.push({x:0, v:0, theta:0});
  } else if (cfg.beamType==='overhang-right'){
    supports.push({x:0, v:0}); supports.push({x:cfg.s, v:0});
  } else if (cfg.beamType==='fixed-fixed'){
    supports.push({x:0, v:0, theta:0}); supports.push({x:1, v:0, theta:0});
  } else if (cfg.beamType==='continuous-3'){
    supports.push({x:0, v:0}); supports.push({x:0.5, v:0}); supports.push({x:1, v:0});
  }

  // loads
  const loads=[];
  if (usePoint){
    const idx = nodes.indexOf(cfg.a);
    if (idx>=0) loads.push({node:idx, P:cfg.P});
  }
  const wUDL = cfg.w>0 ? cfg.w : 0; // kN/m (over full span)
  return {nodes,supports,loads,wUDL};
}

// Build global V(x), M(x) using Macaulay sums and reactions from compatibility solve
function buildVM_Macaulay(model, sol){
  const {nodes} = model;

  // ===== Special case: cantilever (free end at x = 1) =====
  // Compute internal forces from the RIGHT so M(1)=0 and M(x>=a)=0 for point-load-only cases.
  if (cfg.beamType === 'cantilever-point') {
    const P = cfg.P > 0 ? cfg.P : 0;
    const a = cfg.a; // load position from fixed end (0..1)
    const w = model.wUDL > 0 ? model.wUDL : 0; // UDL over 0→1 if toggled

    return {
      // Shear from the right: contributions of loads on the segment (x→1)
      V: function(x){
        let v = 0;
        if (P > 0 && x < a) v -= P;          // point load lies to the right of the cut
        if (w > 0) v -= w * (1 - x);         // UDL on (x→1)
        return v;
      },
      // Moment from the right: zero at the free end by definition
      M: function(x){
        let m = 0;
        if (P > 0 && x < a) m -= P * (a - x);                // linear up to the load
        if (w > 0) m -= 0.5 * w * (1 - x) * (1 - x);         // parabolic from UDL
        return m;
      }
    };
  }

  // ===== Generic Macaulay (existing) for other beam types =====
  const forces=[]; const couples=[];
  for(let i=0;i<nodes.length;i++){
    const atX = nodes[i];
    const hasVfixed = (model.supports||[]).some(s=>s.x===atX && s.v===0);
    if (hasVfixed){ forces.push({x:atX, Q: sol.R[2*i]}); }
    const hasThFixed = (model.supports||[]).some(s=>s.x===atX && s.theta===0);
    if (hasThFixed){ couples.push({x:atX, M: sol.R[2*i+1]}); }
  }
  if (cfg.P>0 && ['ss-point','cantilever-point','ss-combined','overhang-right','fixed-fixed','continuous-3'].includes(cfg.beamType)){
    forces.push({x:cfg.a, Q: -cfg.P}); // downward point load
  }
  const w = model.wUDL>0 ? model.wUDL : 0;

  return {
    V: function(x){
      let V=0; for(const f of forces){ if (x>=f.x) V += f.Q; }
      V += - w * bracket(x,0,1) + w * bracket(x,1,1); // uniform w over [0,1]
      return V;
    },
    M: function(x){
      let M=0; for(const f of forces){ if (x>=f.x) M += f.Q * (x - f.x); }
      for(const c of couples){ if (x>=c.x) M += c.M; }
      M += - (w/2) * bracket(x,0,2) + (w/2) * bracket(x,1,2); // UDL contribution
      return M;
    }
  };
}

// Sampling
function sampler(model, sol){
  const {nodes}=model; const nEl=nodes.length-1; const samples=[];
  const VM = buildVM_Macaulay(model, sol);
  for(let e=0;e<nEl;e++){
    const x1=nodes[e], x2=nodes[e+1]; const Le=x2-x1; const dofs=[2*e,2*e+1,2*(e+1),2*(e+1)+1];
    const d_e=[ sol.d[dofs[0]], sol.d[dofs[1]], sol.d[dofs[2]], sol.d[dofs[3]] ];
    const N=500; for(let i=0;i<=N;i++){
      const s=i/N*Le; const gx=x1 + s;
      const V = VM.V(gx), M = VM.M(gx);
      const v = shapeDisp(Le, d_e, s);
      samples.push({x:gx, V, M, v});
    }
  }
  return samples.sort((a,b)=>a.x-b.x);
}

// Cubic shape function deflection within an element
function shapeDisp(Le, d_e, s){
  const xi = s/Le;
  const N1 = 1 - 3*xi*xi + 2*xi*xi*xi;
  const N2 = Le*(xi - 2*xi*xi + xi*xi*xi);
  const N3 = 3*xi*xi - 2*xi*xi*xi;
  const N4 = Le*(-xi*xi + xi*xi*xi);
  return N1*d_e[0] + N2*d_e[1] + N3*d_e[2] + N4*d_e[3];
}

// ===================== Drawing =====================
let beamY, beamStartX, beamEndX, beamLenPx;

function setup(){ const c=createCanvas(940,650); c.parent('sketch-holder'); updateCtl(); }

function drawSupports(y){
  stroke(0); strokeWeight(2); fill(120); const s=12;
  if (cfg.beamType==='cantilever-point' || cfg.beamType==='fixed-fixed'){
    // left fixed
    rect(beamStartX-12, y-24, 12, 48);
  } else { // left pin
    triangle(beamStartX-s, y+s, beamStartX+s, y+s, beamStartX, y);
  }
  // middle support for continuous-3 at 0.5L
  if (cfg.beamType==='continuous-3'){
    const xm = beamStartX + 0.5*beamLenPx; triangle(xm- s, y+s, xm+ s, y+s, xm, y);
  }
  // right support
  if (cfg.beamType==='fixed-fixed'){
    rect(beamEndX, y-24, 12, 48);
  } else if (cfg.beamType==='cantilever-point'){
    // free end → draw nothing
  } else if (cfg.beamType==='overhang-right'){
    const xr = beamStartX + cfg.s*beamLenPx;
    triangle(xr- s, y+s, xr+ s, y+s, xr, y);
    ellipse(xr-6,y+s+6,8,8); ellipse(xr+6,y+s+6,8,8);
  } else { // simply supported & continuous right
    triangle(beamEndX- s, y+s, beamEndX+ s, y+s, beamEndX, y);
    ellipse(beamEndX-6,y+s+6,8,8); ellipse(beamEndX+6,y+s+6,8,8);
  }
}

function drawArrow(x1,y1,x2,y2){
  strokeWeight(3); line(x1,y1,x2,y2);
  const ang=Math.atan2(y2-y1,x2-x1);
  push(); translate(x2,y2); rotate(ang); line(0,0,-8,-5); line(0,0,-8,5); pop();
}

function drawLoads(y){
  const aPx = beamStartX + cfg.a*beamLenPx;
  if (cfg.w>0){
    stroke(220,0,0);
    // Draw UDL arrows aligned with vertical grid ticks (every beamLenPx/50)
    const tickSpacing = beamLenPx/50;
    for(let i=0; i<=50; i++){
      const x = beamStartX + i*tickSpacing;
      drawArrow(x,y-30,x,y);
    }
    noStroke(); fill(180,0,0); text(`w=${cfg.w} kN/m`, (beamStartX+beamEndX)/2-100, y-40);
  }
  if (cfg.P>0) {stroke(0,200,0); drawArrow(aPx,y-60,aPx,y); noStroke(); fill(0,200,0); text(`${cfg.P} kN`, aPx+25, y-50); }
}

// DEFLECTION
function drawDeflection(samples, yBase){
  stroke(0,0,255); strokeWeight(2); noFill();
  beginShape();
  for(let i=0;i<samples.length;i++){
    const px = beamStartX + samples[i].x*beamLenPx;
    const py = yBase - cfg.scale*samples[i].v; // flipped convention
    vertex(px, py);
  }
  endShape();
  noStroke(); fill(0,0,255);
  const vmax = samples.reduce((m,s)=>Math.max(m,Math.abs(s.v)),0);
  textAlign(CENTER); text(`Max |EIv| (scaled): ${(cfg.scale*vmax).toFixed(2)}`, (beamStartX+beamEndX)/2, height-26);
}

// GENERIC DIAGRAM DRAWER
function drawDiagram(samples, yBase, what){
  const n=samples.length; noFill(); strokeWeight(2);
  if (what==='V'){ stroke(0,120,0); fill(0,120,0,40);} else { stroke(220,0,0); fill(220,0,0,40);}
  // Use separate scaling factors for SFD and BMD
  const scaleFactor = (what==='V') ? cfg.sfdScale : cfg.bmdScale;
  beginShape(); vertex(beamStartX, yBase);
  for(let i=0;i<n;i++){
    const px = beamStartX + samples[i].x*beamLenPx;
    const val = (what==='V') ? samples[i].V : samples[i].M;
    vertex(px, yBase - val*scaleFactor);
  }
  vertex(beamEndX, yBase); endShape(CLOSE);
  noStroke(); fill(what==='V'?color(0,120,0):color(220,0,0));
  textAlign(LEFT); text(what==='V'?'Shear V(x)':'Moment M(x)', beamStartX+8, yBase+18);
}

function draw(){
  background(249);
  beamY = height*0.32; beamStartX = width*0.08; beamEndX = width*0.92; beamLenPx = beamEndX - beamStartX;

  // grid
  stroke(230); for(let i=0;i<=50;i++){ const x=beamStartX + i*beamLenPx/50; line(x, 40, x, height-40); }

  // beam axis
  stroke(150); strokeWeight(3); line(beamStartX, beamY, beamEndX, beamY);
  drawSupports(beamY); drawLoads(beamY);

  // Solve & sample
  const model = buildModel();
  const sol = assemble(model.nodes, model.supports, model.loads, model.wUDL);
  const samples = sampler(model, sol);

  if (cfg.showDefl) drawDeflection(samples, beamY);

  // Shear panel then moment panel below
  const y1 = height * 0.60, y2 = height * 0.82;
  if (cfg.showShear)  drawDiagram(samples, y1, 'V');
  if (cfg.showMoment) drawDiagram(samples, y2, 'M');

  // title
  noStroke(); fill(0); textAlign(CENTER); textSize(14); text(titleText(), width/2, 24);
}

function titleText(){
  switch(cfg.beamType){
    case 'ss-point': return 'Simply Supported – Point at a (Macaulay-compatible)';
    case 'ss-udl': return 'Simply Supported – UDL (Macaulay-compatible)';
    case 'ss-combined': return 'Simply Supported – UDL + Point (Macaulay-compatible)';
    case 'cantilever-point': return 'Cantilever – Point at a';
    case 'overhang-right': return 'Overhang Right – Supports at x=0 & x=s, free end at L';
    case 'fixed-fixed': return 'Fixed–Fixed – Compatibility (stiffness)';
    case 'continuous-3': return 'Continuous (3 supports) – Compatibility (stiffness)';
    default: return 'Beam';
  }
}
</script>
<footer>
  <script src="/assets/common/footer.js"></script>
</footer>
</body>
</html>
