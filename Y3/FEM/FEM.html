<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Finite Element Method Introduction - Interactive Lecture</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="/assets/css/problems.css">
    <link rel="stylesheet" href="/assets/css/quizzes.css">
    <link rel="stylesheet" href="/assets/css/simulations.css">
    <link rel="stylesheet" href="/assets/css/uicontrols.css">
</head>
<body>
    <header>
        <h1>Finite Element Method Introduction</h1>
        <p class="subtitle">Understanding FEM Through 1D Bar Element Analysis</p>
    </header>

    <div class="content-section">
        <h2>Understanding the Finite Element Method</h2>

        <h3>What is the Finite Element Method?</h3>
        <p>The Finite Element Method (FEM) is a numerical technique for finding approximate solutions to boundary value problems for partial differential equations. It subdivides a large problem into smaller, simpler parts called finite elements, which are connected at points called nodes.</p>

        <div class="key-point">
            <p><strong>Core Insight:</strong> FEM transforms complex continuous problems into discrete algebraic equations that can be solved computationally. The key is to approximate the solution using simple functions (shape functions) over small regions (elements), then assemble these into a global system.</p>
        </div>

        <h3>The 1D Bar Element</h3>
        <p>The simplest finite element is the 1D bar element, which models axial deformation under tension or compression. Consider a uniform bar of length \(L\), cross-sectional area \(A\), and elastic modulus \(E\).</p>

        <div class="equation-box">
            <p><strong>Governing Differential Equation:</strong></p>
            <p>\[\frac{d}{dx}\left(EA\frac{du}{dx}\right) + f(x) = 0\]</p>
            <p>where \(u(x)\) is the axial displacement and \(f(x)\) is the distributed body force per unit length.</p>
        </div>

        <h3>Shape Functions</h3>
        <p>For a linear bar element with two nodes (1 and 2), we approximate the displacement field using linear shape functions:</p>

        <div class="equation-box">
            <p>\[u(x) = N_1(x)u_1 + N_2(x)u_2\]</p>
            <p>where the shape functions are:</p>
            <p>\[N_1(x) = 1 - \frac{x}{L}, \quad N_2(x) = \frac{x}{L}\]</p>
            <p>Properties of shape functions:</p>
            <ul style="list-style: none;">
                <li>\(N_1(0) = 1, \quad N_1(L) = 0\)</li>
                <li>\(N_2(0) = 0, \quad N_2(L) = 1\)</li>
                <li>\(N_1(x) + N_2(x) = 1\) (partition of unity)</li>
            </ul>
        </div>

        <h3>Element Stiffness Matrix</h3>
        <p>Using the principle of minimum potential energy or Galerkin's method, we derive the element stiffness matrix:</p>

        <div class="equation-box">
            <p>\[[k^e] = \frac{EA}{L}\begin{bmatrix} 1 & -1 \\ -1 & 1 \end{bmatrix}\]</p>
            <p>The element equilibrium equation is:</p>
            <p>\[[k^e]\{u^e\} = \{f^e\}\]</p>
            <p>where \(\{u^e\} = \begin{bmatrix} u_1 \\ u_2 \end{bmatrix}\) and \(\{f^e\} = \begin{bmatrix} f_1 \\ f_2 \end{bmatrix}\)</p>
        </div>

        <h3>Assembly Process</h3>
        <p>For multiple elements, we assemble the global stiffness matrix by adding contributions from elements sharing common nodes. This is called the <strong>direct stiffness method</strong>.</p>

        <div class="key-point">
            <p><strong>Assembly Rule:</strong> The global stiffness matrix [K] is assembled by adding element stiffness matrices at positions corresponding to their global degrees of freedom. Elements sharing a node contribute to the same entry in [K], ensuring compatibility and equilibrium.</p>
        </div>

        <div class="equation-box">
            <p><strong>Global System:</strong></p>
            <p>\[[K]\{U\} = \{F\}\]</p>
            <p>After applying boundary conditions and solving, we obtain nodal displacements \(\{U\}\).</p>
            <p><strong>Post-Processing:</strong> Element strains and stresses are calculated from:</p>
            <p>\[\varepsilon = \frac{du}{dx} = \frac{u_2 - u_1}{L}\]</p>
            <p>\[\sigma = E\varepsilon = \frac{E(u_2 - u_1)}{L}\]</p>
        </div>

        <h3>Convergence and Accuracy</h3>
        <p>As we increase the number of elements (mesh refinement), the FEM solution converges to the exact solution. This is guaranteed if:</p>
        <ul>
            <li><strong>Compatibility:</strong> Shape functions ensure continuous displacement across elements</li>
            <li><strong>Completeness:</strong> Shape functions can represent rigid body motion and constant strain</li>
            <li><strong>Convergence:</strong> Solution improves as element size decreases (h-refinement)</li>
        </ul>
    </div>

    <div class="simulation-container">
        <h2>Stepped Shaft Analysis: Exact vs FEM Solution</h2>
        <p>This simulation compares the exact analytical solution with the FEM solution for a stepped shaft under axial loading. The shaft has two sections with different diameters.</p>

        <div class="controls-grid">
            <div class="slider-container">
                <label for="num-elements">Number of Elements: <span id="num-elements-value" class="value-display">8</span></label>
                <input type="range" id="num-elements" min="2" max="40" step="2" value="8" class="slider">
            </div>

            <div class="slider-container">
                <label for="diameter1">Diameter d₁ (mm): <span id="diameter1-value" class="value-display">30</span></label>
                <input type="range" id="diameter1" min="20" max="60" step="5" value="30" class="slider">
            </div>

            <div class="slider-container">
                <label for="diameter2">Diameter d₂ (mm): <span id="diameter2-value" class="value-display">15</span></label>
                <input type="range" id="diameter2" min="10" max="50" step="5" value="15" class="slider">
            </div>

            <div class="slider-container">
                <label for="step-position">Step Position (%): <span id="step-position-value" class="value-display">50</span></label>
                <input type="range" id="step-position" min="20" max="80" step="5" value="50" class="slider">
            </div>
        </div>

        <div id="sketch-holder"></div>

        <div class="results-panel">
            <strong>Solution Comparison:</strong>
            <div id="solution-info">Adjust parameters to see displacement and stress distributions...</div>
        </div>
    </div>

    <script>
        // p5.js stepped shaft simulation
        let sketch = new p5(function(p) {
            // Simulation parameters
            let numElements = 8;
            let E = 200; // GPa
            let d1 = 30; // mm - larger diameter
            let d2 = 15; // mm - smaller diameter
            let stepPos = 0.5; // Position of step as fraction of total length (0-1)
            let P = 10; // kN
            const L = 1.0; // m - total length

            // Solution arrays - FEM
            let femDisplacements = [];
            let femStresses = [];
            let femPositions = [];

            // Solution arrays - Exact
            let exactDisplacements = [];
            let exactStresses = [];
            let exactPositions = [];

            p.setup = function() {
                let canvas = p.createCanvas(900, 900);
                canvas.parent('sketch-holder');
                setupSliders();
                solveProblem();
            };

            p.draw = function() {
                p.background(255);

                // Draw stepped shaft geometry
                drawSteppedShaft();

                // Draw displacement plot
                drawComparisonPlot(50, 300, 800, 150, "Displacement (mm)",
                    exactPositions, exactDisplacements.map(d => d * 1000),
                    femPositions, femDisplacements.map(d => d * 1000));

                // Draw stress plot
                drawComparisonPlot(50, 520, 800, 150, "Stress (MPa)",
                    exactPositions, exactStresses,
                    femPositions, femStresses);
            };

            function setupSliders() {
                document.getElementById('num-elements').addEventListener('input', function() {
                    numElements = parseInt(this.value);
                    document.getElementById('num-elements-value').textContent = numElements;
                    solveProblem();
                });

                document.getElementById('diameter1').addEventListener('input', function() {
                    d1 = parseFloat(this.value);
                    document.getElementById('diameter1-value').textContent = d1;
                    solveProblem();
                });

                document.getElementById('diameter2').addEventListener('input', function() {
                    d2 = parseFloat(this.value);
                    document.getElementById('diameter2-value').textContent = d2;
                    solveProblem();
                });

                document.getElementById('step-position').addEventListener('input', function() {
                    stepPos = parseFloat(this.value) / 100;
                    document.getElementById('step-position-value').textContent = this.value;
                    solveProblem();
                });
            }

            function solveProblem() {
                solveExact();
                solveFEM();
                updateSolutionInfo();
            }

            function solveExact() {
                // Calculate areas (convert mm to m)
                let A1 = Math.PI * (d1 * 1e-3) * (d1 * 1e-3) / 4; // m^2
                let A2 = Math.PI * (d2 * 1e-3) * (d2 * 1e-3) / 4; // m^2

                let L1 = L * stepPos; // Position of step
                let L2 = L - L1;

                let E_Pa = E * 1e9; // Convert GPa to Pa
                let P_N = P * 1000; // Convert kN to N

                // Generate exact solution points
                exactPositions = [];
                exactDisplacements = [];
                exactStresses = [];

                let numPoints = 100;
                for (let i = 0; i <= numPoints; i++) {
                    let x = (i / numPoints) * L;
                    exactPositions.push(x);

                    let u, sigma;
                    if (x <= L1) {
                        // Section 1
                        u = (P_N * x) / (E_Pa * A1);
                        sigma = P_N / A1;
                    } else {
                        // Section 2
                        u = (P_N * L1) / (E_Pa * A1) + (P_N * (x - L1)) / (E_Pa * A2);
                        sigma = P_N / A2;
                    }

                    exactDisplacements.push(u);
                    exactStresses.push(sigma / 1e6); // Convert to MPa
                }
            }

            function solveFEM() {
                // Element length
                let Le = L / numElements;

                // Calculate areas
                let A1 = Math.PI * (d1 * 1e-3) * (d1 * 1e-3) / 4; // m^2
                let A2 = Math.PI * (d2 * 1e-3) * (d2 * 1e-3) / 4; // m^2

                let L1 = L * stepPos;
                let E_Pa = E * 1e9;
                let P_N = P * 1000;

                // Assemble global stiffness matrix
                let n = numElements + 1; // Number of nodes
                let K = Array(n).fill(0).map(() => Array(n).fill(0));

                for (let i = 0; i < numElements; i++) {
                    // Determine which area this element has
                    let elemCenter = (i + 0.5) * Le;
                    let A_elem = elemCenter <= L1 ? A1 : A2;

                    // Element stiffness
                    let ke = (E_Pa * A_elem) / Le;

                    // Add to global matrix
                    K[i][i] += ke;
                    K[i][i+1] -= ke;
                    K[i+1][i] -= ke;
                    K[i+1][i+1] += ke;
                }

                // Apply boundary condition (u[0] = 0)
                // Replace first row with constraint equation
                K[0] = Array(n).fill(0);
                K[0][0] = 1;

                // Force vector
                let F = Array(n).fill(0);
                F[0] = 0; // Boundary condition
                F[n-1] = P_N;

                // Solve for displacements using Gaussian elimination
                femDisplacements = gaussianElimination(K, F);

                // Calculate stresses at element centers
                femPositions = [];
                femStresses = [];

                for (let i = 0; i < numElements; i++) {
                    let xCenter = (i + 0.5) * Le;
                    femPositions.push(xCenter);

                    // Determine area for this element
                    let A_elem = xCenter <= L1 ? A1 : A2;

                    // Calculate strain and stress
                    let strain = (femDisplacements[i+1] - femDisplacements[i]) / Le;
                    let stress = E_Pa * strain;

                    femStresses.push(stress / 1e6); // Convert to MPa
                }
            }

            function gaussianElimination(A, b) {
                let n = b.length;
                let Aug = A.map((row, i) => [...row, b[i]]); // Augmented matrix

                // Forward elimination
                for (let i = 0; i < n; i++) {
                    // Find pivot
                    let maxRow = i;
                    for (let k = i + 1; k < n; k++) {
                        if (Math.abs(Aug[k][i]) > Math.abs(Aug[maxRow][i])) {
                            maxRow = k;
                        }
                    }
                    [Aug[i], Aug[maxRow]] = [Aug[maxRow], Aug[i]];

                    // Make all rows below this one 0 in current column
                    for (let k = i + 1; k < n; k++) {
                        if (Math.abs(Aug[i][i]) > 1e-10) {
                            let factor = Aug[k][i] / Aug[i][i];
                            for (let j = i; j <= n; j++) {
                                Aug[k][j] -= factor * Aug[i][j];
                            }
                        }
                    }
                }

                // Back substitution
                let x = Array(n).fill(0);
                for (let i = n - 1; i >= 0; i--) {
                    x[i] = Aug[i][n];
                    for (let j = i + 1; j < n; j++) {
                        x[i] -= Aug[i][j] * x[j];
                    }
                    if (Math.abs(Aug[i][i]) > 1e-10) {
                        x[i] /= Aug[i][i];
                    }
                }

                return x;
            }

            function updateSolutionInfo() {
                // Get max displacements
                let maxDispExact = Math.max(...exactDisplacements) * 1000; // mm
                let maxDispFEM = Math.max(...femDisplacements) * 1000; // mm

                // Calculate error
                let error = Math.abs((maxDispFEM - maxDispExact) / maxDispExact * 100);

                let info = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div><strong>Max Displacement (Exact):</strong> ${maxDispExact.toFixed(4)} mm</div>
                        <div><strong>Max Displacement (FEM):</strong> ${maxDispFEM.toFixed(4)} mm</div>
                        <div><strong>Percentage Error:</strong> ${error.toFixed(3)}%</div>
                        <div><strong>Number of Elements:</strong> ${numElements}</div>
                    </div>
                `;
                document.getElementById('solution-info').innerHTML = info;
            }

            function drawSteppedShaft() {
                p.push();
                p.translate(50, 120);

                // Title
                p.fill(0);
                p.textAlign(p.CENTER);
                p.textSize(16);
                p.text("Stepped Shaft Geometry", 400, -30);

                let barWidth = 800;
                let L1_px = barWidth * stepPos;

                // Calculate visual heights based on diameters
                let maxD = Math.max(d1, d2);
                let h1 = 60 * (d1 / maxD);
                let h2 = 60 * (d2 / maxD);

                let centerY = 40;

                // Fixed support
                p.fill(100);
                p.rect(-20, centerY - 30, 20, 60);

                // Hatching for fixed support
                p.stroke(80);
                p.strokeWeight(1);
                for (let i = -20; i < 0; i += 3) {
                    p.line(i, centerY - 30, i + 10, centerY + 30);
                }

                // Section 1 (larger diameter)
                p.stroke(0);
                p.strokeWeight(2);
                p.fill(200, 220, 255);
                p.rect(0, centerY - h1/2, L1_px, h1);

                // Section 2 (smaller diameter)
                p.fill(255, 220, 200);
                p.rect(L1_px, centerY - h2/2, barWidth - L1_px, h2);

                // Step indicator
                p.stroke(0);
                p.strokeWeight(1);
                p.line(L1_px, centerY - 35, L1_px, centerY + 35);
                p.fill(0);
                p.noStroke();
                p.textSize(10);
                p.textAlign(p.CENTER);
                p.text("Step", L1_px, centerY + 45);

                // Diameter labels
                p.textSize(12);
                p.text(`d₁=${d1}mm`, L1_px/2, centerY);
                p.text(`d₂=${d2}mm`, L1_px + (barWidth - L1_px)/2, centerY);

                // Applied load
                p.stroke(255, 0, 0);
                p.strokeWeight(3);
                p.fill(255, 0, 0);
                p.line(barWidth, centerY, barWidth + 50, centerY);
                p.triangle(barWidth + 50, centerY, barWidth + 40, centerY - 5, barWidth + 40, centerY + 5);

                p.noStroke();
                p.textAlign(p.LEFT);
                p.text(`P = ${P} kN`, barWidth + 55, centerY + 5);

                // Length dimension
                p.stroke(0);
                p.strokeWeight(1);
                p.line(0, -15, barWidth, -15);
                p.line(0, -20, 0, -10);
                p.line(barWidth, -20, barWidth, -10);
                p.fill(0);
                p.noStroke();
                p.textAlign(p.CENTER);
                p.text(`L = ${L} m`, barWidth / 2, -20);

                // Element mesh overlay
                let elementWidth = barWidth / numElements;
                p.stroke(100, 100, 100, 100);
                p.strokeWeight(1);
                for (let i = 1; i < numElements; i++) {
                    let x = i * elementWidth;
                    p.line(x, centerY - 35, x, centerY + 35);
                }

                // Node markers
                p.noStroke();
                p.fill(0, 0, 255);
                for (let i = 0; i <= numElements; i++) {
                    let x = i * elementWidth;
                    p.circle(x, centerY, 5);
                }

                p.pop();
            }

            function drawComparisonPlot(x, y, w, h, title, exactX, exactY, femX, femY) {
                p.push();
                p.translate(x, y);

                // Title
                p.fill(0);
                p.textAlign(p.CENTER);
                p.textSize(14);
                p.text(title, w / 2, -10);

                // Background
                p.fill(250);
                p.noStroke();
                p.rect(0, 0, w, h);

                // Find data range
                let allY = [...exactY, ...femY];
                let yMin = Math.min(...allY);
                let yMax = Math.max(...allY);
                let yRange = yMax - yMin;
                if (yRange < 1e-10) yRange = 1;
                yMin -= yRange * 0.1;
                yMax += yRange * 0.1;

                // Grid
                p.stroke(220);
                p.strokeWeight(1);
                for (let i = 0; i <= 10; i++) {
                    let xPos = p.map(i / 10, 0, 1, 0, w);
                    p.line(xPos, 0, xPos, h);
                }
                for (let i = 0; i <= 5; i++) {
                    let yPos = p.map(i / 5, 0, 1, h, 0);
                    p.line(0, yPos, w, yPos);
                }

                // Axes
                p.stroke(0);
                p.strokeWeight(2);
                p.line(0, h, w, h);
                p.line(0, 0, 0, h);

                // Y-axis labels
                p.fill(0);
                p.noStroke();
                p.textSize(10);
                p.textAlign(p.RIGHT);
                for (let i = 0; i <= 5; i++) {
                    let yPos = p.map(i / 5, 0, 1, h, 0);
                    let yVal = p.map(i / 5, 0, 1, yMin, yMax);
                    p.text(yVal.toFixed(3), -5, yPos + 3);
                }

                // X-axis labels
                p.textAlign(p.CENTER);
                for (let i = 0; i <= 5; i++) {
                    let xPos = p.map(i / 5 * L, 0, L, 0, w);
                    p.text((i / 5 * L).toFixed(2) + " m", xPos, h + 15);
                }

                // Plot exact solution (green line)
                p.stroke(0, 150, 0);
                p.strokeWeight(2);
                p.noFill();
                p.beginShape();
                for (let i = 0; i < exactX.length; i++) {
                    let px = p.map(exactX[i], 0, L, 0, w);
                    let py = p.map(exactY[i], yMin, yMax, h, 0);
                    p.vertex(px, py);
                }
                p.endShape();

                // Plot FEM solution (blue/orange dots and line)
                let femColor = title.includes("Stress") ? [255, 140, 0] : [0, 0, 255];
                p.stroke(...femColor);
                p.strokeWeight(2);
                p.noFill();
                p.beginShape();
                for (let i = 0; i < femX.length; i++) {
                    let px = p.map(femX[i], 0, L, 0, w);
                    let py = p.map(femY[i], yMin, yMax, h, 0);
                    p.vertex(px, py);
                }
                p.endShape();

                // FEM data points
                p.fill(...femColor);
                p.noStroke();
                for (let i = 0; i < femX.length; i++) {
                    let px = p.map(femX[i], 0, L, 0, w);
                    let py = p.map(femY[i], yMin, yMax, h, 0);
                    p.circle(px, py, 7);
                }

                // Legend
                p.textAlign(p.LEFT);
                p.textSize(11);
                p.fill(0, 150, 0);
                p.text("— Exact", w - 120, 20);
                p.fill(...femColor);
                p.text("● FEM", w - 120, 35);

                p.pop();
            }
        }, 'sketch-holder');
    </script>

    <div class="content-section">
        <h2>Engineering Applications</h2>
        <p>The Finite Element Method is one of the most widely used numerical techniques in engineering:</p>
        <ul>
            <li><strong>Structural Analysis:</strong> Buildings, bridges, and aircraft structures are analyzed using FEM to predict stresses, deformations, and failure modes under various loading conditions.</li>
            <li><strong>Heat Transfer:</strong> Thermal analysis of electronic devices, heat exchangers, and manufacturing processes relies on FEM to optimize cooling and prevent overheating.</li>
            <li><strong>Fluid Dynamics:</strong> Computational Fluid Dynamics (CFD) uses FEM to simulate airflow over aircraft, water flow in pipes, and blood flow in vessels.</li>
            <li><strong>Biomechanics:</strong> Bone, tissue, and prosthetic implants are designed using FEM to ensure proper load distribution and prevent failure.</li>
            <li><strong>Geotechnical Engineering:</strong> Soil-structure interaction, foundation design, and slope stability analysis use FEM for accurate predictions.</li>
            <li><strong>Manufacturing:</strong> Metal forming, welding simulations, and additive manufacturing processes are optimized using FEM to reduce defects and improve quality.</li>
        </ul>
    </div>

    <div class="content-section">
        <h2>Summary of Key Equations</h2>
        <div class="equation-table">
            <table>
                <thead>
                    <tr>
                        <th>Concept</th>
                        <th>Equation</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                <tr>
                    <td>Governing Equation (1D Bar)</td>
                    <td>\(\frac{d}{dx}\left(EA\frac{du}{dx}\right) + f(x) = 0\)</td>
                    <td>Equilibrium equation for axial bar</td>
                </tr>
                <tr>
                    <td>Shape Functions (Linear)</td>
                    <td>\(N_1 = 1 - \frac{x}{L}, \quad N_2 = \frac{x}{L}\)</td>
                    <td>Linear interpolation functions</td>
                </tr>
                <tr>
                    <td>Displacement Approximation</td>
                    <td>\(u(x) = N_1(x)u_1 + N_2(x)u_2\)</td>
                    <td>FEM approximation of displacement</td>
                </tr>
                <tr>
                    <td>Element Stiffness Matrix</td>
                    <td>\([k^e] = \frac{EA}{L}\begin{bmatrix} 1 & -1 \\ -1 & 1 \end{bmatrix}\)</td>
                    <td>Bar element stiffness</td>
                </tr>
                <tr>
                    <td>Global System</td>
                    <td>\([K]\{U\} = \{F\}\)</td>
                    <td>Assembled system of equations</td>
                </tr>
                <tr>
                    <td>Element Strain</td>
                    <td>\(\varepsilon = \frac{u_2 - u_1}{L}\)</td>
                    <td>Constant strain in element</td>
                </tr>
                <tr>
                    <td>Element Stress</td>
                    <td>\(\sigma = E\varepsilon = \frac{E(u_2 - u_1)}{L}\)</td>
                    <td>Constant stress in element</td>
                </tr>
                </tbody>
            </table>
        </div>
    </div>

    <div class="content-section">
        <h2>Practice Problems</h2>

        <div class="practice-problems">
            <h3>Problem 1: Two-Element Bar Analysis</h3>
            <p>A bar of total length 2 m is divided into two elements. Element 1 has \(E_1 = 200\) GPa, \(A_1 = 100\) mm², and length 1 m. Element 2 has \(E_2 = 100\) GPa, \(A_2 = 50\) mm², and length 1 m. A force of 10 kN is applied at the free end. Calculate the nodal displacements and element stresses.</p>

            <p class="toggle-section" onclick="toggleSolution('solution1')">Show Solution</p>
            <div id="solution1" class="hidden">
                <p><strong>Step 1: Element stiffness matrices</strong></p>
                <p>\([k^1] = \frac{E_1 A_1}{L_1} = \frac{200 \times 10^9 \times 100 \times 10^{-6}}{1} = 20 \times 10^6\) N/m</p>
                <p>\([k^2] = \frac{E_2 A_2}{L_2} = \frac{100 \times 10^9 \times 50 \times 10^{-6}}{1} = 5 \times 10^6\) N/m</p>

                <p><strong>Step 2: Assemble global stiffness matrix</strong></p>
                <p>\([K] = 10^6 \begin{bmatrix} 20 & -20 & 0 \\ -20 & 25 & -5 \\ 0 & -5 & 5 \end{bmatrix}\) N/m</p>

                <p><strong>Step 3: Apply boundary conditions</strong></p>
                <p>\(u_1 = 0\) (fixed), \(F_3 = 10000\) N</p>

                <p><strong>Step 4: Solve reduced system</strong></p>
                <p>\(10^6 \begin{bmatrix} 25 & -5 \\ -5 & 5 \end{bmatrix} \begin{bmatrix} u_2 \\ u_3 \end{bmatrix} = \begin{bmatrix} 0 \\ 10000 \end{bmatrix}\)</p>

                <p><strong>Solution:</strong></p>
                <p>\(u_2 = 0.5\) mm, \(u_3 = 2.5\) mm</p>
                <p>\(\sigma_1 = \frac{E_1(u_2 - u_1)}{L_1} = \frac{200 \times 10^9 \times 0.5 \times 10^{-3}}{1} = 100\) MPa</p>
                <p>\(\sigma_2 = \frac{E_2(u_3 - u_2)}{L_2} = \frac{100 \times 10^9 \times 2.0 \times 10^{-3}}{1} = 200\) MPa</p>
            </div>
        </div>

        <div class="practice-problems">
            <h3>Problem 2: Convergence Study</h3>
            <p>For a uniform bar with \(E = 200\) GPa, \(A = 100\) mm², \(L = 1\) m, and \(P = 50\) kN, the exact tip displacement is \(u_{exact} = PL/(EA) = 2.5\) mm. Calculate the FEM solution using 1, 2, and 4 elements and discuss convergence.</p>

            <p class="toggle-section" onclick="toggleSolution('solution2')">Show Solution</p>
            <div id="solution2" class="hidden">
                <p><strong>1 Element:</strong></p>
                <p>\(k = \frac{EA}{L} = \frac{200 \times 10^9 \times 100 \times 10^{-6}}{1} = 20 \times 10^6\) N/m</p>
                <p>\(u_{tip} = \frac{P}{k} = \frac{50000}{20 \times 10^6} = 2.5\) mm</p>
                <p>Error = 0% (exact for uniform bar!)</p>

                <p><strong>2 Elements:</strong></p>
                <p>\(k_e = \frac{EA}{L/2} = 40 \times 10^6\) N/m</p>
                <p>\(u_{tip} = 2.5\) mm</p>
                <p>Error = 0%</p>

                <p><strong>4 Elements:</strong></p>
                <p>\(u_{tip} = 2.5\) mm</p>
                <p>Error = 0%</p>

                <p><strong>Conclusion:</strong> For the uniform bar under constant axial load, the linear element gives the exact solution regardless of the number of elements because the exact solution is linear. For non-uniform bars or varying loads, more elements improve accuracy.</p>
            </div>
        </div>

        <div class="practice-problems">
            <h3>Problem 3: Shape Function Properties</h3>
            <p>Verify that the linear shape functions \(N_1(x) = 1 - x/L\) and \(N_2(x) = x/L\) satisfy the essential properties: (a) Kronecker delta property, (b) partition of unity, and (c) can represent constant strain.</p>

            <p class="toggle-section" onclick="toggleSolution('solution3')">Show Solution</p>
            <div id="solution3" class="hidden">
                <p><strong>(a) Kronecker Delta Property:</strong></p>
                <p>At node 1 (\(x = 0\)): \(N_1(0) = 1\), \(N_2(0) = 0\)</p>
                <p>At node 2 (\(x = L\)): \(N_1(L) = 0\), \(N_2(L) = 1\)</p>
                <p>✓ Each shape function equals 1 at its own node and 0 at other nodes.</p>

                <p><strong>(b) Partition of Unity:</strong></p>
                <p>\(N_1(x) + N_2(x) = \left(1 - \frac{x}{L}\right) + \frac{x}{L} = 1\) for all \(x\)</p>
                <p>✓ Shape functions sum to unity everywhere, ensuring rigid body motion can be represented.</p>

                <p><strong>(c) Constant Strain Representation:</strong></p>
                <p>If \(u_1 = 0\) and \(u_2 = \varepsilon_0 L\) (constant strain \(\varepsilon_0\)):</p>
                <p>\(u(x) = N_1(x) \cdot 0 + N_2(x) \cdot \varepsilon_0 L = \frac{x}{L} \cdot \varepsilon_0 L = \varepsilon_0 x\)</p>
                <p>\(\varepsilon = \frac{du}{dx} = \varepsilon_0\) (constant)</p>
                <p>✓ Linear shape functions can exactly represent constant strain states.</p>
            </div>
        </div>
    </div>

    <div class="content-section">
        <h2>Knowledge Check Quiz</h2>
        <div class="quiz-container">
            <div class="quiz-question">
                <h3>Question 1: What is the primary advantage of the Finite Element Method?</h3>
                <div class="quiz-options">
                    <label><input type="radio" name="q1" value="a"> a) It gives exact analytical solutions</label>
                    <label><input type="radio" name="q1" value="b"> b) It can handle complex geometries and boundary conditions</label>
                    <label><input type="radio" name="q1" value="c"> c) It requires no computational resources</label>
                    <label><input type="radio" name="q1" value="d"> d) It eliminates the need for material properties</label>
                </div>
            </div>

            <div class="quiz-question">
                <h3>Question 2: For a 1D bar element, the stiffness matrix is:</h3>
                <div class="quiz-options">
                    <label><input type="radio" name="q2" value="a"> a) Diagonal</label>
                    <label><input type="radio" name="q2" value="b"> b) Symmetric</label>
                    <label><input type="radio" name="q2" value="c"> c) Asymmetric</label>
                    <label><input type="radio" name="q2" value="d"> d) Identity matrix</label>
                </div>
            </div>

            <div class="quiz-question">
                <h3>Question 3: Shape functions must satisfy which property?</h3>
                <div class="quiz-options">
                    <label><input type="radio" name="q3" value="a"> a) They must be nonlinear</label>
                    <label><input type="radio" name="q3" value="b"> b) They must sum to zero</label>
                    <label><input type="radio" name="q3" value="c"> c) They must satisfy partition of unity (sum to one)</label>
                    <label><input type="radio" name="q3" value="d"> d) They must be discontinuous</label>
                </div>
            </div>

            <div class="quiz-question">
                <h3>Question 4: In the assembly process, what happens at shared nodes?</h3>
                <div class="quiz-options">
                    <label><input type="radio" name="q4" value="a"> a) Element stiffnesses are averaged</label>
                    <label><input type="radio" name="q4" value="b"> b) Element stiffnesses are added (superposed)</label>
                    <label><input type="radio" name="q4" value="c"> c) Only the largest stiffness is kept</label>
                    <label><input type="radio" name="q4" value="d"> d) Nodes are duplicated</label>
                </div>
            </div>

            <div class="quiz-question">
                <h3>Question 5: As the number of elements increases, the FEM solution:</h3>
                <div class="quiz-options">
                    <label><input type="radio" name="q5" value="a"> a) Becomes less accurate</label>
                    <label><input type="radio" name="q5" value="b"> b) Remains constant</label>
                    <label><input type="radio" name="q5" value="c"> c) Converges to the exact solution</label>
                    <label><input type="radio" name="q5" value="d"> d) Oscillates randomly</label>
                </div>
            </div>

            <button id="submit-quiz">Submit Quiz</button>
            <div id="quiz-results"></div>
        </div>
    </div>

    <!-- Common JavaScript functions -->
    <script src="/assets/common/problems.js"></script>
    <script src="/assets/common/quizzes.js"></script>

    <script>
        // Quiz functionality
        document.addEventListener('DOMContentLoaded', function() {
            const quizBtn = document.getElementById('submit-quiz');
            if (quizBtn) {
                quizBtn.addEventListener('click', function() {
                    const answers = {
                        q1: 'b', // Complex geometries
                        q2: 'b', // Symmetric
                        q3: 'c', // Partition of unity
                        q4: 'b', // Stiffnesses are added
                        q5: 'c'  // Converges to exact solution
                    };

                    let score = 0;
                    let totalQuestions = Object.keys(answers).length;
                    let resultsHTML = '<h3>Quiz Results:</h3>';

                    for (let question in answers) {
                        const selectedOption = document.querySelector(`input[name="${question}"]:checked`);
                        const correctAnswer = answers[question];

                        if (selectedOption) {
                            if (selectedOption.value === correctAnswer) {
                                score++;
                                resultsHTML += `<p style="color: #28a745; font-weight: bold;">${question.toUpperCase()}: Correct! ✓</p>`;
                            } else {
                                resultsHTML += `<p style="color: #dc3545; font-weight: bold;">${question.toUpperCase()}: Incorrect ✗</p>`;
                            }
                        } else {
                            resultsHTML += `<p style="color: #333;">${question.toUpperCase()}: Not answered</p>`;
                        }
                    }

                    const percentage = ((score / totalQuestions) * 100).toFixed(0);
                    resultsHTML = `<p style="font-size: 1.2em; font-weight: bold;">You scored ${score} out of ${totalQuestions} (${percentage}%)</p>` + resultsHTML;

                    document.getElementById('quiz-results').innerHTML = resultsHTML;
                });
            }
        });
    </script>

    <footer>
        <script src="/assets/common/footer.js"></script>
    </footer>
</body>
</html>
