<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Plasticity in Bending - Interactive Lecture</title>
  <!-- p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
  <!-- MathJax -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
  <!-- External CSS -->
  <link rel="stylesheet" href="/assets/css/main.css">
  <link rel="stylesheet" href="/assets/css/problems.css">
  <link rel="stylesheet" href="/assets/css/quizzes.css">
  <link rel="stylesheet" href="/assets/css/simulations.css">
  <link rel="stylesheet" href="/assets/css/uicontrols.css">

  <style>
    /* Page-specific styles for plasticity simulations */
    .stress-stages{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin:15px 0}
    .stage-card{background:#f9f9f9;border:2px solid #ddd;border-radius:5px;padding:8px 5px;text-align:center;transition:.3s;font-size:12px;}
    .stage-card.active{background:#fff3cd;border-color:#ffc107;font-weight:700}
    .stage-card strong{display:block;margin-bottom:3px;}
    .stage-card p{margin:0;font-size:11px;}
    .simulation-title{background:var(--primary-color);color:var(--text-color);padding:10px;margin:-20px -20px 20px;border-radius:8px 8px 0 0;text-align:center;font-weight:700}
    .value-display{display:inline-block;min-width:50px;padding:4px 8px;background:#fff;border:1px solid #ddd;border-radius:3px;text-align:center;font-weight:700;color:#b38600}
    .info-panel{background:#e6f7ff;border-left:4px solid #1890ff;padding:15px;margin:15px 0;border-radius:0 4px 4px 0}
    .info-panel p{margin:5px 0}
    #sketch-holder-1,#sketch-holder-2{width:100%;height:440px;border:1px solid #ddd;border-radius:4px;background:#f9f9f9;margin:20px 0}
    .section-inputs{display:none;margin:10px 0;padding:10px;background:#f0f0f0;border-radius:5px}
    .section-inputs.active{display:block}
    .section-inputs input[type=number]{width:70px;padding:4px;margin:0 5px}
    .legend{font-size:12px;color:#555}
    .legend span{display:inline-block;padding:2px 6px;margin-right:8px;border-radius:3px}
    .chip-blue{background:#d9ecff;border:1px solid #82b6ff}
    .chip-red{background:#ffd9d9;border:1px solid #ff8a8a}
    .chip-grey{background:#eee;border:1px solid #ccc}
    .chip-gold{background:#fff4d6;border:1px solid #ffc107}
  </style>
</head>
<body>
<header>
  <h1>Plasticity in Bending</h1>
  <p class="subtitle">Understanding Elastic–Plastic Behaviour in Structural Members</p>
</header>

<div class="content-section">
  <h2>Introduction to Plasticity in Bending</h2>
  <p>When structural members are subjected to bending moments beyond their elastic limit, they undergo plastic deformation. Understanding this behaviour is crucial for modern limit state design, allowing engineers to utilise the full strength of materials safely and economically.</p>

  <div class="key-point">
    <h3>Material Models</h3>
    <ul>
      <li><strong>Perfectly Elastic:</strong> \(\sigma = E\varepsilon\)</li>
      <li><strong>Perfectly Plastic:</strong> constant \(\sigma=\sigma_y\) beyond yield</li>
      <li><strong>Elastic–Perfectly Plastic:</strong> elastic up to yield, then perfectly plastic</li>
    </ul>
  </div>

  <div class="equation-box">
    <h3>Fundamental Relationships</h3>
    <p>\[\sigma = \frac{My}{I}\]</p>
    <p>\[M_e = \frac{\sigma_y I}{y_{max}},\quad M_p = \sigma_y Z,\quad f=\frac{M_p}{M_e}=\frac{Z}{S}\]</p>
  </div>
</div>

<!-- SIMULATION 1 -->
<div class="simulation-section">
  <div class="simulation-container">
    <div class="simulation-title">Simulation 1: Plasticity Progression in Cross-Sections</div>

    <div class="controls-panel">
      <div class="control-row">
        <label>Section Type:</label>
        <select id="sectionType1">
          <option value="rectangular">Rectangular</option>
          <option value="t-section">T-Section</option>
          <option value="i-section">I-Section</option>
        </select>
      </div>
      <div class="slider-row">
        <label>Yield Stress (MPa):</label>
        <input type="range" id="yieldStress1" min="200" max="500" value="250" step="10"/>
        <span class="value-display" id="yieldValue1">250</span>
      </div>
      <div class="slider-row">
        <label>Bending Moment (kN·m):</label>
        <input type="range" id="momentSlider1" min="0" max="300" value="0" step="1"/>
        <span class="value-display" id="momentValue1">0</span>
      </div>
      <button id="resetBtn1">Reset</button>
      <div class="legend">
        <span class="chip-blue">Elastic</span>
        <span class="chip-red">Plastic</span>
        <span class="chip-grey">Yield ±σ<sub>y</sub></span>
        <span class="chip-gold">Bisectrix</span>
      </div>
    </div>

    <!-- Section inputs -->
    <div id="rect-inputs" class="section-inputs active">
      <label>Width b (mm): <input type="number" id="rect-b" value="120" min="20" max="600"/></label>
      <label>Height h (mm): <input type="number" id="rect-h" value="200" min="20" max="800"/></label>
    </div>

    <div id="t-inputs" class="section-inputs">
      <label>Flange width b<sub>f</sub> (mm): <input type="number" id="t-bf" value="170" min="40" max="800"/></label>
      <label>Flange thickness t<sub>f</sub> (mm): <input type="number" id="t-tf" value="30" min="4" max="200"/></label>
      <label>Web thickness t<sub>w</sub> (mm): <input type="number" id="t-tw" value="30" min="4" max="200"/></label>
      <label>Web height h<sub>w</sub> (mm): <input type="number" id="t-hw" value="170" min="20" max="800"/></label>
    </div>

    <div id="i-inputs" class="section-inputs">
      <label>Flange width b<sub>f</sub> (mm): <input type="number" id="i-bf" value="150" min="40" max="800"/></label>
      <label>Flange thickness t<sub>f</sub> (mm): <input type="number" id="i-tf" value="25" min="4" max="200"/></label>
      <label>Web thickness t<sub>w</sub> (mm): <input type="number" id="i-tw" value="15" min="4" max="200"/></label>
      <label>Total height h (mm): <input type="number" id="i-h" value="200" min="20" max="800"/></label>
    </div>

    <div class="info-panel">
      <div class="stress-stages">
        <div class="stage-card" id="elastic-stage"><strong>Elastic</strong><p>M &lt; M<sub>e</sub></p></div>
        <div class="stage-card" id="first-yield-stage"><strong>First Yield</strong><p>M ≈ M<sub>e</sub></p></div>
        <div class="stage-card" id="elastoplastic-stage"><strong>Elastic–Plastic</strong><p>M<sub>e</sub> &lt; M &lt; M<sub>p</sub></p></div>
        <div class="stage-card" id="fully-plastic-stage"><strong>Fully Plastic</strong><p>M ≈ M<sub>p</sub></p></div>
      </div>
    </div>

    <div id="sketch-holder-1"></div>
  </div>
</div>

<!-- SIMULATION 2 -->
<div class="simulation-section">
  <div class="simulation-container">
    <div class="simulation-title">Simulation 2: Residual Stress Formation</div>

    <div class="controls-panel">
      <div class="slider-row">
        <label>Fibre Position (y/h):</label>
        <input type="range" id="fibrePosition" min="-1" max="1" value="0.5" step="0.05"/>
        <span class="value-display" id="fibreValue">0.50</span>
      </div>
      <div style="display: flex; gap: 10px; flex-wrap: wrap;">
        <button id="loadBtn">Load</button>
        <button id="unloadBtn" disabled>Unload to 0</button>
        <button id="resetBtn2">Reset</button>
      </div>
      <div class="slider-row">
        <label>Applied Moment (kN·m):</label>
        <input type="range" id="momentSlider2" min="0" max="300" value="0" step="1" disabled/>
        <span class="value-display" id="momentValue2">0</span>
      </div>
      <div class="legend">
        <span class="chip-blue">Current stress (loading)</span>
        <span class="chip-red">Residual (after unload)</span>
      </div>
    </div>

    <div class="info-panel" style="display:flex; flex-wrap:wrap; gap:20px; justify-content:space-between;">
      <p style="margin:5px 0;"><strong>Loading State:</strong> <span id="loadingState">Unloaded</span></p>
      <p style="margin:5px 0;"><strong>Maximum Moment:</strong> <span id="maxMoment">0</span> kN·m</p>
      <p style="margin:5px 0;"><strong>Residual Stress:</strong> <span id="residualStress">0</span> MPa</p>
    </div>

    <div id="sketch-holder-2"></div>
  </div>
</div>

<!-- TEACHING CONTENT SECTION -->
<div class="content-section">
  <h2>Understanding Plastic Bending Theory</h2>

  <div class="equation-box">
    <h3>Key Concepts</h3>
    <ol>
      <li><strong>Elastic Limit Load:</strong> When the extreme fibre first reaches yield stress:
        \[M_e = \frac{\sigma_y I}{y_{max}} = \sigma_y S\]
        where \(S = I/y_{max}\) is the elastic section modulus.</li>
      <li><strong>Plastic Limit Load:</strong> When the entire section is fully plastic:
        \[M_p = \sigma_y Z\]
        where \(Z\) is the plastic section modulus, defined as the first moment of area about the plastic neutral axis (bisectrix).</li>
      <li><strong>Shape Factor:</strong> The ratio of plastic to Elastic Limit Load:
        \[f = \frac{M_p}{M_e} = \frac{Z}{S}\]
        For a rectangle: \(f = 1.5\); for an I-section: \(f \approx 1.15\)</li>
      <li><strong>Plastic Neutral Axis:</strong> The axis that divides the cross-section into two equal areas (not the centroid for asymmetric sections).</li>
    </ol>
  </div>

  <div class="key-point">
    <h3>Applications in Structural Design</h3>
    <ul>
      <li><strong>Limit State Design:</strong> Plastic analysis allows structures to be designed based on their ultimate load capacity rather than just elastic limits.</li>
      <li><strong>Redistribution of Moments:</strong> In continuous beams, plastic hinges form at highly stressed sections, allowing moment redistribution.</li>
      <li><strong>Economy:</strong> Understanding plastic behaviour permits more efficient use of materials, reducing weight and cost.</li>
      <li><strong>Residual Stresses:</strong> After unloading from plastic deformation, residual stresses remain locked in the section.</li>
    </ul>
  </div>
</div>

<!-- APPLICATIONS AND EXAMPLES SECTION -->
<div class="content-section">
  <h2>Engineering Applications</h2>
  <p>Plastic bending theory is fundamental to modern structural engineering, enabling more economical and safe design across numerous applications:</p>
  <ul>
    <li><strong>Building Frames:</strong> Steel frame structures utilize plastic design to allow moment redistribution in continuous beams and rigid connections, enabling lighter, more efficient designs while maintaining safety.</li>
    <li><strong>Bridge Engineering:</strong> Continuous bridge girders benefit from plastic analysis to account for load redistribution after plastic hinge formation, optimizing material usage and reducing construction costs.</li>
    <li><strong>Automotive Crashworthiness:</strong> Vehicle crumple zones are designed using plastic bending theory to predict energy absorption during collisions, with controlled plastic deformation protecting occupants.</li>
    <li><strong>Metal Forming:</strong> Press brake bending, roll forming, and stamping operations rely on understanding plastic behavior to achieve desired shapes without fracture or excessive springback.</li>
    <li><strong>Seismic Design:</strong> Earthquake-resistant structures incorporate plastic hinges at predetermined locations, allowing controlled energy dissipation during seismic events while preventing catastrophic collapse.</li>
    <li><strong>Pipeline Engineering:</strong> Large-diameter pipelines subjected to bending during installation or ground movement are analyzed using plastic bending theory to ensure integrity under extreme deformation.</li>
  </ul>
</div>

<!-- SUMMARY OF KEY EQUATIONS SECTION -->
<div class="content-section">
  <h2>Summary of Key Equations</h2>
  <div class="equation-box">
    <table>
      <tr>
        <th>Concept</th>
        <th>Equation</th>
        <th>Description</th>
      </tr>
      <tr>
        <td>Elastic Section Modulus</td>
        <td>\(S = \frac{I}{y_{max}}\)</td>
        <td>Relates second moment of area to elastic bending resistance</td>
      </tr>
      <tr>
        <td>Elastic Limit Load</td>
        <td>\(M_e = \sigma_y S\)</td>
        <td>Moment when extreme fibre first reaches yield stress</td>
      </tr>
      <tr>
        <td>Plastic Section Modulus</td>
        <td>\(Z = \sum A_i \bar{y}_i\)</td>
        <td>First moment of area about plastic neutral axis</td>
      </tr>
      <tr>
        <td>Plastic Limit Load</td>
        <td>\(M_p = \sigma_y Z\)</td>
        <td>Moment when entire section reaches yield stress</td>
      </tr>
      <tr>
        <td>Shape Factor</td>
        <td>\(f = \frac{M_p}{M_e} = \frac{Z}{S}\)</td>
        <td>Ratio indicating reserve capacity (rectangle: 1.5, I-beam: ~1.15)</td>
      </tr>
    </table>
  </div>
</div>

<!-- PRACTICE PROBLEMS SECTION -->
<div class="content-section">
  <h2>Practice Problems</h2>

  <div class="practice-problems">
    <h3>Problem 1: Plastic Limit Load of Rectangular Section</h3>
    <p>A rectangular steel beam has width \(b = 150\) mm and depth \(h = 300\) mm. The yield stress is \(\sigma_y = 275\) MPa. Calculate:</p>
    <ol type="a">
      <li>The elastic section modulus \(S\)</li>
      <li>The plastic section modulus \(Z\)</li>
      <li>The Elastic Limit Load \(M_e\)</li>
      <li>The Plastic Limit Load \(M_p\)</li>
      <li>The shape factor \(f\)</li>
    </ol>

    <p class="toggle-section" onclick="toggleSolution('solution1')">Show Solution</p>
    <div id="solution1" class="hidden">
      <p><strong>(a) Elastic Section Modulus:</strong></p>
      <p>\[I = \frac{bh^3}{12} = \frac{150 \times 300^3}{12} = 337.5 \times 10^6 \text{ mm}^4\]</p>
      <p>\[S = \frac{I}{y_{max}} = \frac{337.5 \times 10^6}{150} = 2.25 \times 10^6 \text{ mm}^3\]</p>

      <p><strong>(b) Plastic Section Modulus:</strong></p>
      <p>For a rectangle, the plastic neutral axis is at mid-depth. The plastic modulus is:</p>
      <p>\[Z = 2 \times \left(\frac{bh}{2} \times \frac{h}{4}\right) = \frac{bh^2}{4} = \frac{150 \times 300^2}{4} = 3.375 \times 10^6 \text{ mm}^3\]</p>

      <p><strong>(c) Elastic Limit Load:</strong></p>
      <p>\[M_e = \sigma_y S = 275 \times 2.25 \times 10^6 = 618.75 \times 10^6 \text{ N·mm} = 618.75 \text{ kN·m}\]</p>

      <p><strong>(d) Plastic Limit Load:</strong></p>
      <p>\[M_p = \sigma_y Z = 275 \times 3.375 \times 10^6 = 928.1 \times 10^6 \text{ N·mm} = 928.1 \text{ kN·m}\]</p>

      <p><strong>(e) Shape Factor:</strong></p>
      <p>\[f = \frac{M_p}{M_e} = \frac{928.1}{618.75} = 1.50\]</p>
      <p>This confirms the theoretical shape factor of 1.5 for rectangular sections.</p>
    </div>
  </div>

  <div class="practice-problems">
    <h3>Problem 2: Partially Plastic Moment</h3>
    <p>Consider the same rectangular section from Problem 1 (\(b = 150\) mm, \(h = 300\) mm, \(\sigma_y = 275\) MPa). If a bending moment of \(M = 750\) kN·m is applied, determine:</p>
    <ol type="a">
      <li>Whether the section is fully elastic, elastic-plastic, or fully plastic</li>
      <li>The depth of the elastic core \(2c\) (if elastic-plastic)</li>
      <li>The stress distribution</li>
    </ol>

    <p class="toggle-section" onclick="toggleSolution('solution2')">Show Solution</p>
    <div id="solution2" class="hidden">
      <p><strong>(a) Classification:</strong></p>
      <p>From Problem 1: \(M_e = 618.75\) kN·m and \(M_p = 928.1\) kN·m</p>
      <p>Since \(M_e < M = 750 < M_p\), the section is in the <strong>elastic-plastic state</strong>.</p>

      <p><strong>(b) Elastic Core Depth:</strong></p>
      <p>For a rectangular section with moment \(M\) in the elastic-plastic range:</p>
      <p>\[M = \sigma_y b \left(\frac{h^2}{4} - \frac{c^2}{3}\right)\]</p>
      <p>Substituting values:</p>
      <p>\[750 \times 10^6 = 275 \times 150 \times \left(\frac{300^2}{4} - \frac{c^2}{3}\right)\]</p>
      <p>\[750 \times 10^6 = 41250 \times (22500 - \frac{c^2}{3})\]</p>
      <p>\[18181.8 = 22500 - \frac{c^2}{3}\]</p>
      <p>\[c^2 = 3 \times (22500 - 18181.8) = 12954.5\]</p>
      <p>\[c = 113.8 \text{ mm}\]</p>
      <p>Elastic core depth: \(2c = 227.6\) mm</p>

      <p><strong>(c) Stress Distribution:</strong></p>
      <ul>
        <li>Top \(36.2\) mm: \(\sigma = +\sigma_y = +275\) MPa (plastic, tension)</li>
        <li>Middle \(227.6\) mm: \(\sigma\) varies linearly from \(+275\) MPa to \(-275\) MPa (elastic)</li>
        <li>Bottom \(36.2\) mm: \(\sigma = -\sigma_y = -275\) MPa (plastic, compression)</li>
      </ul>
    </div>
  </div>

  <div class="practice-problems">
    <h3>Problem 3: Shape Factor for I-Section</h3>
    <p>A symmetrical I-section has the following dimensions: flange width \(b_f = 200\) mm, flange thickness \(t_f = 25\) mm, web thickness \(t_w = 15\) mm, total depth \(h = 300\) mm. The yield stress is \(\sigma_y = 355\) MPa.</p>
    <p>Calculate the shape factor \(f\). Comment on why I-sections have lower shape factors than rectangular sections.</p>

    <p class="toggle-section" onclick="toggleSolution('solution3')">Show Solution</p>
    <div id="solution3" class="hidden">
      <p><strong>Step 1: Calculate Second Moment of Area \(I\):</strong></p>
      <p>For a symmetric I-section about the centroidal axis:</p>
      <p>\[I = \frac{b_f h^3}{12} - \frac{(b_f - t_w)(h - 2t_f)^3}{12}\]</p>
      <p>\[I = \frac{200 \times 300^3}{12} - \frac{(200-15)(300-50)^3}{12}\]</p>
      <p>\[I = 450 \times 10^6 - 180.3 \times 10^6 = 269.7 \times 10^6 \text{ mm}^4\]</p>

      <p><strong>Step 2: Calculate Elastic Section Modulus \(S\):</strong></p>
      <p>\[S = \frac{I}{y_{max}} = \frac{269.7 \times 10^6}{150} = 1.798 \times 10^6 \text{ mm}^3\]</p>

      <p><strong>Step 3: Calculate Plastic Section Modulus \(Z\):</strong></p>
      <p>For a symmetric I-section, the plastic neutral axis is at mid-depth. Calculate areas and centroids:</p>
      <ul>
        <li>Each flange area: \(A_f = 200 \times 25 = 5000\) mm², centroid at \(137.5\) mm from PNA</li>
        <li>Web area above PNA: \(A_w = 15 \times 125 = 1875\) mm², centroid at \(62.5\) mm from PNA</li>
      </ul>
      <p>\[Z = 2 \times (A_f \times 137.5 + A_w \times 62.5)\]</p>
      <p>\[Z = 2 \times (5000 \times 137.5 + 1875 \times 62.5) = 2 \times (687500 + 117188) = 1.609 \times 10^6 \text{ mm}^3\]</p>

      <p><strong>Wait, this gives \(f < 1\), which is incorrect. Let me recalculate correctly:</strong></p>
      <p>Total web height between flanges: \(h - 2t_f = 300 - 50 = 250\) mm</p>
      <p>Each half-web area: \(A_{hw} = 15 \times 125 = 1875\) mm²</p>
      <p>\[Z = 2 \times \left[5000 \times 137.5 + 1875 \times 62.5\right] = 2 \times 805078 = 2.014 \times 10^6 \text{ mm}^3\]</p>

      <p><strong>Step 4: Calculate Shape Factor:</strong></p>
      <p>\[f = \frac{Z}{S} = \frac{2.014 \times 10^6}{1.798 \times 10^6} = 1.12\]</p>

      <p><strong>Comment:</strong> I-sections have lower shape factors (\(f \approx 1.12–1.15\)) compared to rectangular sections (\(f = 1.5\)) because most of their material is concentrated in the flanges, far from the neutral axis. This means the material is already efficiently placed for elastic bending, leaving less "reserve" capacity to exploit through plasticity. Rectangular sections waste more material near the neutral axis in elastic bending, so they gain more from plastic behavior.</p>
    </div>
  </div>
</div>

<!-- QUIZ SECTION -->
<div class="content-section">
  <div class="quiz-container">
    <h2>Knowledge Check Quiz</h2>

    <div class="quiz-question">
      <h3>Question 1: What is the yield stress?</h3>
      <div class="quiz-options">
        <label><input type="radio" name="q1" value="a"> The stress at which a material begins to deform plastically and permanently</label>
        <label><input type="radio" name="q1" value="b"> The maximum stress a material can withstand before fracture</label>
        <label><input type="radio" name="q1" value="c"> The stress at which elastic deformation begins</label>
        <label><input type="radio" name="q1" value="d"> The average stress throughout the cross-section</label>
      </div>
    </div>

    <div class="quiz-question">
      <h3>Question 2: Where is the plastic neutral axis located for a rectangular section?</h3>
      <div class="quiz-options">
        <label><input type="radio" name="q2" value="a"> At the top of the section</label>
        <label><input type="radio" name="q2" value="b"> At mid-depth (geometric center)</label>
        <label><input type="radio" name="q2" value="c"> At the location of maximum stress</label>
        <label><input type="radio" name="q2" value="d"> It varies depending on the applied moment</label>
      </div>
    </div>

    <div class="quiz-question">
      <h3>Question 3: What is the shape factor for a rectangular section in bending?</h3>
      <div class="quiz-options">
        <label><input type="radio" name="q3" value="a"> 1.0</label>
        <label><input type="radio" name="q3" value="b"> 1.15</label>
        <label><input type="radio" name="q3" value="c"> 1.5</label>
        <label><input type="radio" name="q3" value="d"> 2.0</label>
      </div>
    </div>

    <div class="quiz-question">
      <h3>Question 4: What happens to the stress distribution when a beam section reaches the fully plastic moment \(M_p\)?</h3>
      <div class="quiz-options">
        <label><input type="radio" name="q4" value="a"> Stress varies linearly from top to bottom</label>
        <label><input type="radio" name="q4" value="b"> All fibres are stressed to exactly the yield stress \(\pm\sigma_y\)</label>
        <label><input type="radio" name="q4" value="c"> Stress is zero at the neutral axis</label>
        <label><input type="radio" name="q4" value="d"> Stress exceeds the yield stress in some regions</label>
      </div>
    </div>

    <div class="quiz-question">
      <h3>Question 5: Why do I-sections typically have lower shape factors than rectangular sections?</h3>
      <div class="quiz-options">
        <label><input type="radio" name="q5" value="a"> I-sections are weaker in bending</label>
        <label><input type="radio" name="q5" value="b"> I-sections have less material near the neutral axis, so elastic design is already efficient</label>
        <label><input type="radio" name="q5" value="c"> I-sections always fail before reaching plastic moment</label>
        <label><input type="radio" name="q5" value="d"> The plastic neutral axis is higher in I-sections</label>
      </div>
    </div>

    <button id="submit-quiz">Submit Quiz</button>
    <div id="quiz-results"></div>
  </div>
</div>

<script>
// Quiz handler for Plasticity in Bending
document.getElementById('submit-quiz').addEventListener('click', function() {
  const answers = {
    q1: 'a',  // Plastic deformation begins
    q2: 'b',  // Mid-depth for rectangular
    q3: 'c',  // 1.5 for rectangle
    q4: 'b',  // All fibres at ±σy
    q5: 'b'   // Efficient elastic design
  };

  let score = 0;
  let totalQuestions = Object.keys(answers).length;
  let resultsHTML = '<h3>Quiz Results:</h3>';

  for (let question in answers) {
    const selectedOption = document.querySelector(`input[name="${question}"]:checked`);
    const correctAnswer = answers[question];

    if (selectedOption) {
      if (selectedOption.value === correctAnswer) {
        score++;
        resultsHTML += `<p style="color: #28a745; font-weight: bold;">${question.toUpperCase()}: Correct! ✓</p>`;
      } else {
        resultsHTML += `<p style="color: #dc3545; font-weight: bold;">${question.toUpperCase()}: Incorrect ✗</p>`;
      }
    } else {
      resultsHTML += `<p style="color: #333;">${question.toUpperCase()}: Not answered</p>`;
    }
  }

  const percentage = ((score / totalQuestions) * 100).toFixed(0);
  resultsHTML = `<p style="font-size: 1.2em; font-weight: bold;">You scored ${score} out of ${totalQuestions} (${percentage}%)</p>` + resultsHTML;

  document.getElementById('quiz-results').innerHTML = resultsHTML;
});
</script>

<footer><script src="/assets/common/footer.js"></script></footer>

<script>
// ---------- Geometry helper ----------
function makeSectionGeometry(sectionType, dims){
  let H=0, widthAtY;
  if(sectionType==='rectangular'){
    H = dims.h;
    widthAtY = y => (y>=0 && y<=H) ? dims.b : 0;
  } else if(sectionType==='t-section'){
    H = dims.tf + dims.hw;
    widthAtY = y => {
      if(y<0||y>H) return 0;
      if(y<=dims.tf) return dims.bf;
      return dims.tw;
    };
  } else { // i-section
    H = dims.h;
    widthAtY = y => {
      if(y<0||y>H) return 0;
      if(y<=dims.tf) return dims.bf;
      if(y>=H-dims.tf) return dims.bf;
      return dims.tw;
    };
  }
  const N=700, dy=H/N;
  let A=0, Ay=0, I=0;
  const ys=[], bs=[];
  for(let i=0;i<N;i++){
    const y=(i+0.5)*dy, b=widthAtY(y);
    ys.push(y); bs.push(b);
    A += b*dy; Ay += b*y*dy;
  }
  const yc=Ay/A;
  for(let i=0;i<N;i++){
    const y=ys[i], b=bs[i];
    I += b*(y-yc)*(y-yc)*dy;
  }
  function areaAbove(y0){
    let a=0; for(let i=0;i<N;i++){ if(ys[i]<=y0) a+=bs[i]*dy; } return a;
  }
  let lo=0, hi=H;
  for(let it=0; it<40; it++){
    const mid=0.5*(lo+hi);
    if(areaAbove(mid) < A/2) lo=mid; else hi=mid;
  }
  const y_pna=0.5*(lo+hi);
  let Zp=0; for(let i=0;i<N;i++){ Zp += Math.abs(ys[i]-y_pna)*bs[i]*dy; }
  const yTop = yc - 0, yBot = H - yc, yMax = Math.max(yTop, yBot);
  return {H,N,dy,ys,bs,A,yc,I,yTop,yBot,yMax,y_pna,Zp,widthAtY};
}

// ---------- helpers (graphics) ----------
function drawArrowH(p, x0, y0, x1){
  // horizontal arrow from (x0,y0) -> (x1,y0)
  p.line(x0,y0,x1,y0);
  const dir = Math.sign(x1-x0) || 1;
  const ah = 5; // arrow head size
  p.triangle(x1, y0, x1 - dir*ah, y0 - 0.6*ah, x1 - dir*ah, y0 + 0.6*ah);
}
function setDashed(p, on){ p.drawingContext.setLineDash(on? [6,6] : []); }

// ---------- SIMULATION 1 ----------
function createSimulation1(){
  return (p)=>{
    const WIDTH=980, HEIGHT=440;
    let yieldStress=250, M_target=0, sectionType='rectangular';
    let dims={b:120,h:200};
    let geom = makeSectionGeometry(sectionType, dims);
    let Me=0, Mp=0, S=0, shapeFactor=0;
    let solved=null;

    // MONOTONE NA: persistent previous NA
    let y0_prev = geom.yc;

    function recalcProps(){
      geom = makeSectionGeometry(sectionType, dims);
      S = geom.I/geom.yMax;
      Me = (yieldStress*S)/1e6;
      Mp = (yieldStress*geom.Zp)/1e6;
      shapeFactor = Mp/Me;
      if(M_target>Mp) M_target=Mp;
      solved=null;
      y0_prev = geom.yc; // reset
      updateStageIndicators();
    }

    function updateStageIndicators(){
      document.querySelectorAll('.stage-card').forEach(c=>c.classList.remove('active'));
      if(M_target < Me*0.98) document.getElementById('elastic-stage').classList.add('active');
      else if(M_target <= Me*1.02) document.getElementById('first-yield-stage').classList.add('active');
      else if(M_target < Mp*0.98) document.getElementById('elastoplastic-stage').classList.add('active');
      else document.getElementById('fully-plastic-stage').classList.add('active');
    }

    function readDims(){
      if(sectionType==='rectangular'){
        dims = {b:+document.getElementById('rect-b').value||120,
                h:+document.getElementById('rect-h').value||200};
      } else if(sectionType==='t-section'){
        dims = {bf:+document.getElementById('t-bf').value||170,
                tf:+document.getElementById('t-tf').value||30,
                tw:+document.getElementById('t-tw').value||30,
                hw:+document.getElementById('t-hw').value||170};
      } else {
        dims = {bf:+document.getElementById('i-bf').value||150,
                tf:+document.getElementById('i-tf').value||25,
                tw:+document.getElementById('i-tw').value||15,
                h:+document.getElementById('i-h').value||200};
      }
      recalcProps();
    }

    // Compute force and moment resultants for given NA position (y0) and elastic core half-height (c)
    function computeFM(y0, c){
      const {ys, bs, dy, yc} = geom;
      let F = 0, MM = 0;
      for(let i = 0; i < ys.length; i++){
        const y = ys[i], b = bs[i];
        let sig;
        if(y <= y0 - c) sig = -yieldStress;
        else if(y >= y0 + c) sig = +yieldStress;
        else sig = c > 1e-9 ? (yieldStress / c) * (y - y0) : 0;
        F  += sig * b * dy;
        MM += sig * (y - yc) * b * dy;
      }
      return {F, M: MM / 1e6};
    }

    // Find neutral axis position y0 for a given elastic core half-height c
    // Uses force equilibrium (F = 0) and ensures monotonic transition from yc to y_pna
    function findNA_forC(c, y0_hint){
      const {ys, bs, dy} = geom;

      // Physical bounds: NA must be positioned such that core fits within section
      const y_min = Math.max(c, 0);
      const y_max = Math.min(geom.H - c, geom.H);

      if(y_min >= y_max) return geom.yc;

      // For given y0, compute axial force
      const computeF = (y0) => {
        let F = 0;
        for(let i = 0; i < ys.length; i++){
          const y = ys[i], b = bs[i];
          let sig;
          if(y <= y0 - c) sig = -yieldStress;
          else if(y >= y0 + c) sig = +yieldStress;
          else sig = c > 1e-9 ? (yieldStress / c) * (y - y0) : 0;
          F += sig * b * dy;
        }
        return F;
      };

      // To avoid finding the "wrong" root in asymmetric sections,
      // we restrict the search range to be between yc and y_pna.
      // The NA must transition monotonically from yc (elastic) to y_pna (plastic).

      const y_lower_bound = Math.min(geom.yc, geom.y_pna);
      const y_upper_bound = Math.max(geom.yc, geom.y_pna);

      // Constrain search to monotonic transition region
      let lo = Math.max(y_min, y_lower_bound);
      let hi = Math.min(y_max, y_upper_bound);

      // Safety check
      if(lo >= hi) return y0_hint || geom.yc;

      let F_lo = computeF(lo);
      let F_hi = computeF(hi);

      // Check if root exists in interval
      if(F_lo * F_hi > 0){
        // No sign change in the constrained interval
        // Return the endpoint closer to zero force, or the hint if valid
        if(y0_hint && y0_hint >= lo && y0_hint <= hi){
          const F_hint = computeF(y0_hint);
          if(Math.abs(F_hint) < Math.max(Math.abs(F_lo), Math.abs(F_hi))){
            return y0_hint;
          }
        }
        return Math.abs(F_lo) < Math.abs(F_hi) ? lo : hi;
      }

      // Bisection search for F = 0
      for(let iter = 0; iter < 100; iter++){
        const mid = 0.5 * (lo + hi);
        const F_mid = computeF(mid);

        if(Math.abs(F_mid) < 1e-3) return mid;
        if(Math.abs(hi - lo) < 1e-9) return mid;

        if(F_lo * F_mid < 0){
          hi = mid;
          F_hi = F_mid;
        } else {
          lo = mid;
          F_lo = F_mid;
        }
      }

      return 0.5 * (lo + hi);
    }

    function solveDistribution(){
      if(solved && solved.M === M_target && solved.yield === yieldStress) return solved;

      // CASE 1: Fully elastic (M ≤ Me)
      if(M_target <= Me * 0.999){
        const k = (M_target * 1e6) / geom.I;
        const out = geom.ys.map(y => ({y, sigma: k * (y - geom.yc)}));
        y0_prev = geom.yc;
        solved = {stage: 'elastic', dist: out, y0: geom.yc, c: geom.yMax, M: M_target, yield: yieldStress};
        return solved;
      }

      // CASE 2: Fully plastic (M ≥ Mp)
      if(M_target >= Mp * 0.999){
        const out = geom.ys.map(y => ({y, sigma: (y < geom.y_pna ? -yieldStress : +yieldStress)}));
        y0_prev = geom.y_pna;
        solved = {stage: 'plastic', dist: out, y0: geom.y_pna, c: 0, M: M_target, yield: yieldStress};
        return solved;
      }

      // CASE 3: Elastoplastic (Me < M < Mp)
      // Strategy: parametrize by elastic core half-height c
      // As M increases from Me to Mp:
      //   - c decreases from yMax to 0
      //   - NA (y0) transitions from yc to y_pna

      // Determine bounds on c
      // At M = Me, the entire section is elastic with c = yMax
      // At M = Mp, the entire section is plastic with c = 0

      // Interpolate c based on M to get initial bounds
      const alpha = (M_target - Me) / (Mp - Me);  // 0 at Me, 1 at Mp

      // Initial guess: linearly interpolate c
      const c_elastic = geom.yMax;
      const c_plastic = 0;
      const c_guess = c_elastic * (1 - alpha);

      // Search bounds for c
      let c_lo = 1e-6;
      let c_hi = geom.yMax;

      // Bisection on c to match target moment
      let y0_best = geom.yc, c_best = c_guess, M_best = Me;

      for(let iter = 0; iter < 120; iter++){
        const c_mid = 0.5 * (c_lo + c_hi);

        // For this c, find NA position that satisfies force equilibrium
        // Pass previous y0 as hint to maintain continuity
        const y0_mid = findNA_forC(c_mid, y0_best);

        // Compute moment for this (y0, c) pair
        const result = computeFM(y0_mid, c_mid);
        const M_mid = result.M;
        const F_mid = result.F;

        // Check for convergence
        if(Math.abs(M_mid - M_target) < 1e-4){
          y0_best = y0_mid;
          c_best = c_mid;
          M_best = M_mid;
          break;
        }

        if(Math.abs(c_hi - c_lo) < 1e-9){
          y0_best = y0_mid;
          c_best = c_mid;
          M_best = M_mid;
          break;
        }

        // Adjust c bounds
        // Smaller c → larger M (more plasticity)
        if(M_mid < M_target){
          c_hi = c_mid;
        } else {
          c_lo = c_mid;
        }

        y0_best = y0_mid;
        c_best = c_mid;
        M_best = M_mid;
      }

      // Build stress distribution
      const out = geom.ys.map(y => {
        let sig;
        if(y <= y0_best - c_best) sig = -yieldStress;
        else if(y >= y0_best + c_best) sig = +yieldStress;
        else sig = c_best > 1e-9 ? (yieldStress / c_best) * (y - y0_best) : 0;
        return {y, sigma: sig};
      });

      y0_prev = y0_best;
      solved = {stage: 'elastoplastic', dist: out, y0: y0_best, c: c_best, M: M_best, yield: yieldStress};
      return solved;
    }

    p.setup = function(){
      const canvas = p.createCanvas(WIDTH, HEIGHT);
      canvas.parent('sketch-holder-1');

      document.getElementById('sectionType1').addEventListener('change', e=>{
        sectionType = e.target.value;
        document.querySelectorAll('.section-inputs').forEach(el=>el.classList.remove('active'));
        if(sectionType==='rectangular') document.getElementById('rect-inputs').classList.add('active');
        else if(sectionType==='t-section') document.getElementById('t-inputs').classList.add('active');
        else document.getElementById('i-inputs').classList.add('active');
        readDims();
      });

      document.getElementById('momentSlider1').addEventListener('input', e=>{
        M_target = parseFloat(e.target.value);
        document.getElementById('momentValue1').textContent = M_target.toFixed(0);
        solved=null; updateStageIndicators();
      });

      document.getElementById('yieldStress1').addEventListener('input', e=>{
        yieldStress = parseFloat(e.target.value);
        document.getElementById('yieldValue1').textContent = yieldStress.toFixed(0);
        recalcProps();
      });

      document.getElementById('resetBtn1').addEventListener('click', ()=>{
        M_target=0; document.getElementById('momentSlider1').value=0;
        document.getElementById('momentValue1').textContent='0';
        // Reset dimensions to defaults for all section types
        if(sectionType==='rectangular'){
          document.getElementById('rect-b').value=120;
          document.getElementById('rect-h').value=200;
          dims = {b:120, h:200};
        } else if(sectionType==='t-section'){
          document.getElementById('t-bf').value=170;
          document.getElementById('t-tf').value=30;
          document.getElementById('t-tw').value=30;
          document.getElementById('t-hw').value=170;
          dims = {bf:170, tf:30, tw:30, hw:170};
        } else if(sectionType==='i-section'){
          document.getElementById('i-bf').value=150;
          document.getElementById('i-tf').value=25;
          document.getElementById('i-tw').value=15;
          document.getElementById('i-h').value=200;
          dims = {bf:150, tf:25, tw:15, h:200};
        }
        recalcProps();
        solved=null; updateStageIndicators();
      });

      document.querySelectorAll('.section-inputs input').forEach(inp=>{
        inp.addEventListener('input', readDims);
      });

      recalcProps();
    };

    function drawPlasticBands(sol){
      // shade plastic regions as horizontal red bands within the actual section bounds
      if(sol.stage==='elastic') return;
      const x0=220, pixPerMm=300/geom.H;
      const yNA = sol.stage==='plastic' ? geom.y_pna : sol.y0;
      const c   = sol.c || 0;

      const yTopBand = Math.min(geom.H, yNA + c);
      const yTopEnd  = geom.H;
      const yBotBand = 0;
      const yBotEnd  = Math.max(0, yNA - c);

      p.push();
      p.translate(x0, HEIGHT/2);
      p.noStroke();
      p.fill(231,76,60,70); // translucent red

      // Draw top plastic band (line by line to respect section width)
      if(yTopBand < yTopEnd) {
        const step = 0.5; // mm resolution for shading
        for(let y = yTopBand; y < yTopEnd; y += step) {
          const width = geom.widthAtY(y);
          if(width > 0) {
            const w = Math.min(260, width*pixPerMm);
            const yPix = (y - geom.H/2)*pixPerMm;
            p.rect(-w/2, yPix, w, step*pixPerMm);
          }
        }
      }

      // Draw bottom plastic band (line by line to respect section width)
      if(yBotBand < yBotEnd) {
        const step = 0.5; // mm resolution for shading
        for(let y = yBotBand; y < yBotEnd; y += step) {
          const width = geom.widthAtY(y);
          if(width > 0) {
            const w = Math.min(260, width*pixPerMm);
            const yPix = (y - geom.H/2)*pixPerMm;
            p.rect(-w/2, yPix, w, step*pixPerMm);
          }
        }
      }
      p.pop();
    }

    function drawSectionPanel(sol){
      const x0=220, y0=HEIGHT/2, pixPerMm=300/geom.H;
      p.push(); p.translate(x0, y0);
      p.stroke(51); p.strokeWeight(2); p.fill(255);
      if(sectionType==='rectangular'){
        const w = Math.min(260, geom.widthAtY(geom.H/2)*pixPerMm);
        p.rect(-w/2, -geom.H*pixPerMm/2, w, geom.H*pixPerMm);
      } else if(sectionType==='t-section'){
        const bf=Math.min(260, (dims.bf)*pixPerMm);
        const tf=dims.tf*pixPerMm, tw=Math.min(260, (dims.tw)*pixPerMm), hw=dims.hw*pixPerMm;
        p.rect(-bf/2, -geom.H*pixPerMm/2, bf, tf);
        p.rect(-tw/2, -geom.H*pixPerMm/2 + tf, tw, hw);
      } else {
        const bf=Math.min(260, (dims.bf)*pixPerMm), tf=dims.tf*pixPerMm, tw=Math.min(260,(dims.tw)*pixPerMm), h=geom.H*pixPerMm;
        p.rect(-bf/2, -h/2, bf, tf);
        p.rect(-tw/2, -h/2+tf, tw, h-2*tf);
        p.rect(-bf/2,  h/2-tf, bf, tf);
      }

      // Elastic centroidal NA (thin gray dashed)
      p.stroke(150); p.strokeWeight(1); setDashed(p,true);
      p.line(-170, (geom.yc - geom.H/2)*pixPerMm, 170, (geom.yc - geom.H/2)*pixPerMm);
      setDashed(p,false);

      // Current NA (thick solid line - changes color by stage)
      const naY = sol.stage==='plastic' ? geom.y_pna : sol.y0;
      const naPix = (naY - geom.H/2)*pixPerMm;

      // Color based on stage: blue=elastic, orange=elastoplastic, red=plastic
      if(sol.stage==='elastic') p.stroke(0,96,255);
      else if(sol.stage==='elastoplastic') p.stroke(255,140,0);
      else p.stroke(220,20,60);

      p.strokeWeight(3);
      p.line(-170, naPix, 170, naPix);

      // Add NA label showing current position
      p.noStroke(); p.fill(0);
      p.textAlign(p.LEFT, p.CENTER); p.textSize(11);
      p.text(`NA: ${naY.toFixed(1)} mm`, 175, naPix);

      // Plastic NA / Bisectrix (thin gold dashed) for reference
      if(sectionType!=='rectangular'){
        p.stroke(218,165,32); p.strokeWeight(1); setDashed(p,true);
        p.line(-170, (geom.y_pna - geom.H/2)*pixPerMm, 170, (geom.y_pna - geom.H/2)*pixPerMm);
        setDashed(p,false);
      }

      p.noStroke(); p.fill(51); p.textAlign(p.CENTER);
      p.text('Cross-Section', 0, -HEIGHT/2 + 24);
      p.pop();

      // plastic bands overlay (draw after to sit on top)
      drawPlasticBands(sol);
    }

    function drawDistributionPanel(sol){
      const x0=720, y0=HEIGHT/2, pixPerMmY=300/geom.H, scaleX=120/yieldStress;
      p.push(); p.translate(x0, y0);

      // axes
      p.stroke(51); p.strokeWeight(1);
      p.line(0,-160,0,160); p.line(-140,0,140,0);

      // yield lines
      p.stroke(120); setDashed(p,true);
      p.line(+yieldStress*scaleX, -160, +yieldStress*scaleX, 160);
      p.line(-yieldStress*scaleX, -160, -yieldStress*scaleX, 160);
      setDashed(p,false);

      // draw stress curve: elastic (green) vs plastic (red)
      p.noFill();
      // elastic (|σ| < σy)
      p.stroke(46, 204, 113); p.strokeWeight(2);
      p.beginShape();
      for(let i=0;i<geom.N;i++){
        const s=sol.dist[i].sigma, y=sol.dist[i].y;
        if(Math.abs(s) < yieldStress-1e-6) p.vertex(s*scaleX, (y - geom.H/2)*pixPerMmY);
      }
      p.endShape();

      // plastic (|σ| ~ σy)
      p.stroke(231,76,60); p.strokeWeight(2);
      p.beginShape();
      for(let i=0;i<geom.N;i++){
        const s=sol.dist[i].sigma; if(Math.abs(s) < yieldStress-1e-6) continue;
        const y=sol.dist[i].y;
        p.vertex(s*scaleX, (y - geom.H/2)*pixPerMmY);
      }
      p.endShape();

      // horizontal arrows from centerline to curve (sampled)
      const step = Math.max(1, Math.floor(geom.N/12));
      for(let i=0;i<geom.N;i+=step){
        const s=sol.dist[i].sigma, y=sol.dist[i].y;
        const yp = (y - geom.H/2)*pixPerMmY;
        const xp = s*scaleX;
        if(Math.abs(s) < yieldStress-1e-6) p.stroke(46,204,113);
        else p.stroke(231,76,60);
        p.strokeWeight(2);
        drawArrowH(p, 0, yp, xp);
      }

      p.noStroke(); p.fill(51); p.textAlign(p.CENTER);
      p.text('Stress Distribution (σ vs y)', 0, -HEIGHT/2 + 24);
      p.textAlign(p.RIGHT); p.text('σ = +σy', +yieldStress*scaleX-4, -HEIGHT/2+38);
      p.textAlign(p.LEFT);  p.text('σ = -σy', -yieldStress*scaleX+4, -HEIGHT/2+38);
      p.pop();
    }

    p.setup(); // ensure p5 calls setup
    p.draw = function(){
      p.background(245);
      const sol = solveDistribution();
      drawSectionPanel(sol);
      drawDistributionPanel(sol);
      p.fill(51); p.noStroke(); p.textAlign(p.LEFT); p.textSize(12);
      p.text(`Elastic Limit: M_e = ${Me.toFixed(1)} kN·m`, 20, HEIGHT-60);
      p.text(`Plastic Limit: M_p = ${Mp.toFixed(1)} kN·m`, 20, HEIGHT-40);
      p.text(`Shape Factor: f = ${shapeFactor.toFixed(3)}`, 20, HEIGHT-20);
    };
  };
}

// ---------- SIMULATION 2 ----------
function createSimulation2(){
  return (p)=>{
    const WIDTH=980, HEIGHT=440;
    const b=120, h=200;
    const N=400, dy=h/N;
    const ys = Array.from({length:N}, (_,i)=> -h/2 + (i+0.5)*dy);
    const bs = Array.from({length:N}, ()=> b);
    const I = b*Math.pow(h,3)/12;
    const yMax=h/2, S=I/yMax;
    let sigY=250, E=200000;
    const Me=(sigY*S)/1e6, Zp=b*h*h/4, Mp=(sigY*Zp)/1e6;

    // Animation control for unloading
    const UNLOAD_FRAMES = 45; // <— change this for faster/slower animated unload

    let epsP=new Float64Array(N).fill(0);
    let sigma=new Float64Array(N).fill(0);
    let kappa=0;
    let M_current=0, M_target=0, M_max=0;
    let isLoading=false;
    let fibreAlpha=0.5;
    let showResidual=false;

    // unloading animation state
    let isUnloading=false;
    let unloadStepsLeft=0;
    let unloadStartM=0;

    // σ–ε history (segments array)
    const hist = []; // {x1,y1,x2,y2, color:[r,g,b]}
    let prevPt = null;

    // colors
    const colElastic=[46,204,113], colPlastic=[231,76,60], colUnload=[255,159,67];

    function resetState(){
      epsP.fill(0); sigma.fill(0);
      kappa=0; M_current=0; M_target=0; M_max=0;
      isLoading=false; showResidual=false;
      isUnloading=false; unloadStepsLeft=0; unloadStartM=0;
      prevPt=null; hist.length=0;
      const s2=document.getElementById('momentSlider2'); if(s2){s2.value=0; s2.disabled=true;}
      const mv2=document.getElementById('momentValue2'); if(mv2){mv2.textContent='0';}
      const mm=document.getElementById('maxMoment'); if(mm){mm.textContent='0';}
      const ls=document.getElementById('loadingState'); if(ls){ls.textContent='Unloaded';}
      const ub=document.getElementById('unloadBtn'); if(ub){ub.disabled=true;}
      const rs=document.getElementById('residualStress'); if(rs){rs.textContent='0';}
    }

    function momentFromKappaTrial(k){
      let M=0; const sig=new Float64Array(N), epsP_trial=new Float64Array(N);
      for(let i=0;i<N;i++){
        const eps=k*ys[i], sig_trial=E*(eps - epsP[i]);
        if(Math.abs(sig_trial) <= sigY){
          sig[i]=sig_trial; epsP_trial[i]=epsP[i];
        }else{
          const sgn=Math.sign(sig_trial);
          sig[i]=sgn*sigY; epsP_trial[i]=eps - sig[i]/E;
        }
        M += sig[i]*ys[i]*bs[i]*dy;
      }
      return {M:M/1e6, sig, epsP_trial};
    }

    function setToCurvatureForTargetMoment(Mt){
      let k_lo=0, k_hi=(sigY/E)*(2/yMax)*10;
      let best=momentFromKappaTrial(k_lo);
      for(let it=0; it<60; it++){
        const k_mid=0.5*(k_lo+k_hi);
        const trial=momentFromKappaTrial(k_mid);
        if(trial.M < Mt){ k_lo=k_mid; best=trial; } else { k_hi=k_mid; }
        if(Math.abs(trial.M - Mt) < 0.001){ best=trial; break; }
      }
      kappa=0.5*(k_lo+k_hi);
      sigma=best.sig; epsP=best.epsP_trial; M_current=best.M;
    }

    function unloadTo(Mt){
      function momentForK(k){
        let M=0;
        for(let i=0;i<N;i++){
          const sig_i=E*(k*ys[i]-epsP[i]);
          const sig_c=Math.max(-2*sigY, Math.min(2*sigY, sig_i));
          M += sig_c*ys[i]*bs[i]*dy;
        }
        return M/1e6;
      }
      let k_lo=-kappa, k_hi=kappa, k_best=0;
      for(let it=0; it<60; it++){
        const k_mid=0.5*(k_lo+k_hi), M_mid=momentForK(k_mid);
        if(Math.abs(M_mid - Mt) < 0.001){ k_best=k_mid; break; }
        if(M_mid < Mt) k_lo=k_mid; else k_hi=k_mid;
        k_best=k_mid;
      }
      kappa=k_best;
      for(let i=0;i<N;i++){
        const sig_un=E*(kappa*ys[i]-epsP[i]);
        sigma[i]=Math.max(-2*sigY, Math.min(2*sigY, sig_un));
      }
      M_current=momentForK(kappa);
    }

    p.setup=function(){
      const canvas=p.createCanvas(WIDTH, HEIGHT);
      canvas.parent('sketch-holder-2');

      const loadBtn=document.getElementById('loadBtn');
      const unloadBtn=document.getElementById('unloadBtn');
      const s2=document.getElementById('momentSlider2');
      const mv2=document.getElementById('momentValue2');
      const fibrePos=document.getElementById('fibrePosition');
      const fibreVal=document.getElementById('fibreValue');

      if(loadBtn){
        loadBtn.addEventListener('click', ()=>{
          isLoading=true; isUnloading=false;
          const ls=document.getElementById('loadingState'); if(ls) ls.textContent='Loading';
          if(s2) s2.disabled=false;
          if(unloadBtn) unloadBtn.disabled=false;
        });
      }
      if(unloadBtn){
        unloadBtn.addEventListener('click', ()=>{
          if(isUnloading) return;
          isLoading=false; isUnloading=true; showResidual=false;
          unloadStepsLeft = UNLOAD_FRAMES;
          unloadStartM = M_current;
          const ls=document.getElementById('loadingState'); if(ls) ls.textContent='Unloading';
          const s2=document.getElementById('momentSlider2'); if(s2) s2.disabled=true;
        });
      }
      const resetBtn2=document.getElementById('resetBtn2');
      if(resetBtn2) resetBtn2.addEventListener('click', resetState);

      if(s2){
        s2.addEventListener('input', e=>{
          if(!isLoading) return;
          M_target=+e.target.value;
          if(mv2) mv2.textContent=M_target.toFixed(0);
          if(M_target > M_max) M_max=M_target;
          const mm=document.getElementById('maxMoment'); if(mm) mm.textContent=M_max.toFixed(0);
          setToCurvatureForTargetMoment(M_target);
        });
      }
      if(fibrePos){
        fibrePos.addEventListener('input', e=>{
          fibreAlpha=+e.target.value;
          if(fibreVal) fibreVal.textContent=fibreAlpha.toFixed(2);
        });
      }
      resetState();
    };

    p.mousePressed=function(){
      const pixPerMm=300/h;
      const ySel=fibreAlpha*(h/2);
      const elemY=HEIGHT/2 + ySel*pixPerMm;
      if(Math.abs(p.mouseX - 220) < 80 && Math.abs(p.mouseY - elemY) < 15){
        document.body.style.cursor='ns-resize';
      }
    };
    p.mouseReleased=function(){ document.body.style.cursor='default'; };

    function drawLeftPanel(){
      const x0=220, y0=HEIGHT/2, pixPerMm=300/h;
      p.push(); p.translate(x0, y0);
      p.stroke(51); p.fill(255); p.strokeWeight(2);
      p.rect(-b*pixPerMm/2, -h*pixPerMm/2, b*pixPerMm, h*pixPerMm);
      p.stroke(150); p.strokeWeight(1); setDashed(p,true);
      p.line(-90,0,90,0); setDashed(p,false);
      const ySel=fibreAlpha*(h/2), ypix=ySel*pixPerMm;
      p.fill(255,193,7,160); p.stroke(255,193,7); p.strokeWeight(2);
      p.rect(-8, ypix-8, 16, 16, 2);
      p.noStroke(); p.fill(51); p.textAlign(p.CENTER);
      p.text('Section', 0, -HEIGHT/2 + 24);
      p.textSize(10); p.text(`y = ${ySel.toFixed(0)} mm`, 0, ypix + 24);
      p.pop();
    }

    function drawMidPanel(){
  const x0 = 520, y0 = HEIGHT/2;
  const pixPerMmY = 300/h, scaleX = 120/sigY;

  p.push(); 
  p.translate(x0, y0);

  // Axes
  p.stroke(51); p.strokeWeight(1);
  p.line(0, -160, 0, 160); 
  p.line(-140, 0, 140, 0);

  // Yield lines
  p.stroke(120); setDashed(p, true);
  p.line(sigY*scaleX, -160, sigY*scaleX, 160);
  p.line(-sigY*scaleX, -160, -sigY*scaleX, 160);
  setDashed(p, false);

  // 🔸 Orange whenever unloading OR fully unloaded
  const drawOrange = isUnloading || (showResidual && Math.abs(M_current) < 1e-3);

  if (drawOrange) {
    // Whole curve in orange
    p.noFill();
    p.stroke(colUnload[0], colUnload[1], colUnload[2]); // [255,159,67]
    p.strokeWeight(2);
    p.beginShape();
    for (let i = 0; i < N; i++) {
      const s = sigma[i], y = ys[i];
      p.vertex(s*scaleX, y*pixPerMmY);
    }
    p.endShape();

    // Orange arrows
    const step = Math.max(1, Math.floor(N/12));
    for (let i = 0; i < N; i += step) {
      const s = sigma[i], y = ys[i];
      p.stroke(colUnload[0], colUnload[1], colUnload[2]);
      p.strokeWeight(2);
      drawArrowH(p, 0, y*pixPerMmY, s*scaleX);
    }
  } else {
    // Green elastic part
    p.noFill();
    p.stroke(46, 204, 113); 
    p.strokeWeight(2);
    p.beginShape();
    for (let i = 0; i < N; i++) {
      const s = sigma[i], y = ys[i];
      if (Math.abs(s) < sigY - 1e-6) p.vertex(s*scaleX, y*pixPerMmY);
    }
    p.endShape();

    // Red plastic part
    p.stroke(231, 76, 60); 
    p.strokeWeight(2);
    p.beginShape();
    for (let i = 0; i < N; i++) {
      const s = sigma[i], y = ys[i];
      if (Math.abs(s) >= sigY - 1e-6) p.vertex(s*scaleX, y*pixPerMmY);
    }
    p.endShape();

    // Arrows colored to match segment type
    const step = Math.max(1, Math.floor(N/12));
    for (let i = 0; i < N; i += step) {
      const s = sigma[i], y = ys[i];
      if (Math.abs(s) < sigY - 1e-6) p.stroke(46, 204, 113); else p.stroke(231, 76, 60);
      p.strokeWeight(2);
      drawArrowH(p, 0, y*pixPerMmY, s*scaleX);
    }
  }

  // Title
  p.noStroke(); p.fill(51); p.textAlign(p.CENTER);
  p.text('Stress Distribution', 0, -HEIGHT/2 + 24);

  p.pop();
}

    function drawRightPanel(){
      const x0=820, y0=HEIGHT/2;
      const iSel = Math.max(0, Math.min(N-1, Math.round( ( (fibreAlpha*(h/2)) + h/2)/dy - 0.5 )));
      const eps=kappa*ys[iSel], sig=sigma[iSel];
      const scaleEps=30000, scaleSig=120/sigY;
      const epsY=sigY/E;

      // determine color state
      let col = isUnloading ? colUnload : (Math.abs(sig) < sigY-1e-6 ? colElastic : colPlastic);

      // add history segment
      const x = Math.max(-120, Math.min(120, eps*scaleEps));
      const y = Math.max(-160, Math.min(160, -sig*scaleSig));
      if(prevPt){
        hist.push({x1:prevPt.x, y1:prevPt.y, x2:x, y2:y, color:col});
      }
      prevPt = {x,y};

      p.push(); p.translate(x0, y0);
      // axes
      p.stroke(51); p.strokeWeight(1);
      p.line(-120,0,120,0); p.line(0,-160,0,160);
      p.stroke(120); setDashed(p,true);
      p.line(-120, -sigY*scaleSig, 120, -sigY*scaleSig);
      p.line(-120,  sigY*scaleSig, 120,  sigY*scaleSig);
      setDashed(p,false);

      // base bilinear curve (blue)
      p.stroke(100,150,200); p.strokeWeight(2);
      p.line(0,0, epsY*scaleEps, -sigY*scaleSig);
      if(epsY*scaleEps<120) p.line(epsY*scaleEps, -sigY*scaleSig, 120, -sigY*scaleSig);
      p.line(0,0, -epsY*scaleEps, sigY*scaleSig);
      if(epsY*scaleEps<120) p.line(-epsY*scaleEps, sigY*scaleSig, -120, sigY*scaleSig);

      // draw history
      for(const seg of hist){
        p.stroke(seg.color[0], seg.color[1], seg.color[2]);
        p.strokeWeight(2);
        p.line(seg.x1, seg.y1, seg.x2, seg.y2);
      }

      // current point (yellow)
      p.noStroke(); p.fill(255,0,100);
      p.circle(x, y, 8);

      p.noStroke(); p.fill(51); p.textAlign(p.CENTER);
      p.text('σ–ε at selected fibre', 0, -HEIGHT/2 + 24);
      p.textSize(10); p.text(`ε = ${eps.toExponential(2)}, σ = ${sig.toFixed(1)} MPa`, 0, 150);
      p.pop();
    }

    // animate unloading smoothly
    function stepUnloading(){
      if(!isUnloading) return;
      if(unloadStepsLeft<=0){
        isUnloading=false; showResidual=true;
        const ls=document.getElementById('loadingState'); if(ls) ls.textContent='Unloaded';
        const ySel=fibreAlpha*(h/2);
        const idx=Math.max(0, Math.min(N-1, Math.round((ySel + h/2)/dy - 0.5)));
        const rs=document.getElementById('residualStress'); if(rs) rs.textContent=sigma[idx].toFixed(1);
        return;
      }
      const frac = (unloadStepsLeft-1)/UNLOAD_FRAMES;
      const Mt = unloadStartM*frac;
      unloadTo(Mt);
      unloadStepsLeft--;
    }

    p.draw=function(){
      // advance unloading if active
      stepUnloading();

      p.background(245);
      drawLeftPanel();
      drawMidPanel();
      drawRightPanel();
    };
  };
}

// -------- Boot both simulations --------
window.addEventListener('DOMContentLoaded', ()=>{
  try{
    new p5(createSimulation1());
    new p5(createSimulation2());
  }catch(e){
    console.error('Error initializing simulations:', e);
    const holder1=document.getElementById('sketch-holder-1');
    const holder2=document.getElementById('sketch-holder-2');
    if(holder1) holder1.innerHTML='<div style="padding:12px;color:#b00;font-weight:600;">Simulation 1 failed to load.</div>';
    if(holder2) holder2.innerHTML='<div style="padding:12px;color:#b00;font-weight:600;">Simulation 2 failed to load.</div>';
  }
});
</script>

    <!-- Common JavaScript functions -->
    <script src="/assets/common/problems.js"></script>
    <script src="/assets/common/quizzes.js"></script>

</body>
</html>
