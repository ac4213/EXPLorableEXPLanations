<!DOCTYPE html>
<html>
<head>
    <title>Asteroids</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #000;
            overflow: hidden;
        }
        canvas {
            max-width: 800px !important;
            max-height: 600px !important;
        }
    </style>
</head>
<body>
<script>
let ship;
let asteroids = [];
let bullets = [];
let score = 0;
let gameOver = false;
let levelCleared = false;
let currentLevel = 1;
let canvasWidth, canvasHeight;
let levelStartTime = 0;
const LEVEL_TRANSITION_DURATION = 3000; // 3 seconds

function calculateCanvasSize() {
    canvasWidth = min(windowWidth - 20, 800);
    canvasHeight = min(windowHeight - 20, 600);
    
    if (canvasWidth / canvasHeight > 4/3) {
        canvasWidth = canvasHeight * 4/3;
    } else {
        canvasHeight = canvasWidth * 3/4;
    }
}

class Ship {
    constructor() {
        this.pos = createVector(canvasWidth/2, canvasHeight/2);
        this.r = 20;
        this.heading = 0;
        this.rotation = 0;
        this.vel = createVector(0, 0);
        this.isBoosting = false;
        this.isBraking = false;
    }

    boosting(b) {
        this.isBoosting = b;
    }

    braking(b) {
        this.isBraking = b;
    }

    update() {
        if (this.isBoosting) {
            this.boost();
        }
        if (this.isBraking) {
            // Apply braking force
            this.vel.mult(0.95);
        }
        this.pos.add(this.vel);
        this.vel.mult(0.99);
        
        if (this.pos.x > canvasWidth) this.pos.x = 0;
        if (this.pos.x < 0) this.pos.x = canvasWidth;
        if (this.pos.y > canvasHeight) this.pos.y = 0;
        if (this.pos.y < 0) this.pos.y = canvasHeight;
    }

    boost() {
        let force = p5.Vector.fromAngle(this.heading - PI/2);
        force.mult(0.1);
        this.vel.add(force);
    }

    hits(asteroid) {
        let d = dist(this.pos.x, this.pos.y, asteroid.pos.x, asteroid.pos.y);
        return d < this.r + asteroid.r;
    }

    render() {
        push();
        translate(this.pos.x, this.pos.y);
        rotate(this.heading);
        fill(0);
        stroke(255);
        triangle(-this.r, this.r, this.r, this.r, 0, -this.r);
        
        // Show brake lights when braking
        if (this.isBraking) {
            fill(255, 0, 0);
            rect(-this.r + 5, this.r - 5, 5, 5);
            rect(this.r - 10, this.r - 5, 5, 5);
        }
        pop();
    }

    setRotation(angle) {
        this.rotation = angle;
    }

    turn() {
        this.heading += this.rotation;
    }
}

class Asteroid {
    constructor(pos, r, level) {
        if (pos) {
            this.pos = pos.copy();
        } else {
            this.pos = createVector(random(canvasWidth), random(canvasHeight));
            // Ensure asteroids don't spawn too close to the ship
            while (dist(this.pos.x, this.pos.y, canvasWidth/2, canvasHeight/2) < 100) {
                this.pos = createVector(random(canvasWidth), random(canvasHeight));
            }
        }
        if (r) {
            this.r = r * 0.5;
        } else {
            this.r = random(15, 30);
        }
        
        this.level = level;
        this.vel = p5.Vector.random2D();
        // Increase speed based on level
        this.vel.mult(map(level, 1, 10, 1, 3));
        
        this.total = floor(random(5, 15));
        this.offset = [];
        for (let i = 0; i < this.total; i++) {
            this.offset[i] = random(-5, 5);
        }
    }

    update() {
        this.pos.add(this.vel);
        if (this.pos.x > canvasWidth) this.pos.x = 0;
        if (this.pos.x < 0) this.pos.x = canvasWidth;
        if (this.pos.y > canvasHeight) this.pos.y = 0;
        if (this.pos.y < 0) this.pos.y = canvasHeight;
    }

    render() {
        push();
        translate(this.pos.x, this.pos.y);
        noFill();
        stroke(255);
        beginShape();
        for (let i = 0; i < this.total; i++) {
            let angle = map(i, 0, this.total, 0, TWO_PI);
            let r = this.r + this.offset[i];
            let x = r * cos(angle);
            let y = r * sin(angle);
            vertex(x, y);
        }
        endShape(CLOSE);
        pop();
    }
}

class Bullet {
    constructor(ship) {
        this.pos = createVector(ship.pos.x, ship.pos.y);
        this.vel = p5.Vector.fromAngle(ship.heading - PI/2);
        this.vel.mult(10);
    }

    update() {
        this.pos.add(this.vel);
    }

    render() {
        push();
        stroke(255);
        strokeWeight(4);
        point(this.pos.x, this.pos.y);
        pop();
    }

    hits(asteroid) {
        let d = dist(this.pos.x, this.pos.y, asteroid.pos.x, asteroid.pos.y);
        return d < asteroid.r;
    }

    offscreen() {
        return (this.pos.x > canvasWidth || this.pos.x < 0 || 
                this.pos.y > canvasHeight || this.pos.y < 0);
    }
}

function startLevel(level) {
    asteroids = [];
    bullets = [];
    ship.pos = createVector(canvasWidth/2, canvasHeight/2);
    ship.vel = createVector(0, 0);
    
    // Increase number of asteroids with each level
    let numAsteroids = 4 + level;
    for (let i = 0; i < numAsteroids; i++) {
        asteroids.push(new Asteroid(null, null, level));
    }
    
    levelCleared = false;
    levelStartTime = millis();
}

function setup() {
    calculateCanvasSize();
    createCanvas(canvasWidth, canvasHeight);
    resetGame();
}

function resetGame() {
    ship = new Ship();
    currentLevel = 1;
    score = 0;
    gameOver = false;
    levelCleared = false;
    startLevel(currentLevel);
}

function draw() {
    background(0);
    
    if (!gameOver && !levelCleared) {
        // Check if level is cleared
        if (asteroids.length === 0) {
            levelCleared = true;
            levelStartTime = millis();
        }

        for (let i = asteroids.length - 1; i >= 0; i--) {
            if (ship.hits(asteroids[i])) {
                gameOver = true;
            }
            asteroids[i].render();
            asteroids[i].update();
        }

        for (let i = bullets.length - 1; i >= 0; i--) {
            bullets[i].render();
            bullets[i].update();
            if (bullets[i].offscreen()) {
                bullets.splice(i, 1);
            } else {
                for (let j = asteroids.length - 1; j >= 0; j--) {
                    if (bullets[i] && bullets[i].hits(asteroids[j])) {
                        if (asteroids[j].r > 15) {
                            let newAsteroids = [];
                            newAsteroids[0] = new Asteroid(asteroids[j].pos, asteroids[j].r, asteroids[j].level+2);
                            newAsteroids[1] = new Asteroid(asteroids[j].pos, asteroids[j].r, asteroids[j].level+2);
                            asteroids = asteroids.concat(newAsteroids);
                        }
                        asteroids.splice(j, 1);
                        bullets.splice(i, 1);
                        score += 100;
                        break;
                    }
                }
            }
        }

        ship.render();
        ship.turn();
        ship.update();
    }

    // Display score and level
    textAlign(RIGHT);
    textSize(24);
    fill(255);
    text(`Score: ${score}`, canvasWidth - 10, 30);
    textAlign(LEFT);
    text(`Level: ${currentLevel}`, 10, 30);

    // Level cleared screen
    if (levelCleared) {
        textAlign(CENTER);
        textSize(64);
        fill(255);
        text('LEVEL CLEARED!', canvasWidth/2, canvasHeight/2);
        textSize(32);
        text(`Score: ${score}`, canvasWidth/2, canvasHeight/2 + 50);
        
        // Start next level after delay
        if (millis() - levelStartTime > LEVEL_TRANSITION_DURATION) {
            currentLevel++;
            startLevel(currentLevel);
        }
    }

    // Game Over screen
    if (gameOver) {
        textAlign(CENTER);
        textSize(64);
        fill(255);
        text('GAME OVER', canvasWidth/2, canvasHeight/2);
        textSize(32);
        text(`Final Score: ${score}`, canvasWidth/2, canvasHeight/2 + 50);
        text('Press R to Restart', canvasWidth/2, canvasHeight/2 + 100);
    }
}

function windowResized() {
    calculateCanvasSize();
    resizeCanvas(canvasWidth, canvasHeight);
    if (ship) {
        ship.pos = createVector(canvasWidth/2, canvasHeight/2);
    }
}

function keyPressed() {
    if (keyCode === RIGHT_ARROW) {
        ship.setRotation(0.1);
    } else if (keyCode === LEFT_ARROW) {
        ship.setRotation(-0.1);
    } else if (keyCode === UP_ARROW) {
        ship.boosting(true);
    } else if (keyCode === DOWN_ARROW) {
        ship.braking(true);
    } else if (key === ' ') {
        bullets.push(new Bullet(ship));
    } else if (key === 'r' || key === 'R') {
        if (gameOver) {
            resetGame();
        }
    }
}

function keyReleased() {
    if (keyCode === RIGHT_ARROW || keyCode === LEFT_ARROW) {
        ship.setRotation(0);
    } else if (keyCode === UP_ARROW) {
        ship.boosting(false);
    } else if (keyCode === DOWN_ARROW) {
        ship.braking(false);
    }
}
</script>
</body>
</html>
