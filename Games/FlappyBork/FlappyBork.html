<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.10.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.10.0/addons/p5.sound.min.js"></script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <style>
      html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  width: 100%;
  height: 100%;
  touch-action: none;
}
canvas {
  display: block;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
    </style>

  </head>
  <body>
    <main>
    </main>
    <script>
        let bird;
let pipes = [];
let score = 0;
let highScore = 0;
let gameover = false;
let canvasWidth, canvasHeight;
let particles = [];
let bgHue = 200;
let shakeAmount = 0;
let difficulty = 1;

function setup() {
  // Make canvas responsive to screen size
  canvasWidth = min(windowWidth, 400);
  canvasHeight = min(windowHeight, 600);

  // For mobile, use portrait orientation optimally
  if (windowWidth < 600) {
    canvasWidth = windowWidth;
    canvasHeight = windowHeight;
  }

  createCanvas(canvasWidth, canvasHeight);
  colorMode(HSB, 360, 100, 100, 100);
  bird = new Bird();
  pipes.push(new Pipe());

  // Load high score from localStorage
  if (localStorage.getItem('flappyBorkHighScore')) {
    highScore = parseInt(localStorage.getItem('flappyBorkHighScore'));
  }
}

function windowResized() {
  // Adjust canvas size when window is resized
  canvasWidth = min(windowWidth, 400);
  canvasHeight = min(windowHeight, 600);

  if (windowWidth < 600) {
    canvasWidth = windowWidth;
    canvasHeight = windowHeight;
  }

  resizeCanvas(canvasWidth, canvasHeight);
}

function draw() {
  // Animated gradient background
  bgHue = (bgHue + 0.2) % 360;
  drawGradientBackground();

  // Apply screen shake
  if (shakeAmount > 0) {
    translate(random(-shakeAmount, shakeAmount), random(-shakeAmount, shakeAmount));
    shakeAmount *= 0.9;
    if (shakeAmount < 0.1) shakeAmount = 0;
  }

  if (!gameover) {
    bird.update();
    bird.show();

    // Progressive difficulty - spawn pipes faster and increase speed
    difficulty = 1 + score * 0.05;
    let spawnRate = max(50, 75 - score * 2);

    // Only spawn pipe if last pipe is at least 3x bird size away (96 pixels minimum spacing)
    let minSpacing = bird.size * 3;
    let canSpawn = pipes.length === 0 || (width - pipes[pipes.length - 1].x >= minSpacing);

    if (frameCount % spawnRate == 0 && canSpawn) {
      pipes.push(new Pipe());
    }

    for (let i = pipes.length - 1; i >= 0; i--) {
      pipes[i].show();
      pipes[i].update();

      if (pipes[i].hits(bird)) {
        gameover = true;
        shakeAmount = 10;
        // Update high score
        if (score > highScore) {
          highScore = score;
          localStorage.setItem('flappyBorkHighScore', highScore);
        }
      }

      if (pipes[i].offscreen()) {
        pipes.splice(i, 1);
        score++;
        // Create particles when scoring
        for (let j = 0; j < 10; j++) {
          particles.push(new Particle(bird.x, bird.y));
        }
      }
    }

    // Update and show particles
    for (let i = particles.length - 1; i >= 0; i--) {
      particles[i].update();
      particles[i].show();
      if (particles[i].finished()) {
        particles.splice(i, 1);
      }
    }

    // Responsive text size with color based on score
    let textScaleFactor = min(width / 400, height / 600);
    textSize(32 * textScaleFactor);
    let scoreHue = (score * 20) % 360;
    fill(scoreHue, 80, 100);
    text("Score: " + score, 10, 30 * textScaleFactor);

    // Show high score
    textSize(20 * textScaleFactor);
    fill(60, 80, 100);
    text("Best: " + highScore, 10, 60 * textScaleFactor);
  } else {
    // Show final bird position
    bird.show();

    // Responsive text size for game over
    let textScaleFactor = min(width / 400, height / 600);
    textSize(32 * textScaleFactor);
    fill(0, 100, 100);
    textAlign(CENTER, CENTER);
    text("Game Over!", width / 2, height / 2 - 60 * textScaleFactor);

    textSize(24 * textScaleFactor);
    fill(60, 80, 100);
    text("Final Score: " + score, width / 2, height / 2 - 10 * textScaleFactor);

    // Highlight if new high score
    if (score >= highScore) {
      fill(50, 100, 100);
      textSize(28 * textScaleFactor);
      text("NEW HIGH SCORE!", width / 2, height / 2 + 30 * textScaleFactor);
    } else {
      fill(60, 60, 80);
      text("Best: " + highScore, width / 2, height / 2 + 30 * textScaleFactor);
    }

    textSize(20 * textScaleFactor);
    fill(200, 60, 90);
    text("Tap to restart", width / 2, height / 2 + 80 * textScaleFactor);
    textAlign(LEFT, BASELINE);
    noLoop();
  }
}

function drawGradientBackground() {
  // Create animated gradient background
  for (let y = 0; y < height; y++) {
    let inter = map(y, 0, height, 0, 1);
    let c = lerpColor(
      color(bgHue, 60, 20),
      color((bgHue + 60) % 360, 80, 40),
      inter
    );
    stroke(c);
    line(0, y, width, y);
  }
}

function keyPressed() {
  if (key == ' ' && !gameover) {
    bird.up();
  } else if (gameover) {
    resetGame();
  }
}

// Add touch support
function touchStarted() {
  if (!gameover) {
    bird.up();
  } else {
    resetGame();
  }
  return false; // Prevent default behavior
}

function resetGame() {
  score = 0;
  pipes = [];
  particles = [];
  bird = new Bird();
  pipes.push(new Pipe());
  gameover = false;
  difficulty = 1;
  shakeAmount = 0;
  loop();
}

class Bird {
  constructor() {
    this.y = height / 2;
    this.x = 64;

    this.gravity = 0.7;
    this.lift = -12;
    this.velocity = 0;
    this.size = 32;
  }

  show() {
    push();
    translate(this.x, this.y);

    // Rotate bird based on velocity
    let angle = map(this.velocity, -10, 10, -PI/4, PI/4);
    rotate(angle);

    // Bird color changes with score
    let birdHue = (60 + score * 5) % 360;
    fill(birdHue, 80, 100);
    stroke(birdHue, 80, 80);
    strokeWeight(2);

    // Body
    ellipse(0, 0, this.size, this.size);

    // Eye
    fill(0, 0, 100);
    ellipse(5, -5, 8, 8);
    fill(0, 0, 0);
    ellipse(6, -5, 4, 4);

    // Beak
    fill(30, 100, 100);
    triangle(this.size/2, -3, this.size/2, 3, this.size/2 + 8, 0);

    pop();
  }

  up() {
    this.velocity += this.lift;
  }

  update() {
    this.velocity += this.gravity;
    this.y += this.velocity;

    if (this.y > height) {
      this.y = height;
      this.velocity = 0;
    }

    if (this.y < 0) {
      this.y = 0;
      this.velocity = 0;
    }
  }
}

class Pipe {
  constructor() {
    // Ensure gap is at least 2x bird size (64 pixels minimum)
    let minGap = bird.size * 2;
    let gap = minGap + random(minGap * 0.5, minGap * 1.5); // Gap between 64-128 pixels

    // Calculate available space and randomly position the gap
    let availableSpace = height - gap;
    this.top = random(50, availableSpace - 50); // Keep some margin from edges
    this.bottom = height - this.top - gap;

    this.x = width;
    this.w = 20;
    this.speed = 3 * difficulty;
    this.hue = (score * 30) % 360;
    this.passed = false;
  }

  hits(bird) {
    let halfBird = bird.size / 2;
    if (bird.y - halfBird < this.top || bird.y + halfBird > height - this.bottom) {
      if (bird.x + halfBird > this.x && bird.x - halfBird < this.x + this.w) {
        return true;
      }
    }
    return false;
  }

  show() {
    // Gradient pipes with colors based on difficulty
    let pipeHue = (this.hue + frameCount * 0.5) % 360;
    noStroke();

    // Top pipe
    for (let i = 0; i < this.w; i++) {
      let inter = map(i, 0, this.w, 0, 1);
      fill(pipeHue, 70 + inter * 30, 60 + inter * 20);
      rect(this.x + i, 0, 1, this.top);
    }

    // Bottom pipe
    for (let i = 0; i < this.w; i++) {
      let inter = map(i, 0, this.w, 0, 1);
      fill(pipeHue, 70 + inter * 30, 60 + inter * 20);
      rect(this.x + i, height - this.bottom, 1, this.bottom);
    }

    // Pipe caps
    fill(pipeHue, 80, 70);
    rect(this.x - 3, this.top - 5, this.w + 6, 5);
    rect(this.x - 3, height - this.bottom, this.w + 6, 5);
  }

  update() {
    this.x -= this.speed;
  }

  offscreen() {
    return (this.x < -this.w);
  }
}

class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.vx = random(-3, 3);
    this.vy = random(-5, -1);
    this.alpha = 100;
    this.hue = random(360);
    this.size = random(3, 8);
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.2;
    this.alpha -= 3;
  }

  show() {
    noStroke();
    fill(this.hue, 80, 100, this.alpha);
    ellipse(this.x, this.y, this.size);
  }

  finished() {
    return this.alpha <= 0;
  }
}

    </script>
  </body>
</html>
