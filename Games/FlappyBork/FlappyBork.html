<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.10.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.10.0/addons/p5.sound.min.js"></script>
    <script src="/Games/shared/highscore-api.js"></script>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <style>
      html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  width: 100%;
  height: 100%;
  touch-action: none;
}
canvas {
  display: block;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

/* Leaderboard Modal Styles */
.modal-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.8);
  z-index: 999;
  animation: fadeIn 0.3s;
}

.modal-content {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding: 25px;
  border-radius: 15px;
  max-width: 500px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
  z-index: 1000;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
  animation: slideIn 0.3s;
}

.modal-content h2 {
  margin: 0 0 20px 0;
  text-align: center;
  color: white;
  font-family: Arial, sans-serif;
  font-size: 28px;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
}

#leaderboard-list {
  margin: 20px 0;
  background: rgba(255, 255, 255, 0.95);
  border-radius: 10px;
  padding: 15px;
  max-height: 50vh;
  overflow-y: auto;
}

.leaderboard-entry {
  display: flex;
  justify-content: space-between;
  padding: 12px 15px;
  margin: 8px 0;
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  font-family: Arial, sans-serif;
  transition: transform 0.2s;
}

.leaderboard-entry:hover {
  transform: translateX(5px);
}

.leaderboard-entry.top3 {
  background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
  font-weight: bold;
  box-shadow: 0 4px 10px rgba(255, 215, 0, 0.4);
}

.leaderboard-entry.top1 {
  background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%);
  font-size: 1.1em;
}

.entry-rank {
  font-weight: bold;
  color: #667eea;
  min-width: 40px;
}

.entry-name {
  flex: 1;
  padding: 0 10px;
  color: #333;
}

.entry-score {
  font-weight: bold;
  color: #764ba2;
}

.modal-content button {
  width: 100%;
  padding: 12px;
  font-size: 18px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: bold;
  margin-top: 10px;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
  transition: transform 0.2s, box-shadow 0.2s;
}

.modal-content button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
}

.modal-content button:active {
  transform: translateY(0);
}

.loading {
  text-align: center;
  color: #666;
  padding: 20px;
  font-family: Arial, sans-serif;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideIn {
  from {
    transform: translate(-50%, -60%);
    opacity: 0;
  }
  to {
    transform: translate(-50%, -50%);
    opacity: 1;
  }
}
    </style>

  </head>
  <body>
    <main>
    </main>

    <!-- Leaderboard Modal -->
    <div id="leaderboard-modal" class="modal-overlay" onclick="closeLeaderboard()">
      <div class="modal-content" onclick="event.stopPropagation()">
        <h2>üèÜ Leaderboard üèÜ</h2>
        <div id="leaderboard-list">
          <div class="loading">Loading...</div>
        </div>
        <button onclick="closeLeaderboard()">Close</button>
      </div>
    </div>

    <script>
        let bird;
let pipes = [];
let score = 0;
let highScore = 0;
let gameover = false;
let canvasWidth, canvasHeight;
let particles = [];
let bgHue = 200;
let shakeAmount = 0;
let difficulty = 1;

// High Score API Integration
let scoreAPI;
let scoreSubmitted = false;

function setup() {
  // Make canvas responsive to screen size
  canvasWidth = min(windowWidth, 400);
  canvasHeight = min(windowHeight, 600);

  // For mobile, use portrait orientation optimally
  if (windowWidth < 600) {
    canvasWidth = windowWidth;
    canvasHeight = windowHeight;
  }

  createCanvas(canvasWidth, canvasHeight);
  colorMode(HSB, 360, 100, 100, 100);
  bird = new Bird();
  pipes.push(new Pipe());

  // Initialize High Score API
  scoreAPI = new HighScoreAPI('flappybork');

  // Load high score from localStorage (backward compatible)
  if (localStorage.getItem('flappyBorkHighScore')) {
    highScore = parseInt(localStorage.getItem('flappyBorkHighScore'));
  }

  // Also check API for high score
  const localHigh = scoreAPI.getLocalHighScore();
  if (localHigh.score > highScore) {
    highScore = localHigh.score;
  }
}

function windowResized() {
  // Adjust canvas size when window is resized
  canvasWidth = min(windowWidth, 400);
  canvasHeight = min(windowHeight, 600);

  if (windowWidth < 600) {
    canvasWidth = windowWidth;
    canvasHeight = windowHeight;
  }

  resizeCanvas(canvasWidth, canvasHeight);
}

function draw() {
  // Animated gradient background
  bgHue = (bgHue + 0.2) % 360;
  drawGradientBackground();

  // Apply screen shake
  if (shakeAmount > 0) {
    translate(random(-shakeAmount, shakeAmount), random(-shakeAmount, shakeAmount));
    shakeAmount *= 0.9;
    if (shakeAmount < 0.1) shakeAmount = 0;
  }

  if (!gameover) {
    bird.update();
    bird.show();

    // Progressive difficulty - spawn pipes faster and increase speed
    difficulty = 1 + score * 0.05;
    let spawnRate = max(50, 75 - score * 2);

    // Only spawn pipe if last pipe is at least 3x bird size away (96 pixels minimum spacing)
    let minSpacing = bird.size * 3;
    let canSpawn = pipes.length === 0 || (width - pipes[pipes.length - 1].x >= minSpacing);

    if (frameCount % spawnRate == 0 && canSpawn) {
      pipes.push(new Pipe());
    }

    for (let i = pipes.length - 1; i >= 0; i--) {
      pipes[i].show();
      pipes[i].update();

      if (pipes[i].hits(bird)) {
        gameover = true;
        shakeAmount = 10;
        // Update high score
        if (score > highScore) {
          highScore = score;
          localStorage.setItem('flappyBorkHighScore', highScore);
        }
      }

      if (pipes[i].offscreen()) {
        pipes.splice(i, 1);
        score++;
        // Create particles when scoring
        for (let j = 0; j < 10; j++) {
          particles.push(new Particle(bird.x, bird.y));
        }
      }
    }

    // Update and show particles
    for (let i = particles.length - 1; i >= 0; i--) {
      particles[i].update();
      particles[i].show();
      if (particles[i].finished()) {
        particles.splice(i, 1);
      }
    }

    // Responsive text size with color based on score
    let textScaleFactor = min(width / 400, height / 600);
    textSize(32 * textScaleFactor);
    let scoreHue = (score * 20) % 360;
    fill(scoreHue, 80, 100);
    text("Score: " + score, 10, 30 * textScaleFactor);

    // Show high score
    textSize(20 * textScaleFactor);
    fill(60, 80, 100);
    text("Best: " + highScore, 10, 60 * textScaleFactor);
  } else {
    // Show final bird position
    bird.show();

    // Responsive text size for game over
    let textScaleFactor = min(width / 400, height / 600);
    textSize(32 * textScaleFactor);
    fill(0, 100, 100);
    textAlign(CENTER, CENTER);
    text("Game Over!", width / 2, height / 2 - 60 * textScaleFactor);

    textSize(24 * textScaleFactor);
    fill(60, 80, 100);
    text("Final Score: " + score, width / 2, height / 2 - 10 * textScaleFactor);

    // Highlight if new high score
    if (score >= highScore) {
      fill(50, 100, 100);
      textSize(28 * textScaleFactor);
      text("NEW HIGH SCORE!", width / 2, height / 2 + 30 * textScaleFactor);
    } else {
      fill(60, 60, 80);
      text("Best: " + highScore, width / 2, height / 2 + 30 * textScaleFactor);
    }

    textSize(20 * textScaleFactor);
    fill(200, 60, 90);
    text("Tap to restart", width / 2, height / 2 + 80 * textScaleFactor);

    // Show leaderboard prompt
    textSize(16 * textScaleFactor);
    fill(120, 70, 100);
    text("Press L for Leaderboard", width / 2, height / 2 + 110 * textScaleFactor);

    textAlign(LEFT, BASELINE);

    // Submit score to API
    if (score > 0 && !scoreSubmitted) {
      submitHighScore();
    }

    noLoop();
  }
}

function drawGradientBackground() {
  // Create animated gradient background
  for (let y = 0; y < height; y++) {
    let inter = map(y, 0, height, 0, 1);
    let c = lerpColor(
      color(bgHue, 60, 20),
      color((bgHue + 60) % 360, 80, 40),
      inter
    );
    stroke(c);
    line(0, y, width, y);
  }
}

function keyPressed() {
  if (key == ' ' && !gameover) {
    bird.up();
  } else if (gameover) {
    // Show leaderboard on 'L' key
    if (key === 'l' || key === 'L') {
      showLeaderboard();
    } else {
      resetGame();
    }
  } else if (key === 'l' || key === 'L') {
    // Can also view leaderboard during gameplay
    showLeaderboard();
  }
}

// Add touch support
function touchStarted() {
  if (!gameover) {
    bird.up();
  } else {
    resetGame();
  }
  return false; // Prevent default behavior
}

function resetGame() {
  score = 0;
  pipes = [];
  particles = [];
  bird = new Bird();
  pipes.push(new Pipe());
  gameover = false;
  difficulty = 1;
  shakeAmount = 0;
  scoreSubmitted = false;
  loop();
}

class Bird {
  constructor() {
    this.y = height / 2;
    this.x = 64;

    this.gravity = 0.7;
    this.lift = -12;
    this.velocity = 0;
    this.size = 32;
  }

  show() {
    push();
    translate(this.x, this.y);

    // Rotate bird based on velocity
    let angle = map(this.velocity, -10, 10, -PI/4, PI/4);
    rotate(angle);

    // Bird color changes with score
    let birdHue = (60 + score * 5) % 360;
    fill(birdHue, 80, 100);
    stroke(birdHue, 80, 80);
    strokeWeight(2);

    // Body
    ellipse(0, 0, this.size, this.size);

    // Eye
    fill(0, 0, 100);
    ellipse(5, -5, 8, 8);
    fill(0, 0, 0);
    ellipse(6, -5, 4, 4);

    // Beak
    fill(30, 100, 100);
    triangle(this.size/2, -3, this.size/2, 3, this.size/2 + 8, 0);

    pop();
  }

  up() {
    this.velocity += this.lift;
  }

  update() {
    this.velocity += this.gravity;
    this.y += this.velocity;

    if (this.y > height) {
      this.y = height;
      this.velocity = 0;
    }

    if (this.y < 0) {
      this.y = 0;
      this.velocity = 0;
    }
  }
}

class Pipe {
  constructor() {
    // Ensure gap is at least 2.25x bird size (64 pixels minimum)
    let minGap = bird.size * 2.25;
    let gap = minGap + random(minGap * 0.5, minGap * 1.5); // Gap between 64-128 pixels

    // Calculate available space and randomly position the gap
    let availableSpace = height - gap;
    this.top = random(50, availableSpace - 50); // Keep some margin from edges
    this.bottom = height - this.top - gap;

    this.x = width;
    this.w = 20;
    this.speed = 3 * difficulty;
    this.hue = (score * 30) % 360;
    this.passed = false;
  }

  hits(bird) {
    let halfBird = bird.size / 2;
    if (bird.y - halfBird < this.top || bird.y + halfBird > height - this.bottom) {
      if (bird.x + halfBird > this.x && bird.x - halfBird < this.x + this.w) {
        return true;
      }
    }
    return false;
  }

  show() {
    // Gradient pipes with colors based on difficulty
    let pipeHue = (this.hue + frameCount * 0.5) % 360;
    noStroke();

    // Top pipe
    for (let i = 0; i < this.w; i++) {
      let inter = map(i, 0, this.w, 0, 1);
      fill(pipeHue, 70 + inter * 30, 60 + inter * 20);
      rect(this.x + i, 0, 1, this.top);
    }

    // Bottom pipe
    for (let i = 0; i < this.w; i++) {
      let inter = map(i, 0, this.w, 0, 1);
      fill(pipeHue, 70 + inter * 30, 60 + inter * 20);
      rect(this.x + i, height - this.bottom, 1, this.bottom);
    }

    // Pipe caps
    fill(pipeHue, 80, 70);
    rect(this.x - 3, this.top - 5, this.w + 6, 5);
    rect(this.x - 3, height - this.bottom, this.w + 6, 5);
  }

  update() {
    this.x -= this.speed;
  }

  offscreen() {
    return (this.x < -this.w);
  }
}

class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.vx = random(-3, 3);
    this.vy = random(-5, -1);
    this.alpha = 100;
    this.hue = random(360);
    this.size = random(3, 8);
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.2;
    this.alpha -= 3;
  }

  show() {
    noStroke();
    fill(this.hue, 80, 100, this.alpha);
    ellipse(this.x, this.y, this.size);
  }

  finished() {
    return this.alpha <= 0;
  }
}

// ============================================================================
// High Score API Functions
// ============================================================================

/**
 * Submit high score to the API
 */
async function submitHighScore() {
  if (score > 0 && !scoreSubmitted) {
    scoreSubmitted = true;

    // Always prompt for name (allows multiple players per device)
    const playerName = scoreAPI.promptForScoreSubmission(score);

    // Submit to API
    const result = await scoreAPI.submitScore(playerName, score);

    if (result.success) {
      console.log(`‚úÖ Score submitted! Rank: ${result.rank}`);
      if (result.rank <= 10) {
        console.log(`üéâ You're in the top 10!`);
      }
    } else if (result.fallback) {
      console.log('‚ö†Ô∏è API unavailable, score saved locally');
    } else {
      console.log('‚ùå Score submission failed:', result.error);
    }
  }
}

/**
 * Show the leaderboard modal
 */
async function showLeaderboard() {
  const modal = document.getElementById('leaderboard-modal');
  const listDiv = document.getElementById('leaderboard-list');

  // Show modal with loading state
  modal.style.display = 'block';
  listDiv.innerHTML = '<div class="loading">Loading leaderboard...</div>';

  try {
    // Fetch leaderboard data
    const leaderboard = await scoreAPI.getLeaderboard(10);

    if (leaderboard.length > 0) {
      // Build leaderboard HTML
      let html = '';
      leaderboard.forEach(entry => {
        const topClass = entry.rank <= 3 ? 'top3' : '';
        const top1Class = entry.rank === 1 ? 'top1' : '';
        const medal = entry.rank === 1 ? 'ü•á' : entry.rank === 2 ? 'ü•à' : entry.rank === 3 ? 'ü•â' : '';

        html += `
          <div class="leaderboard-entry ${topClass} ${top1Class}">
            <span class="entry-rank">${medal} ${entry.rank}.</span>
            <span class="entry-name">${entry.player_name}</span>
            <span class="entry-score">${entry.score}</span>
          </div>
        `;
      });

      listDiv.innerHTML = html;
    } else {
      listDiv.innerHTML = '<div class="loading">No scores yet. Be the first!</div>';
    }
  } catch (error) {
    console.error('Failed to load leaderboard:', error);
    listDiv.innerHTML = '<div class="loading">Failed to load leaderboard. Please try again.</div>';
  }
}

/**
 * Close the leaderboard modal
 */
function closeLeaderboard() {
  const modal = document.getElementById('leaderboard-modal');
  modal.style.display = 'none';
}

    </script>
  </body>
</html>
