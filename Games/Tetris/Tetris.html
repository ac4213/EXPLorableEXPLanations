<!DOCTYPE html>
<html>
<head>
    <title>Tetris</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="/Games/shared/highscore-api.js"></script>
    <script src="/Games/shared/leaderboard.js"></script>
    <link rel="stylesheet" href="/Games/shared/leaderboard.css">
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a1a;
            touch-action: none;
        }
        #soundToggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 10px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 20px;
            z-index: 1000;
        }
        #leaderboardBtn {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 1001;
        }
    </style>
</head>
<body>
    <button id="soundToggle">üîä</button>
    <button id="leaderboardBtn" class="leaderboard-button">üèÜ View Leaderboard</button>
<script>
// Sound system
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();
let isSoundEnabled = true;

// Sound functions
function playTone(frequency, duration, type = 'square') {
    if (!isSoundEnabled) return;
    
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    
    oscillator.type = type;
    oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
    
    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
    
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + duration);
}

function playRotateSound() {
    playTone(580, 0.1);
}

function playDropSound() {
    playTone(220, 0.2);
}

function playClearSound() {
    playTone(440, 0.1, 'sine');
    setTimeout(() => playTone(550, 0.1, 'sine'), 50);
    setTimeout(() => playTone(660, 0.1, 'sine'), 100);
}

function playGameOverSound() {
    playTone(440, 0.2, 'sine');
    setTimeout(() => playTone(330, 0.2, 'sine'), 200);
    setTimeout(() => playTone(220, 0.3, 'sine'), 400);
}

function playLevelUpSound() {
    playTone(523, 0.1, 'sine');
    setTimeout(() => playTone(659, 0.1, 'sine'), 100);
    setTimeout(() => playTone(784, 0.1, 'sine'), 200);
    setTimeout(() => playTone(1047, 0.2, 'sine'), 300);
}

// Sound toggle
document.getElementById('soundToggle').addEventListener('click', () => {
    isSoundEnabled = !isSoundEnabled;
    document.getElementById('soundToggle').textContent = isSoundEnabled ? 'üîä' : 'üîà';
});

// High Score API Integration
let scoreAPI;
let scoreSubmitted = false;

new p5(function(p) {
    let grid = [];
    let currentPiece;
    let nextPiece;
    let score = 0;
    let lines = 0;
    let level = 1;
    let gameOver = false;
    let cellSize;
    let startX;
    let startY;
    let touchStartX;
    let touchStartY;
    let gameSpeed;
    let lastMove = 0;
    let clearAnimationLines = [];
    let clearAnimationProgress = 0;
    let particles = [];
    let dropParticles = [];
    let levelUpEffect = 0;
    let comboCount = 0;
    let lastClearTime = 0;

    const COLS = 10;
    const ROWS = 20;

    // NES Tetris colors - each piece has its own color
    const PIECE_COLORS = {
        I: '#00F0F0', // Cyan
        O: '#F0F000', // Yellow
        T: '#A000F0', // Purple
        L: '#F0A000', // Orange
        J: '#0000F0', // Blue
        S: '#00F000', // Green
        Z: '#F00000'  // Red
    };

    const PIECES = {
        I: { shape: [[1, 1, 1, 1]], color: PIECE_COLORS.I },
        O: { shape: [[1, 1], [1, 1]], color: PIECE_COLORS.O },
        T: { shape: [[0, 1, 0], [1, 1, 1]], color: PIECE_COLORS.T },
        L: { shape: [[1, 0], [1, 0], [1, 1]], color: PIECE_COLORS.L },
        J: { shape: [[0, 1], [0, 1], [1, 1]], color: PIECE_COLORS.J },
        S: { shape: [[1, 1, 0], [0, 1, 1]], color: PIECE_COLORS.S },
        Z: { shape: [[0, 1, 1], [1, 1, 0]], color: PIECE_COLORS.Z }
    };

    const PIECE_TYPES = ['I', 'O', 'T', 'L', 'J', 'S', 'Z'];

    p.setup = function() {
        cellSize = p.min(p.floor(p.windowHeight / 24), p.floor(p.windowWidth / 20));
        let cnv = p.createCanvas(cellSize * 20, cellSize * 24);

        startX = cellSize * 2;
        startY = cellSize * 2;

        // Initialize High Score API
        scoreAPI = new HighScoreAPI('tetris');

        // Initialize leaderboard modal
        initLeaderboardModal();

        // Add leaderboard button click handler
        document.getElementById('leaderboardBtn').addEventListener('click', () => {
            showLeaderboard(scoreAPI);
        });

        for (let i = 0; i < ROWS; i++) {
            grid[i] = new Array(COLS).fill(0);
        }

        currentPiece = createPiece();
        nextPiece = createPiece();
        gameSpeed = 800;
        
        cnv.touchStarted(handleTouchStart);
        cnv.touchEnded(handleTouchEnd);
    };

    function createPiece() {
        const type = PIECE_TYPES[p.floor(p.random(PIECE_TYPES.length))];
        const pieceData = PIECES[type];
        return {
            shape: pieceData.shape,
            color: pieceData.color,
            type: type,
            x: p.floor(COLS / 2) - 1,
            y: 0
        };
    }

    p.draw = function() {
        p.background('#1a1a1a');

        if (!gameOver) {
            if (p.millis() - lastMove > gameSpeed) {
                movePiece(0, 1);
                lastMove = p.millis();
            }

            // Draw game area border with glow effect
            p.stroke('#ffffff');
            p.strokeWeight(2);
            p.noFill();
            p.rect(startX - 1, startY - 1, COLS * cellSize + 2, ROWS * cellSize + 2);
            p.strokeWeight(1);

            // Draw grid with subtle grid lines
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    // Subtle grid background
                    p.stroke(40, 40, 40);
                    p.noFill();
                    p.rect(startX + x * cellSize, startY + y * cellSize, cellSize, cellSize);

                    if (grid[y][x]) {
                        // Draw blocks with 3D effect
                        p.noStroke();
                        p.fill(grid[y][x]);
                        p.rect(startX + x * cellSize, startY + y * cellSize, cellSize, cellSize);

                        // Add highlight
                        p.fill(255, 255, 255, 60);
                        p.rect(startX + x * cellSize, startY + y * cellSize, cellSize, 2);
                        p.rect(startX + x * cellSize, startY + y * cellSize, 2, cellSize);
                    }
                }
            }

            // Draw ghost piece (preview where piece will land)
            //drawGhostPiece();

            // Draw current piece
            drawPiece(currentPiece);

            // Draw particles
            updateAndDrawParticles();

            // Draw drop particles
            updateAndDrawDropParticles();

            drawUI();

            if (clearAnimationLines.length > 0) {
                drawClearAnimation();
            }

            // Level up effect
            if (levelUpEffect > 0) {
                p.fill(255, 255, 0, levelUpEffect);
                p.textSize(cellSize * 2);
                p.textAlign(p.CENTER, p.CENTER);
                p.text('LEVEL UP!', p.width / 2, p.height / 2);
                levelUpEffect -= 5;
            }
        } else {
            drawGameOver();
        }
    };

    function drawUI() {
        let uiX = startX + (COLS * cellSize) + cellSize * 2;

        p.fill('#ffffff');
        p.textSize(cellSize);
        p.textAlign(p.LEFT);
        p.text(`Score: ${score}`, uiX, startY + cellSize);
        p.text(`Lines: ${lines}`, uiX, startY + cellSize * 2.5);
        p.text(`Level: ${level}`, uiX, startY + cellSize * 4);

        // Show combo if active
        if (comboCount > 1) {
            p.fill(255, 255, 0);
            p.textSize(cellSize * 0.8);
            p.text(`COMBO x${comboCount}!`, uiX, startY + cellSize * 5.2);
        }

        // Next piece preview
        p.fill('#ffffff');
        p.textSize(cellSize * 0.7);
        p.text('NEXT:', uiX, startY + cellSize * 6.5);

        p.stroke('#ffffff');
        p.noFill();
        p.rect(uiX, startY + cellSize * 7, cellSize * 4, cellSize * 4);

        let previewX = uiX + cellSize * 2 - (nextPiece.shape[0].length * cellSize) / 2;
        let previewY = startY + cellSize * 9 - (nextPiece.shape.length * cellSize) / 2;

        drawPieceAt(nextPiece, previewX, previewY);

        // Controls info
        p.fill(150);
        p.textSize(cellSize * 0.5);
        p.textAlign(p.LEFT);
        let controlY = startY + cellSize * 12;
        p.text('Controls:', uiX, controlY);
        p.text('‚Üê‚Üí: Move', uiX, controlY + cellSize * 0.8);
        p.text('‚Üë: Rotate', uiX, controlY + cellSize * 1.5);
        p.text('‚Üì: Drop', uiX, controlY + cellSize * 2.2);
        p.text('Tap: Rotate', uiX, controlY + cellSize * 3.2);
        p.text('Swipe: Move/Drop', uiX, controlY + cellSize * 3.9);
    }

    function drawPiece(piece) {
        drawPieceAt(piece, startX + piece.x * cellSize, startY + piece.y * cellSize);
    }

    function drawPieceAt(piece, x, y) {
        p.noStroke();
        p.fill(piece.color);
        for (let row = 0; row < piece.shape.length; row++) {
            for (let col = 0; col < piece.shape[row].length; col++) {
                if (piece.shape[row][col]) {
                    p.rect(x + col * cellSize, y + row * cellSize, cellSize, cellSize);

                    // Add 3D highlight effect
                    p.fill(255, 255, 255, 60);
                    p.rect(x + col * cellSize, y + row * cellSize, cellSize, 2);
                    p.rect(x + col * cellSize, y + row * cellSize, 2, cellSize);
                    p.fill(piece.color);
                }
            }
        }
    }

    function drawGhostPiece() {
        // Calculate where piece would land
        let ghostY = currentPiece.y;
        let testPiece = {
            shape: currentPiece.shape,
            x: currentPiece.x,
            y: ghostY,
            color: currentPiece.color
        };

        while (!collision(testPiece)) {
            ghostY++;
            testPiece.y = ghostY;
        }
        ghostY--;

        // Draw ghost piece
        p.noStroke();
        for (let row = 0; row < currentPiece.shape.length; row++) {
            for (let col = 0; col < currentPiece.shape[row].length; col++) {
                if (currentPiece.shape[row][col]) {
                    let c = p.color(currentPiece.color);
                    p.fill(p.red(c), p.green(c), p.blue(c), 50);
                    p.rect(
                        startX + (currentPiece.x + col) * cellSize,
                        startY + (ghostY + row) * cellSize,
                        cellSize,
                        cellSize
                    );
                }
            }
        }
    }

    function createParticle(x, y, color) {
        return {
            x: x,
            y: y,
            vx: p.random(-2, 2),
            vy: p.random(-3, -1),
            life: 255,
            color: color,
            size: p.random(2, 6)
        };
    }

    function updateAndDrawParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            let particle = particles[i];

            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.vy += 0.2; // gravity
            particle.life -= 5;

            if (particle.life <= 0) {
                particles.splice(i, 1);
                continue;
            }

            p.noStroke();
            let c = p.color(particle.color);
            p.fill(p.red(c), p.green(c), p.blue(c), particle.life);
            p.circle(particle.x, particle.y, particle.size);
        }
    }

    function updateAndDrawDropParticles() {
        for (let i = dropParticles.length - 1; i >= 0; i--) {
            let particle = dropParticles[i];

            particle.y += particle.vy;
            particle.vy += 0.5;
            particle.life -= 8;

            if (particle.life <= 0) {
                dropParticles.splice(i, 1);
                continue;
            }

            p.noStroke();
            let c = p.color(particle.color);
            p.fill(p.red(c), p.green(c), p.blue(c), particle.life);
            p.rect(particle.x, particle.y, particle.size, particle.size);
        }
    }

    function drawGameOver() {
        p.background(0, 0, 0, 200);
        p.fill('#ffffff');
        p.textSize(cellSize * 2);
        p.textAlign(p.CENTER, p.CENTER);
        p.text('GAME OVER', p.width / 2, p.height / 2 - cellSize);
        p.textSize(cellSize);
        p.text(`Final Score: ${score}`, p.width / 2, p.height / 2 + cellSize);
        p.text('Click to restart', p.width / 2, p.height / 2 + cellSize * 3);
        p.textSize(cellSize * 0.6);
        p.text('Press L for Leaderboard', p.width / 2, p.height / 2 + cellSize * 4);

        // Submit score to API
        if (score > 0 && !scoreSubmitted) {
            submitTetrisScore();
        }

        // Show leaderboard button
        document.getElementById('leaderboardBtn').style.display = 'block';
    }

    function drawClearAnimation() {
        clearAnimationProgress += 20;

        for (let line of clearAnimationLines) {
            // Pulsing white overlay effect
            let alpha = p.sin(clearAnimationProgress * 0.1) * 127 + 127;
            p.fill(255, 255, 255, alpha);
            p.rect(startX, startY + line * cellSize, COLS * cellSize, cellSize);

            // Horizontal line sweep effect
            let sweepWidth = (clearAnimationProgress / 255) * COLS * cellSize;
            p.fill(255, 255, 0, 200 - clearAnimationProgress);
            p.rect(startX, startY + line * cellSize, sweepWidth, cellSize);
        }

        if (clearAnimationProgress >= 255) {
            removeLines(clearAnimationLines);
            clearAnimationLines = [];
            clearAnimationProgress = 0;
        }
    }

    function movePiece(dx, dy) {
        currentPiece.x += dx;
        currentPiece.y += dy;
        
        if (collision()) {
            currentPiece.x -= dx;
            currentPiece.y -= dy;
            
            if (dy > 0) {
                mergePiece();
                playDropSound();
                checkLines();
                currentPiece = nextPiece;
                nextPiece = createPiece();
                
                if (collision()) {
                    gameOver = true;
                    playGameOverSound();
                }
            }
            return false;
        } else {
            // Hide leaderboard button during gameplay
            document.getElementById('leaderboardBtn').style.display = 'none';
        }

        return true;
    }

    function rotatePiece() {
        let rotated = [];
        for (let x = 0; x < currentPiece.shape[0].length; x++) {
            rotated[x] = [];
            for (let y = 0; y < currentPiece.shape.length; y++) {
                rotated[x][currentPiece.shape.length - 1 - y] = currentPiece.shape[y][x];
            }
        }
        
        let oldShape = currentPiece.shape;
        currentPiece.shape = rotated;
        
        if (collision()) {
            currentPiece.shape = oldShape;
            return false;
        }
        
        playRotateSound();
        return true;
    }

    function collision(piece = currentPiece) {
        for (let y = 0; y < piece.shape.length; y++) {
            for (let x = 0; x < piece.shape[y].length; x++) {
                if (piece.shape[y][x]) {
                    let newX = piece.x + x;
                    let newY = piece.y + y;

                    if (newX < 0 || newX >= COLS || newY >= ROWS) return true;
                    if (newY >= 0 && grid[newY][newX]) return true;
                }
            }
        }
        return false;
    }

    function mergePiece() {
        for (let y = 0; y < currentPiece.shape.length; y++) {
            for (let x = 0; x < currentPiece.shape[y].length; x++) {
                if (currentPiece.shape[y][x]) {
                    let newY = currentPiece.y + y;
                    if (newY >= 0) {
                        grid[newY][currentPiece.x + x] = currentPiece.color;

                        // Create particles on merge
                        let px = startX + (currentPiece.x + x) * cellSize + cellSize / 2;
                        let py = startY + newY * cellSize + cellSize / 2;
                        for (let i = 0; i < 3; i++) {
                            dropParticles.push({
                                x: px,
                                y: py,
                                vy: p.random(-2, 0),
                                life: 255,
                                color: currentPiece.color,
                                size: p.random(3, 6)
                            });
                        }
                    }
                }
            }
        }
    }

    function checkLines() {
        let linesToClear = [];
        
        for (let y = ROWS - 1; y >= 0; y--) {
            let complete = true;
            for (let x = 0; x < COLS; x++) {
                if (!grid[y][x]) {
                    complete = false;
                    break;
                }
            }
            if (complete) {
                linesToClear.push(y);
            }
        }
        
        if (linesToClear.length > 0) {
            clearAnimationLines = linesToClear;

            // Create particles for cleared lines
            for (let line of linesToClear) {
                for (let x = 0; x < COLS; x++) {
                    let px = startX + x * cellSize + cellSize / 2;
                    let py = startY + line * cellSize + cellSize / 2;
                    let color = grid[line][x];
                    for (let i = 0; i < 5; i++) {
                        particles.push(createParticle(px, py, color));
                    }
                }
            }

            // Check for combo
            if (p.millis() - lastClearTime < 3000) {
                comboCount++;
            } else {
                comboCount = 1;
            }
            lastClearTime = p.millis();

            let oldLevel = level;
            lines += linesToClear.length;
            score += calculateScore(linesToClear.length) * comboCount;
            level = p.floor(lines / 10) + 1;

            // Level up effect
            if (level > oldLevel) {
                levelUpEffect = 255;
                playLevelUpSound();
            }

            // More aggressive speed increase: starts at 800ms, decreases by 70ms per level
            // Minimum speed of 50ms at level 11+
            gameSpeed = p.max(50, 800 - (level - 1) * 70);
            playClearSound();
        }
    }

    function removeLines(linesToRemove) {
        // Sort in descending order to remove from bottom to top
        // This prevents index shifting issues
        linesToRemove.sort((a, b) => b - a);

        for (let line of linesToRemove) {
            grid.splice(line, 1);
            grid.unshift(new Array(COLS).fill(0));
        }
    }

    function calculateScore(clearedLines) {
        const basePoints = [40, 100, 300, 1200];
        return basePoints[clearedLines - 1] * level;
    }

    function hardDrop() {
        while (movePiece(0, 1)) {
            score += 2;
        }
    }

    function handleTouchStart(event) {
        if (gameOver) {
            restartGame();
            return;
        }
        
        touchStartX = event.touches[0].clientX;
        touchStartY = event.touches[0].clientY;
        return false;
    }

    function handleTouchEnd(event) {
        if (!touchStartX || !touchStartY) return false;

        let touchEndX = event.changedTouches[0].clientX;
        let touchEndY = event.changedTouches[0].clientY;

        let dx = touchEndX - touchStartX;
        let dy = touchEndY - touchStartY;

        // Tap detection - if movement is small, it's a tap to rotate
        if (p.abs(dx) < 30 && p.abs(dy) < 30) {
            rotatePiece();
            touchStartX = null;
            touchStartY = null;
            return false;
        }

        // Swipe detection
        if (p.abs(dx) > p.abs(dy)) {
            // Horizontal swipe
            if (dx > 0) {
                movePiece(1, 0);
            } else {
                movePiece(-1, 0);
            }
        } else {
            // Vertical swipe - only down for hard drop
            if (dy > 0) {
                hardDrop();
            }
        }

        touchStartX = null;
        touchStartY = null;
        return false;
    }

    p.keyPressed = function() {
        // Show leaderboard on 'L' key
        if (p.key === 'l' || p.key === 'L') {
            showLeaderboard(scoreAPI);
            return;
        }

        if (gameOver) {
            restartGame();
            return;
        }

        if (p.keyCode === p.LEFT_ARROW) {
            movePiece(-1, 0);
        } else if (p.keyCode === p.RIGHT_ARROW) {
            movePiece(1, 0);
        } else if (p.keyCode === p.DOWN_ARROW) {
            hardDrop();
        } else if (p.keyCode === p.UP_ARROW) {
            rotatePiece();
        }
    };

    p.mousePressed = function() {
        if (gameOver) {
            restartGame();
        }
    };

    function restartGame() {
        grid = [];
        for (let i = 0; i < ROWS; i++) {
            grid[i] = new Array(COLS).fill(0);
        }
        score = 0;
        lines = 0;
        level = 1;
        gameSpeed = 800;
        gameOver = false;
        currentPiece = createPiece();
        nextPiece = createPiece();
        clearAnimationLines = [];
        clearAnimationProgress = 0;
        particles = [];
        dropParticles = [];
        levelUpEffect = 0;
        comboCount = 0;
        lastClearTime = 0;
        scoreSubmitted = false;

        // Hide leaderboard button
        document.getElementById('leaderboardBtn').style.display = 'none';
    }

    p.windowResized = function() {
        cellSize = p.min(p.floor(p.windowHeight / 24), p.floor(p.windowWidth / 20));
        p.resizeCanvas(cellSize * 20, cellSize * 24);
        startX = cellSize * 2;
        startY = cellSize * 2;
    };

    // ============================================================================
    // High Score API Functions
    // ============================================================================

    /**
     * Submit high score to the API
     */
    async function submitTetrisScore() {
        if (score > 0 && !scoreSubmitted) {
            scoreSubmitted = true;
            await submitHighScore(scoreAPI, score);
        }
    }
});
</script>
</body>
</html>