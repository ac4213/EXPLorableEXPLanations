<!DOCTYPE html>
<html>
<head>
    <title>Tetris</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a1a;
            touch-action: none;
            overflow: hidden;
        }
    </style>
</head>
<body>
<script>
let grid = [];
let currentPiece;
let nextPiece;
let score = 0;
let lines = 0;
let level = 1;
let gameOver = false;
let cellSize;
let startX;
let startY;
let touchStartX;
let touchStartY;
let gameSpeed;
let lastMove = 0;
let lastRotate = 0;
let clearAnimationLines = [];
let clearAnimationProgress = 0;

const COLS = 10;
const ROWS = 20;
const COLORS = [
    '#FF0000', // Red
    '#00FF00', // Green
    '#0000FF', // Blue
    '#FFFF00', // Yellow
    '#FF00FF', // Magenta
    '#00FFFF', // Cyan
    '#FFA500'  // Orange
];

const PIECES = [
    [[1, 1, 1, 1]], // I
    [[1, 1], [1, 1]], // O
    [[0, 1, 0], [1, 1, 1]], // T
    [[1, 0], [1, 0], [1, 1]], // L
    [[0, 1], [0, 1], [1, 1]], // J
    [[1, 1, 0], [0, 1, 1]], // S
    [[0, 1, 1], [1, 1, 0]]  // Z
];

function setup() {
    // Calculate cell size based on screen size
    cellSize = min(floor(windowHeight / 24), floor(windowWidth / 20));
    
    // Create canvas with extra width for UI elements
    let cnv = createCanvas(cellSize * 20, cellSize * 24);
    
    // Position game area on the left side with margin
    startX = cellSize * 2;
    startY = cellSize * 2;
    
    // Initialize grid
    for (let i = 0; i < ROWS; i++) {
        grid[i] = new Array(COLS).fill(0);
    }
    
    // Create first piece and next piece
    currentPiece = createPiece();
    nextPiece = createPiece();
    
    // Set initial game speed
    gameSpeed = 800;
    
    // Touch event listeners
    cnv.touchStarted(handleTouchStart);
    cnv.touchEnded(handleTouchEnd);
}

function createPiece() {
    let piece = {
        shape: random(PIECES),
        color: random(COLORS),
        x: floor(COLS / 2) - floor(PIECES[0].length / 2),
        y: 0,
        rotation: 0
    };
    return piece;
}

function draw() {
    background('#1a1a1a');
    
    if (!gameOver) {
        // Move piece down automatically
        if (millis() - lastMove > gameSpeed) {
            movePiece(0, 1);
            lastMove = millis();
        }
        
        // Draw game area border
        stroke('#ffffff');
        noFill();
        rect(startX - 1, startY - 1, COLS * cellSize + 2, ROWS * cellSize + 2);
        
        // Draw grid
        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                if (grid[y][x]) {
                    fill(grid[y][x]);
                    rect(startX + x * cellSize, startY + y * cellSize, cellSize, cellSize);
                }
            }
        }
        
        // Draw current piece
        drawPiece(currentPiece);
        
        // Draw UI panel on the right side
        drawUIPanel();
        
        // Handle line clear animation
        if (clearAnimationLines.length > 0) {
            drawClearAnimation();
        }
    } else {
        // Game Over screen
        background(0, 0, 0, 200);
        fill('#ffffff');
        textSize(cellSize * 2);
        textAlign(CENTER, CENTER);
        text('GAME OVER', width / 2, height / 2 - cellSize);
        textSize(cellSize);
        text(`Final Score: ${score}`, width / 2, height / 2 + cellSize);
        text('Tap/Click to restart', width / 2, height / 2 + cellSize * 3);
    }
}

function drawUIPanel() {
    // Calculate UI panel position (right of game area)
    let uiX = startX + (COLS * cellSize) + cellSize * 2;
    
    // Draw score, lines, and level
    fill('#ffffff');
    textSize(cellSize);
    textAlign(LEFT);
    text(`Score: ${score}`, uiX, startY + cellSize);
    text(`Lines: ${lines}`, uiX, startY + cellSize * 2.5);
    text(`Level: ${level}`, uiX, startY + cellSize * 4);
    
    // Draw next piece preview box
    stroke('#ffffff');
    noFill();
    rect(uiX, startY + cellSize * 5, cellSize * 4, cellSize * 4);
    
    // Draw next piece centered in preview box
    let previewX = uiX + cellSize * 2 - (nextPiece.shape[0].length * cellSize) / 2;
    let previewY = startY + cellSize * 7 - (nextPiece.shape.length * cellSize) / 2;
    
    fill(nextPiece.color);
    for (let y = 0; y < nextPiece.shape.length; y++) {
        for (let x = 0; x < nextPiece.shape[y].length; x++) {
            if (nextPiece.shape[y][x]) {
                rect(
                    previewX + x * cellSize,
                    previewY + y * cellSize,
                    cellSize,
                    cellSize
                );
            }
        }
    }
}

function drawPiece(piece) {
    fill(piece.color);
    for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
            if (piece.shape[y][x]) {
                rect(
                    startX + (piece.x + x) * cellSize,
                    startY + (piece.y + y) * cellSize,
                    cellSize,
                    cellSize
                );
            }
        }
    }
}

function drawClearAnimation() {
    clearAnimationProgress += 15;
    
    for (let line of clearAnimationLines) {
        fill(255, 255, 255, clearAnimationProgress);
        rect(startX, startY + line * cellSize, COLS * cellSize, cellSize);
    }
    
    if (clearAnimationProgress >= 255) {
        removeLines(clearAnimationLines);
        clearAnimationLines = [];
        clearAnimationProgress = 0;
    }
}

function movePiece(dx, dy) {
    currentPiece.x += dx;
    currentPiece.y += dy;
    
    if (collision()) {
        currentPiece.x -= dx;
        currentPiece.y -= dy;
        
        if (dy > 0) {
            mergePiece();
            checkLines();
            currentPiece = nextPiece;
            nextPiece = createPiece();
            
            if (collision()) {
                gameOver = true;
            }
        }
        return false;
    }
    return true;
}

function rotatePiece() {
    let rotated = [];
    for (let x = 0; x < currentPiece.shape[0].length; x++) {
        rotated[x] = [];
        for (let y = 0; y < currentPiece.shape.length; y++) {
            rotated[x][currentPiece.shape.length - 1 - y] = currentPiece.shape[y][x];
        }
    }
    
    let oldShape = currentPiece.shape;
    currentPiece.shape = rotated;
    
    if (collision()) {
        currentPiece.shape = oldShape;
        return false;
    }
    return true;
}

function collision() {
    for (let y = 0; y < currentPiece.shape.length; y++) {
        for (let x = 0; x < currentPiece.shape[y].length; x++) {
            if (currentPiece.shape[y][x]) {
                let newX = currentPiece.x + x;
                let newY = currentPiece.y + y;
                
                if (newX < 0 || newX >= COLS || newY >= ROWS) return true;
                if (newY >= 0 && grid[newY][newX]) return true;
            }
        }
    }
    return false;
}

function mergePiece() {
    for (let y = 0; y < currentPiece.shape.length; y++) {
        for (let x = 0; x < currentPiece.shape[y].length; x++) {
            if (currentPiece.shape[y][x]) {
                let newY = currentPiece.y + y;
                if (newY >= 0) {
                    grid[newY][currentPiece.x + x] = currentPiece.color;
                }
            }
        }
    }
}

function checkLines() {
    let linesToClear = [];
    
    for (let y = ROWS - 1; y >= 0; y--) {
        let complete = true;
        for (let x = 0; x < COLS; x++) {
            if (!grid[y][x]) {
                complete = false;
                break;
            }
        }
        if (complete) {
            linesToClear.push(y);
        }
    }
    
    if (linesToClear.length > 0) {
        clearAnimationLines = linesToClear;
        lines += linesToClear.length;
        score += calculateScore(linesToClear.length);
        level = floor(lines / 10) + 1;
        gameSpeed = max(100, 800 - (level - 1) * 50);
    }
}

function removeLines(linesToRemove) {
    for (let line of linesToRemove) {
        grid.splice(line, 1);
        grid.unshift(new Array(COLS).fill(0));
    }
}

function calculateScore(clearedLines) {
    const basePoints = [40, 100, 300, 1200];
    return basePoints[clearedLines - 1] * level;
}

function hardDrop() {
    while (movePiece(0, 1)) {
        score += 2;
    }
}

function handleTouchStart(event) {
    if (gameOver) {
        restartGame();
        return;
    }
    
    touchStartX = event.touches[0].clientX;
    touchStartY = event.touches[0].clientY;
}

function handleTouchEnd(event) {
    if (!touchStartX || !touchStartY) return;
    
    let touchEndX = event.changedTouches[0].clientX;
    let touchEndY = event.changedTouches[0].clientY;
    
    let dx = touchEndX - touchStartX;
    let dy = touchEndY - touchStartY;
    
    // Minimum swipe distance
    if (abs(dx) < 30 && abs(dy) < 30) return;
    
    if (abs(dx) > abs(dy)) {
        // Horizontal swipe
        if (dx > 0) {
            movePiece(1, 0);
        } else {
            movePiece(-1, 0);
        }
    } else {
        // Vertical swipe
        if (dy > 0) {
            hardDrop();
        } else {
            rotatePiece();
        }
    }
    
    touchStartX = null;
    touchStartY = null;
}

function keyPressed() {
    if (gameOver) {
        restartGame();
        return;
    }
    
    if (keyCode === LEFT_ARROW) {
        movePiece(-1, 0);
    } else if (keyCode === RIGHT_ARROW) {
        movePiece(1, 0);
    } else if (keyCode === DOWN_ARROW) {
        hardDrop();
    } else if (keyCode === UP_ARROW) {
        rotatePiece();
    }
}

function mousePressed() {
    if (gameOver) {
        restartGame();
    }
}

function restartGame() {
    grid = [];
    for (let i = 0; i < ROWS; i++) {
        grid[i] = new Array(COLS).fill(0);
    }
    score = 0;
    lines = 0;
    level = 1;
    gameSpeed = 800;
    gameOver = false;
    currentPiece = createPiece();
    nextPiece = createPiece();
    clearAnimationLines = [];
    clearAnimationProgress = 0;
}

function windowResized() {
    cellSize = min(floor(windowHeight / 24), floor(windowWidth / 20));
    resizeCanvas(cellSize * 20, cellSize * 24);
    startX = cellSize * 2;
    startY = cellSize * 2;
}
</script>
</body>
</html>
