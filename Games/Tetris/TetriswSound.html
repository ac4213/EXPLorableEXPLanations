<!DOCTYPE html>
<html>
<head>
    <title>Tetris</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #1a1a1a;
            touch-action: none;
        }
        #soundToggle {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            padding: 10px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 20px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <button id="soundToggle">ðŸ”Š</button>
<script>
// Sound system
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();
let isSoundEnabled = true;

// Sound functions
function playTone(frequency, duration, type = 'square') {
    if (!isSoundEnabled) return;
    
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    
    oscillator.type = type;
    oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
    
    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
    
    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    
    oscillator.start();
    oscillator.stop(audioCtx.currentTime + duration);
}

function playMoveSound() {
    playTone(440, 0.1);
}

function playRotateSound() {
    playTone(580, 0.1);
}

function playDropSound() {
    playTone(220, 0.2);
}

function playClearSound() {
    playTone(440, 0.1, 'sine');
    setTimeout(() => playTone(550, 0.1, 'sine'), 50);
    setTimeout(() => playTone(660, 0.1, 'sine'), 100);
}

function playGameOverSound() {
    playTone(440, 0.2, 'sine');
    setTimeout(() => playTone(330, 0.2, 'sine'), 200);
    setTimeout(() => playTone(220, 0.3, 'sine'), 400);
}

// Sound toggle
document.getElementById('soundToggle').addEventListener('click', () => {
    isSoundEnabled = !isSoundEnabled;
    document.getElementById('soundToggle').textContent = isSoundEnabled ? 'ðŸ”Š' : 'ðŸ”ˆ';
});

new p5(function(p) {
    let grid = [];
    let currentPiece;
    let nextPiece;
    let score = 0;
    let lines = 0;
    let level = 1;
    let gameOver = false;
    let cellSize;
    let startX;
    let startY;
    let touchStartX;
    let touchStartY;
    let gameSpeed;
    let lastMove = 0;
    let clearAnimationLines = [];
    let clearAnimationProgress = 0;

    const COLS = 10;
    const ROWS = 20;
    const COLORS = [
        '#FF0000', '#00FF00', '#0000FF', '#FFFF00', 
        '#FF00FF', '#00FFFF', '#FFA500'
    ];

    const PIECES = [
        [[1, 1, 1, 1]], // I
        [[1, 1], [1, 1]], // O
        [[0, 1, 0], [1, 1, 1]], // T
        [[1, 0], [1, 0], [1, 1]], // L
        [[0, 1], [0, 1], [1, 1]], // J
        [[1, 1, 0], [0, 1, 1]], // S
        [[0, 1, 1], [1, 1, 0]]  // Z
    ];

    p.setup = function() {
        cellSize = p.min(p.floor(p.windowHeight / 24), p.floor(p.windowWidth / 20));
        let cnv = p.createCanvas(cellSize * 20, cellSize * 24);
        
        startX = cellSize * 2;
        startY = cellSize * 2;
        
        for (let i = 0; i < ROWS; i++) {
            grid[i] = new Array(COLS).fill(0);
        }
        
        currentPiece = createPiece();
        nextPiece = createPiece();
        gameSpeed = 800;
        
        cnv.touchStarted(handleTouchStart);
        cnv.touchEnded(handleTouchEnd);
    };

    function createPiece() {
        return {
            shape: PIECES[p.floor(p.random(PIECES.length))],
            color: COLORS[p.floor(p.random(COLORS.length))],
            x: p.floor(COLS / 2) - 1,
            y: 0
        };
    }

    p.draw = function() {
        p.background('#1a1a1a');
        
        if (!gameOver) {
            if (p.millis() - lastMove > gameSpeed) {
                movePiece(0, 1);
                lastMove = p.millis();
            }
            
            // Draw game area border
            p.stroke('#ffffff');
            p.noFill();
            p.rect(startX - 1, startY - 1, COLS * cellSize + 2, ROWS * cellSize + 2);
            
            // Draw grid
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (grid[y][x]) {
                        p.fill(grid[y][x]);
                        p.rect(startX + x * cellSize, startY + y * cellSize, cellSize, cellSize);
                    }
                }
            }
            
            drawPiece(currentPiece);
            drawUI();
            
            if (clearAnimationLines.length > 0) {
                drawClearAnimation();
            }
        } else {
            drawGameOver();
        }
    };

    function drawUI() {
        let uiX = startX + (COLS * cellSize) + cellSize * 2;
        
        p.fill('#ffffff');
        p.textSize(cellSize);
        p.textAlign(p.LEFT);
        p.text(`Score: ${score}`, uiX, startY + cellSize);
        p.text(`Lines: ${lines}`, uiX, startY + cellSize * 2.5);
        p.text(`Level: ${level}`, uiX, startY + cellSize * 4);
        
        p.stroke('#ffffff');
        p.noFill();
        p.rect(uiX, startY + cellSize * 5, cellSize * 4, cellSize * 4);
        
        let previewX = uiX + cellSize * 2 - (nextPiece.shape[0].length * cellSize) / 2;
        let previewY = startY + cellSize * 7 - (nextPiece.shape.length * cellSize) / 2;
        
        drawPieceAt(nextPiece, previewX, previewY);
    }

    function drawPiece(piece) {
        drawPieceAt(piece, startX + piece.x * cellSize, startY + piece.y * cellSize);
    }

    function drawPieceAt(piece, x, y) {
        p.fill(piece.color);
        for (let row = 0; row < piece.shape.length; row++) {
            for (let col = 0; col < piece.shape[row].length; col++) {
                if (piece.shape[row][col]) {
                    p.rect(x + col * cellSize, y + row * cellSize, cellSize, cellSize);
                }
            }
        }
    }

    function drawGameOver() {
        p.background(0, 0, 0, 200);
        p.fill('#ffffff');
        p.textSize(cellSize * 2);
        p.textAlign(p.CENTER, p.CENTER);
        p.text('GAME OVER', p.width / 2, p.height / 2 - cellSize);
        p.textSize(cellSize);
        p.text(`Final Score: ${score}`, p.width / 2, p.height / 2 + cellSize);
        p.text('Click to restart', p.width / 2, p.height / 2 + cellSize * 3);
    }

    function drawClearAnimation() {
        clearAnimationProgress += 15;
        
        for (let line of clearAnimationLines) {
            p.fill(255, 255, 255, clearAnimationProgress);
            p.rect(startX, startY + line * cellSize, COLS * cellSize, cellSize);
        }
        
        if (clearAnimationProgress >= 255) {
            removeLines(clearAnimationLines);
            clearAnimationLines = [];
            clearAnimationProgress = 0;
        }
    }

    function movePiece(dx, dy) {
        currentPiece.x += dx;
        currentPiece.y += dy;
        
        if (collision()) {
            currentPiece.x -= dx;
            currentPiece.y -= dy;
            
            if (dy > 0) {
                mergePiece();
                playDropSound();
                checkLines();
                currentPiece = nextPiece;
                nextPiece = createPiece();
                
                if (collision()) {
                    gameOver = true;
                    playGameOverSound();
                }
            }
            return false;
        }
        
        if (dx !== 0) playMoveSound();
        return true;
    }

    function rotatePiece() {
        let rotated = [];
        for (let x = 0; x < currentPiece.shape[0].length; x++) {
            rotated[x] = [];
            for (let y = 0; y < currentPiece.shape.length; y++) {
                rotated[x][currentPiece.shape.length - 1 - y] = currentPiece.shape[y][x];
            }
        }
        
        let oldShape = currentPiece.shape;
        currentPiece.shape = rotated;
        
        if (collision()) {
            currentPiece.shape = oldShape;
            return false;
        }
        
        playRotateSound();
        return true;
    }

    function collision() {
        for (let y = 0; y < currentPiece.shape.length; y++) {
            for (let x = 0; x < currentPiece.shape[y].length; x++) {
                if (currentPiece.shape[y][x]) {
                    let newX = currentPiece.x + x;
                    let newY = currentPiece.y + y;
                    
                    if (newX < 0 || newX >= COLS || newY >= ROWS) return true;
                    if (newY >= 0 && grid[newY][newX]) return true;
                }
            }
        }
        return false;
    }

    function mergePiece() {
        for (let y = 0; y < currentPiece.shape.length; y++) {
            for (let x = 0; x < currentPiece.shape[y].length; x++) {
                if (currentPiece.shape[y][x]) {
                    let newY = currentPiece.y + y;
                    if (newY >= 0) {
                        grid[newY][currentPiece.x + x] = currentPiece.color;
                    }
                }
            }
        }
    }

    function checkLines() {
        let linesToClear = [];
        
        for (let y = ROWS - 1; y >= 0; y--) {
            let complete = true;
            for (let x = 0; x < COLS; x++) {
                if (!grid[y][x]) {
                    complete = false;
                    break;
                }
            }
            if (complete) {
                linesToClear.push(y);
            }
        }
        
        if (linesToClear.length > 0) {
            clearAnimationLines = linesToClear;
            lines += linesToClear.length;
            score += calculateScore(linesToClear.length);
            level = p.floor(lines / 10) + 1;
            gameSpeed = p.max(100, 800 - (level - 1) * 50);
            playClearSound();
        }
    }

    function removeLines(linesToRemove) {
        for (let line of linesToRemove) {
            grid.splice(line, 1);
            grid.unshift(new Array(COLS).fill(0));
        }
    }

    function calculateScore(clearedLines) {
        const basePoints = [40, 100, 300, 1200];
        return basePoints[clearedLines - 1] * level;
    }

    function hardDrop() {
        while (movePiece(0, 1)) {
            score += 2;
        }
    }

    function handleTouchStart(event) {
        if (gameOver) {
            restartGame();
            return;
        }
        
        touchStartX = event.touches[0].clientX;
        touchStartY = event.touches[0].clientY;
        return false;
    }

    function handleTouchEnd(event) {
        if (!touchStartX || !touchStartY) return false;
        
        let touchEndX = event.changedTouches[0].clientX;
        let touchEndY = event.changedTouches[0].clientY;
        
        let dx = touchEndX - touchStartX;
        let dy = touchEndY - touchStartY;
        
        if (p.abs(dx) < 30 && p.abs(dy) < 30) return false;
        
        if (p.abs(dx) > p.abs(dy)) {
            if (dx > 0) {
                movePiece(1, 0);
            } else {
                movePiece(-1, 0);
            }
        } else {
            if (dy > 0) {
                hardDrop();
            } else {
                rotatePiece();
            }
        }
        
        touchStartX = null;
        touchStartY = null;
        return false;
    }

    p.keyPressed = function() {
        if (gameOver) {
            restartGame();
            return;
        }
        
        if (p.keyCode === p.LEFT_ARROW) {
            movePiece(-1, 0);
        } else if (p.keyCode === p.RIGHT_ARROW) {
            movePiece(1, 0);
        } else if (p.keyCode === p.DOWN_ARROW) {
            hardDrop();
        } else if (p.keyCode === p.UP_ARROW) {
            rotatePiece();
        }
    };

    p.mousePressed = function() {
        if (gameOver) {
            restartGame();
        }
    };

    function restartGame() {
        grid = [];
        for (let i = 0; i < ROWS; i++) {
            grid[i] = new Array(COLS).fill(0);
        }
        score = 0;
        lines = 0;
        level = 1;
        gameSpeed = 800;
        gameOver = false;
        currentPiece = createPiece();
        nextPiece = createPiece();
        clearAnimationLines = [];
        clearAnimationProgress = 0;
    }

    p.windowResized = function() {
        cellSize = p.min(p.floor(p.windowHeight / 24), p.floor(p.windowWidth / 20));
        p.resizeCanvas(cellSize * 20, cellSize * 24);
        startX = cellSize * 2;
        startY = cellSize * 2;
    };
});
</script>
</body>
</html>