<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Truss Analysis - Interactive Lecture</title>

    <!-- External CSS -->
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="/assets/css/problems.css">
    <link rel="stylesheet" href="/assets/css/quizzes.css">
    <link rel="stylesheet" href="/assets/css/simulations.css">
    <link rel="stylesheet" href="/assets/css/uicontrols.css">

    <!-- MathJax for LaTeX equations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>

    <!-- p5.js for interactive simulations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
</head>

<body>
    <header>
        <h1>Truss Analysis</h1>
        <p class="subtitle">Interactive Lecture & Simulation</p>
    </header>

    <!-- Section 1: Teaching Content -->
    <div class="content-section">
        <h2>Understanding Truss Structures</h2>
        <p>A truss is a structural framework composed of straight members connected at joints (nodes), designed to support loads. Trusses are commonly used in bridges, roofs, and towers because they efficiently transfer loads through axial forces in the members.</p>

        <div class="key-point">
            <p><strong>Core Insight:</strong> In an ideal truss, all members are two-force members experiencing only tension or compression, with no bending moments. This simplification makes structural analysis straightforward and efficient.</p>
        </div>

        <h3>Truss Assumptions</h3>
        <p>For classical truss analysis, we make the following assumptions:</p>
        <ul>
            <li>All members are connected by frictionless pins (no moment transfer at joints)</li>
            <li>All loads are applied at the joints only</li>
            <li>All members are straight and axially loaded (two-force members)</li>
            <li>The weight of members is neglected or applied at joints</li>
        </ul>

        <h3>Method of Joints</h3>
        <p>The Method of Joints is a technique for analyzing trusses by considering the equilibrium of forces at each joint. Since each joint is in equilibrium, the sum of forces in any direction must be zero.</p>

        <div class="equation-box">
            <p><strong>Equilibrium Equations at Each Joint:</strong></p>
            <p>\[\sum F_x = 0\]</p>
            <p>\[\sum F_y = 0\]</p>
            <p>Where:</p>
            <ul>
                <li>\(\sum F_x\) = Sum of horizontal forces (N)</li>
                <li>\(\sum F_y\) = Sum of vertical forces (N)</li>
            </ul>
        </div>

        <h3>Method of Sections</h3>
        <p>The Method of Sections allows us to find forces in specific members without analyzing the entire truss. We make an imaginary cut through the truss, dividing it into two sections, and apply equilibrium equations to one section.</p>

        <div class="equation-box">
            <p><strong>Equilibrium Equations for a Section:</strong></p>
            <p>\[\sum F_x = 0\]</p>
            <p>\[\sum F_y = 0\]</p>
            <p>\[\sum M = 0\]</p>
            <p>Where:</p>
            <ul>
                <li>\(\sum M\) = Sum of moments about any point (N·m)</li>
            </ul>
        </div>

        <h3>Sign Convention</h3>
        <p>In truss analysis, we use the following sign convention:</p>
        <ul>
            <li><strong>Tension (+):</strong> Member is being pulled (elongated)</li>
            <li><strong>Compression (-):</strong> Member is being pushed (shortened)</li>
        </ul>

        <div class="key-point">
            <p><strong>Problem-Solving Strategy:</strong></p>
            <ol>
                <li>Calculate support reactions using global equilibrium</li>
                <li>Identify zero-force members (simplifies analysis)</li>
                <li>Start at a joint with only two unknown forces</li>
                <li>Solve joint equilibrium equations systematically</li>
                <li>Check results by analyzing another joint</li>
            </ol>
        </div>
    </div>

    <!-- Section 2: Interactive Simulation -->
    <div class="simulation-container">
        <h2>Interactive Warren Truss Simulation</h2>
        <p><strong>Click on any node</strong> to view its free body diagram and edit applied forces and constraints. Members in <span style="color: red; font-weight: bold;">red</span> are in tension, <span style="color: blue; font-weight: bold;">blue</span> are in compression. The thickness represents force magnitude.</p>

        <!-- Canvas Holder -->
        <div id="sketch-holder"></div>

        <!-- Node Editor Panel -->
        <div id="node-editor" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border: 3px solid #333; border-radius: 10px; padding: 20px; z-index: 1000; box-shadow: 0 4px 20px rgba(0,0,0,0.3); width: 600px; max-height: 80vh; overflow-y: auto;">
            <h3 style="margin-top: 0;">Node <span id="selected-node-id"></span> - Free Body Diagram</h3>

            <!-- Free Body Diagram Canvas -->
            <div id="fbd-holder" style="border: 2px solid #ddd; margin: 10px 0; background: #f9f9f9;"></div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">
                <div>
                    <label style="font-weight: bold; display: block; margin-bottom: 5px;">Applied Force X (kN):</label>
                    <input type="number" id="force-x" step="0.1" style="width: 100%; padding: 5px; font-size: 14px;">
                </div>
                <div>
                    <label style="font-weight: bold; display: block; margin-bottom: 5px;">Applied Force Y (kN):</label>
                    <input type="number" id="force-y" step="0.1" style="width: 100%; padding: 5px; font-size: 14px;">
                </div>
                <div style="grid-column: span 2;">
                    <label style="font-weight: bold; display: block; margin-bottom: 5px;">Constraint Type:</label>
                    <select id="constraint-type" style="width: 100%; padding: 5px; font-size: 14px;">
                        <option value="none">None (Free)</option>
                        <option value="pin">Pin (Fixed X & Y)</option>
                        <option value="roller-x">Horizontal Roller (Fixed Y only)</option>
                        <option value="roller-y">Vertical Roller (Fixed X only)</option>
                    </select>
                    <p style="font-size: 12px; color: #666; margin-top: 5px;">
                        <strong>Pin:</strong> Prevents movement in X and Y directions<br>
                        <strong>Horizontal Roller:</strong> Prevents vertical movement (Y) only<br>
                        <strong>Vertical Roller:</strong> Prevents horizontal movement (X) only
                    </p>
                </div>
            </div>

            <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: flex-end;">
                <button id="apply-node-changes" style="background: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 14px;">Apply Changes</button>
                <button id="close-node-editor" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 14px;">Close</button>
            </div>
        </div>

        <!-- Controls for deflection -->
        <div style="max-width: 400px; margin: 20px auto; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
            <label style="font-weight: bold; display: block; margin-bottom: 8px;">Deflection Scale:</label>
            <input type="range" id="deflection-scale" min="0" max="100" value="0" step="1" style="width: 100%;">
            <div style="text-align: center; margin-top: 5px; color: #666;">
                <span id="deflection-value">0</span>x (0 = no deflection)
            </div>
        </div>

        <!-- Legend -->
        <div class="diagram-legend">
            <div class="legend-item">
                <div class="legend-color" style="background-color: red;"></div>
                <span>Tension</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: blue;"></div>
                <span>Compression</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: black;"></div>
                <span>Zero Force</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background-color: #28a745;"></div>
                <span>Selected Node</span>
            </div>
        </div>
    </div>

    <!-- Section 3: Engineering Applications -->
    <div class="content-section">
        <h2>Engineering Applications</h2>
        <ul>
            <li><strong>Bridge Design:</strong> Truss bridges are among the strongest bridge types relative to their weight, using triangulated structures to span long distances efficiently. Examples include the Warren truss and Pratt truss configurations.</li>
            <li><strong>Roof Structures:</strong> Trusses support roofs in buildings, warehouses, and gymnasiums, allowing for large open spaces without interior columns. The triangular configuration distributes loads efficiently to exterior walls.</li>
            <li><strong>Transmission Towers:</strong> Electrical transmission towers use truss configurations to achieve great heights while minimizing material usage and wind resistance.</li>
            <li><strong>Crane Booms:</strong> Tower cranes and mobile cranes use truss structures for their booms, providing high strength-to-weight ratios essential for lifting heavy loads.</li>
            <li><strong>Space Frames:</strong> Three-dimensional truss structures are used in large-span roofs for stadiums, exhibition halls, and airports, creating column-free spaces while distributing loads efficiently.</li>
        </ul>
    </div>

    <!-- Section 4: Summary of Key Equations -->
    <div class="content-section">
        <h2>Summary of Key Equations</h2>
        <div class="equation-table">
            <table>
                <thead>
                    <tr>
                        <th>Concept</th>
                        <th>Equation</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Joint Equilibrium (X)</td>
                        <td>\(\sum F_x = 0\)</td>
                        <td>Sum of horizontal forces at a joint</td>
                    </tr>
                    <tr>
                        <td>Joint Equilibrium (Y)</td>
                        <td>\(\sum F_y = 0\)</td>
                        <td>Sum of vertical forces at a joint</td>
                    </tr>
                    <tr>
                        <td>Force Resolution</td>
                        <td>\(F_x = F \cos\theta\), \(F_y = F \sin\theta\)</td>
                        <td>Resolve member force into components</td>
                    </tr>
                    <tr>
                        <td>Section Equilibrium</td>
                        <td>\(\sum M = 0\)</td>
                        <td>Sum of moments about any point</td>
                    </tr>
                    <tr>
                        <td>Member Count Check</td>
                        <td>\(m = 2j - 3\)</td>
                        <td>For a stable, determinate truss (m=members, j=joints)</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <!-- Section 5: Practice Problems -->
    <div class="content-section">
        <h2>Practice Problems</h2>

        <div class="practice-problems">
            <h3>Problem 1: Simple Warren Truss</h3>
            <p>A Warren truss has a span of 6 m and height of 2 m. A downward load of 10 kN is applied at the center top joint. The truss is supported by a pin at the left end and a roller at the right end. Find the force in the top horizontal member.</p>

            <p class="toggle-section" onclick="toggleSolution('solution1')">Show Solution</p>
            <div id="solution1" class="hidden">
                <p><strong>Solution:</strong></p>
                <p><strong>Step 1: Calculate Support Reactions</strong></p>
                <p>By symmetry, each support carries 5 kN vertically.</p>
                <p>\[R_A = R_B = \frac{10}{2} = 5 \text{ kN}\]</p>

                <p><strong>Step 2: Analyze the Center Top Joint</strong></p>
                <p>At the center joint, the applied load is 10 kN downward. Two diagonal members connect to the supports, and one horizontal member on each side.</p>
                <p>The angle of the diagonal members: \(\theta = \arctan(2/3) = 33.69°\)</p>

                <p><strong>Step 3: Vertical Equilibrium</strong></p>
                <p>Two diagonal members carry the load symmetrically:</p>
                <p>\[2F_{\text{diagonal}} \sin\theta = 10\]</p>
                <p>\[F_{\text{diagonal}} = \frac{10}{2 \times \sin(33.69°)} = \frac{10}{1.11} = 9.01 \text{ kN (Compression)}\]</p>

                <p><strong>Step 4: Horizontal Equilibrium</strong></p>
                <p>The horizontal member must balance the horizontal components:</p>
                <p>\[F_{\text{horizontal}} = 2F_{\text{diagonal}} \cos\theta = 2 \times 9.01 \times \cos(33.69°) = 15.0 \text{ kN (Tension)}\]</p>

                <p><strong>Answer:</strong> The top horizontal member carries 15.0 kN in tension.</p>
            </div>
        </div>

        <div class="practice-problems">
            <h3>Problem 2: Method of Sections</h3>
            <p>For a Pratt truss with 8 m span and 2 m height, a 12 kN load is applied at the top left quarter point. Using the method of sections, find the force in the center vertical member.</p>

            <p class="toggle-section" onclick="toggleSolution('solution2')">Show Solution</p>
            <div id="solution2" class="hidden">
                <p><strong>Solution:</strong></p>
                <p><strong>Step 1: Calculate Support Reactions</strong></p>
                <p>Taking moments about the right support:</p>
                <p>\[R_A \times 8 = 12 \times 6\]</p>
                <p>\[R_A = 9 \text{ kN}\]</p>
                <p>\[R_B = 12 - 9 = 3 \text{ kN}\]</p>

                <p><strong>Step 2: Make a Section Cut</strong></p>
                <p>Cut through the center vertical member and the two diagonal members adjacent to it.</p>

                <p><strong>Step 3: Take Moments About Intersection Point</strong></p>
                <p>Choose the point where the two diagonals intersect (eliminates two unknowns).</p>
                <p>Taking moments about this point and considering the left section:</p>
                <p>\[R_A \times 4 - 12 \times 2 - F_{\text{vertical}} \times 0 = 0\]</p>
                <p>Wait, we need to choose a better moment point.</p>

                <p>Taking moments about the top left joint of the section:</p>
                <p>\[R_A \times 4 - F_{\text{vertical}} \times 4 = 0\]</p>
                <p>\[F_{\text{vertical}} = R_A = 9 \text{ kN (Tension)}\]</p>

                <p><strong>Answer:</strong> The center vertical member carries 9 kN in tension.</p>
            </div>
        </div>

        <div class="practice-problems">
            <h3>Problem 3: Zero-Force Members</h3>
            <p>Identify the zero-force members in a truss where a joint has three members: two are collinear (in a straight line), and the third is at an angle. No external loads are applied at this joint.</p>

            <p class="toggle-section" onclick="toggleSolution('solution3')">Show Solution</p>
            <div id="solution3" class="hidden">
                <p><strong>Solution:</strong></p>
                <p><strong>Zero-Force Member Rules:</strong></p>
                <ul>
                    <li>If two members form a truss joint and no external force is applied, both members are zero-force members.</li>
                    <li>If three members form a truss joint and two are collinear, the third member is a zero-force member (if no external force is applied).</li>
                </ul>

                <p><strong>Analysis:</strong></p>
                <p>At the described joint, two members are collinear. For equilibrium in the direction perpendicular to these collinear members, the force in the third member must be zero.</p>

                <p><strong>Mathematical Proof:</strong></p>
                <p>Let the collinear members be along the x-axis. For vertical equilibrium:</p>
                <p>\[\sum F_y = F_3 \sin\theta = 0\]</p>
                <p>Since \(\sin\theta \neq 0\) (the member is at an angle), we must have \(F_3 = 0\).</p>

                <p><strong>Answer:</strong> The non-collinear member is a zero-force member.</p>
            </div>
        </div>
    </div>

    <!-- Section 6: Knowledge Check Quiz -->
    <div class="content-section">
        <h2>Knowledge Check Quiz</h2>
        <div class="quiz-container">
            <div class="quiz-question">
                <h3>Question 1: In truss analysis, what assumption is made about the joints?</h3>
                <div class="quiz-options">
                    <label><input type="radio" name="q1" value="a"> a) Joints are rigid and transfer moments</label>
                    <label><input type="radio" name="q1" value="b"> b) Joints are frictionless pins with no moment transfer</label>
                    <label><input type="radio" name="q1" value="c"> c) Joints are welded connections</label>
                    <label><input type="radio" name="q1" value="d"> d) Joints can rotate freely under any load</label>
                </div>
            </div>

            <div class="quiz-question">
                <h3>Question 2: A truss member in compression is:</h3>
                <div class="quiz-options">
                    <label><input type="radio" name="q2" value="a"> a) Being pulled and elongated</label>
                    <label><input type="radio" name="q2" value="b"> b) Being pushed and shortened</label>
                    <label><input type="radio" name="q2" value="c"> c) Experiencing zero force</label>
                    <label><input type="radio" name="q2" value="d"> d) Bending under load</label>
                </div>
            </div>

            <div class="quiz-question">
                <h3>Question 3: The Method of Joints is most efficient when:</h3>
                <div class="quiz-options">
                    <label><input type="radio" name="q3" value="a"> a) You need forces in all members</label>
                    <label><input type="radio" name="q3" value="b"> b) You need force in only one specific member</label>
                    <label><input type="radio" name="q3" value="c"> c) The truss has many zero-force members</label>
                    <label><input type="radio" name="q3" value="d"> d) Analyzing a three-dimensional truss</label>
                </div>
            </div>

            <div class="quiz-question">
                <h3>Question 4: For a statically determinate plane truss with j joints and m members:</h3>
                <div class="quiz-options">
                    <label><input type="radio" name="q4" value="a"> a) m = j - 3</label>
                    <label><input type="radio" name="q4" value="b"> b) m = 2j - 3</label>
                    <label><input type="radio" name="q4" value="c"> c) m = 2j + 3</label>
                    <label><input type="radio" name="q4" value="d"> d) m = 3j - 2</label>
                </div>
            </div>

            <div class="quiz-question">
                <h3>Question 5: When using the Method of Sections, you can cut through a maximum of:</h3>
                <div class="quiz-options">
                    <label><input type="radio" name="q5" value="a"> a) 2 members</label>
                    <label><input type="radio" name="q5" value="b"> b) 3 members</label>
                    <label><input type="radio" name="q5" value="c"> c) 4 members</label>
                    <label><input type="radio" name="q5" value="d"> d) Any number of members</label>
                </div>
            </div>

            <button id="submit-quiz">Submit Quiz</button>
            <div id="quiz-results"></div>
        </div>
    </div>

    <!-- Footer -->
    <footer>
        <script src="/assets/common/footer.js"></script>
    </footer>

    <!-- Common JavaScript Functions -->
    <script src="/assets/common/problems.js"></script>
    <script src="/assets/common/quizzes.js"></script>

    <!-- Page-specific JavaScript -->
    <script>
        // Global variables for node editor
        let selectedNodeIndex = -1;
        let fbdSketch = null;

        // Main truss simulation using p5.js
        let sketch = new p5(function(p) {
            const numSpans = 5;
            const spanLength = 1.5; // meters
            const trussHeight = 1.5; // meters
            const scale = 60; // pixels per meter

            // Truss data
            let nodes = [];
            let members = [];
            let memberForces = [];
            let isSolved = false;
            let deflectionScale = 0;
            let nodeDeflections = []; // Store calculated deflections
            let systemStatus = 'unknown'; // 'isostatic', 'hyperstatic', 'hypostatic'
            let solverMessage = ''; // Message explaining solver status
            let numEquations = 0;
            let numMembers = 0;

            p.setup = function() {
                let canvasWidth = Math.min(900, p.windowWidth - 40);
                p.createCanvas(canvasWidth, 500);
                initializeTruss();
                setupNodeEditor();
                setupDeflectionSlider();
            };

            p.draw = function() {
                p.background(240);

                // Draw info panel first (in screen coordinates)
                drawInfoPanel();

                p.translate(50, 350);

                // Draw members first (behind nodes)
                drawMembers();

                // Draw supports and nodes
                drawSupports();
                drawNodes();

                // Draw applied forces
                drawAppliedForces();
            };

            p.mousePressed = function() {
                // Check if a node was clicked
                for (let i = 0; i < nodes.length; i++) {
                    let node = nodes[i];
                    let screenX = node.x * scale;
                    let screenY = node.y * scale;
                    let dx = p.mouseX - 50 - screenX;
                    let dy = p.mouseY - 350 - screenY;
                    let dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 15) {
                        openNodeEditor(i);
                        return;
                    }
                }
            };

            function initializeTruss() {
                nodes = [];
                members = [];

                // Create Warren truss nodes
                // Bottom chord nodes
                for (let i = 0; i <= numSpans; i++) {
                    nodes.push({
                        x: i * spanLength,
                        y: 0,
                        fx: 0,
                        fy: 0,
                        constraint: i === 0 ? 'pin' : (i === numSpans ? 'roller-y' : 'none')
                    });
                }

                // Top chord nodes (between bottom nodes)
                for (let i = 0; i < numSpans; i++) {
                    nodes.push({
                        x: (i + 0.5) * spanLength,
                        y: -trussHeight,
                        fx: 0,
                        fy: i === Math.floor(numSpans / 2) ? -10 : 0, // Apply -10 kN (downward, following convention: down = negative)
                        constraint: 'none'
                    });
                }

                // Create members
                // Bottom chord
                for (let i = 0; i < numSpans; i++) {
                    members.push({start: i, end: i + 1});
                }

                // Diagonals and top chord
                for (let i = 0; i < numSpans; i++) {
                    let topNodeIndex = numSpans + 1 + i;
                    // Left diagonal
                    members.push({start: i, end: topNodeIndex});
                    // Right diagonal
                    members.push({start: i + 1, end: topNodeIndex});
                }

                // Top chord
                for (let i = 0; i < numSpans - 1; i++) {
                    let topNodeIndex = numSpans + 1 + i;
                    members.push({start: topNodeIndex, end: topNodeIndex + 1});
                }

                solveTruss();
            }

            function solveTruss(skipUpdateResults = false) {
                // Build global equilibrium matrix using method of joints
                const numNodes = nodes.length;
                numMembers = members.length;

                // Count degrees of freedom
                let dofCount = 0;
                let dofMap = []; // Maps node and direction to equation number

                for (let i = 0; i < numNodes; i++) {
                    let node = nodes[i];
                    if (node.constraint === 'pin') {
                        dofMap.push(-1, -1); // Both constrained
                    } else if (node.constraint === 'roller-x') {
                        dofMap.push(-1, dofCount++); // X constrained, Y free
                    } else if (node.constraint === 'roller-y') {
                        dofMap.push(dofCount++, -1); // X free, Y constrained
                    } else {
                        dofMap.push(dofCount++, dofCount++); // Both free
                    }
                }

                numEquations = dofCount;

                // Determine system status
                if (numEquations === numMembers) {
                    systemStatus = 'isostatic';
                } else if (numEquations < numMembers) {
                    systemStatus = 'hyperstatic';
                } else {
                    systemStatus = 'hypostatic';
                }

                if (numEquations === 0) {
                    memberForces = members.map(() => 0);
                    isSolved = true;
                    solverMessage = 'Fully constrained (no unknowns)';
                    if (!skipUpdateResults) updateResults();
                    return;
                }

                // Build coefficient matrix and force vector
                let A = Array(numEquations).fill(0).map(() => Array(numEquations).fill(0));
                let b = Array(numEquations).fill(0);

                // For each member, add its contribution to the equilibrium equations
                for (let m = 0; m < numMembers; m++) {
                    let member = members[m];
                    let n1 = nodes[member.start];
                    let n2 = nodes[member.end];

                    let dx = n2.x - n1.x;
                    let dy = n2.y - n1.y;
                    let length = Math.sqrt(dx * dx + dy * dy);
                    let cosTheta = dx / length;
                    let sinTheta = dy / length;

                    // Node 1 equilibrium (force from member is in direction n1->n2)
                    let eqX1 = dofMap[member.start * 2];
                    let eqY1 = dofMap[member.start * 2 + 1];
                    if (eqX1 >= 0) A[eqX1][m] = cosTheta;
                    if (eqY1 >= 0) A[eqY1][m] = sinTheta;

                    // Node 2 equilibrium (force from member is in direction n2->n1)
                    let eqX2 = dofMap[member.end * 2];
                    let eqY2 = dofMap[member.end * 2 + 1];
                    if (eqX2 >= 0) A[eqX2][m] = -cosTheta;
                    if (eqY2 >= 0) A[eqY2][m] = -sinTheta;
                }

                // Add applied forces to right-hand side
                for (let i = 0; i < numNodes; i++) {
                    let node = nodes[i];
                    let eqX = dofMap[i * 2];
                    let eqY = dofMap[i * 2 + 1];
                    if (eqX >= 0) b[eqX] = -node.fx;
                    if (eqY >= 0) b[eqY] = -node.fy;
                }

                // Check if system is determined
                if (numEquations !== numMembers) {
                    memberForces = members.map(() => 0);
                    isSolved = false;
                    if (systemStatus === 'hyperstatic') {
                        solverMessage = 'System is indeterminate (too few equations)';
                    } else if (systemStatus === 'hypostatic') {
                        solverMessage = 'System is under-constrained (mechanism)';
                    }
                    if (!skipUpdateResults) updateResults();
                    return;
                }

                // Solve using Gaussian elimination
                try {
                    memberForces = gaussianElimination(A, b);
                    isSolved = true;
                    solverMessage = 'System solved successfully';
                } catch (e) {
                    memberForces = members.map(() => 0);
                    isSolved = false;
                    solverMessage = 'System is unstable (singular matrix)';
                    console.log('Solver error:', e.message);
                }

                if (!skipUpdateResults) updateResults();
            }

            function gaussianElimination(A, b) {
                const n = A.length;
                let augmented = A.map((row, i) => [...row, b[i]]);

                // Forward elimination
                for (let i = 0; i < n; i++) {
                    // Find pivot
                    let maxRow = i;
                    for (let k = i + 1; k < n; k++) {
                        if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
                            maxRow = k;
                        }
                    }

                    // Swap rows
                    [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];

                    // Check for singular matrix
                    if (Math.abs(augmented[i][i]) < 1e-10) {
                        throw new Error('Singular matrix');
                    }

                    // Eliminate column
                    for (let k = i + 1; k < n; k++) {
                        let factor = augmented[k][i] / augmented[i][i];
                        for (let j = i; j <= n; j++) {
                            augmented[k][j] -= factor * augmented[i][j];
                        }
                    }
                }

                // Back substitution
                let x = Array(n).fill(0);
                for (let i = n - 1; i >= 0; i--) {
                    x[i] = augmented[i][n];
                    for (let j = i + 1; j < n; j++) {
                        x[i] -= augmented[i][j] * x[j];
                    }
                    x[i] /= augmented[i][i];
                }

                return x;
            }

            function drawMembers() {
                let maxForce = isSolved ? Math.max(...memberForces.map(f => Math.abs(f)), 1) : 1;

                for (let i = 0; i < members.length; i++) {
                    let member = members[i];
                    let force = isSolved ? memberForces[i] : 0;
                    let n1 = nodes[member.start];
                    let n2 = nodes[member.end];

                    // Apply deflection if enabled
                    let def1 = deflectionScale > 0 && nodeDeflections[member.start] ? nodeDeflections[member.start] : {x: 0, y: 0};
                    let def2 = deflectionScale > 0 && nodeDeflections[member.end] ? nodeDeflections[member.end] : {x: 0, y: 0};

                    let x1 = (n1.x + def1.x * deflectionScale * 0.01) * scale;
                    let y1 = (n1.y + def1.y * deflectionScale * 0.01) * scale;
                    let x2 = (n2.x + def2.x * deflectionScale * 0.01) * scale;
                    let y2 = (n2.y + def2.y * deflectionScale * 0.01) * scale;

                    // Color and thickness based on force
                    if (!isSolved || Math.abs(force) < 0.1) {
                        p.stroke(0);
                        p.strokeWeight(2);
                    } else if (force > 0) {
                        p.stroke(255, 0, 0); // Tension - red
                        p.strokeWeight(p.map(Math.abs(force), 0, maxForce, 2, 10));
                    } else {
                        p.stroke(0, 0, 255); // Compression - blue
                        p.strokeWeight(p.map(Math.abs(force), 0, maxForce, 2, 10));
                    }

                    p.line(x1, y1, x2, y2);

                    // Draw force magnitude at midpoint
                    if (isSolved && Math.abs(force) > 0.1) {
                        let midX = (x1 + x2) / 2;
                        let midY = (y1 + y2) / 2;
                        p.noStroke();
                        p.fill(0);
                        p.textAlign(p.CENTER, p.CENTER);
                        p.textSize(10);
                        p.text(Math.abs(force).toFixed(1), midX, midY - 8);
                    }
                }
            }

            function drawNodes() {
                for (let i = 0; i < nodes.length; i++) {
                    let node = nodes[i];

                    // Apply deflection if enabled
                    let def = deflectionScale > 0 && nodeDeflections[i] ? nodeDeflections[i] : {x: 0, y: 0};
                    let nodeX = (node.x + def.x * deflectionScale * 0.01) * scale;
                    let nodeY = (node.y + def.y * deflectionScale * 0.01) * scale;

                    // Highlight selected node
                    if (i === selectedNodeIndex) {
                        p.fill(40, 167, 69); // Green
                        p.noStroke();
                        p.ellipse(nodeX, nodeY, 20, 20);
                    }

                    p.fill(0);
                    p.noStroke();
                    p.ellipse(nodeX, nodeY, 10, 10);

                    // Draw node number
                    p.fill(100);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.textSize(10);
                    p.text(i, nodeX, nodeY + 20);
                }
            }

            function drawSupports() {
                for (let i = 0; i < nodes.length; i++) {
                    let node = nodes[i];

                    // Apply deflection if enabled
                    let def = deflectionScale > 0 && nodeDeflections[i] ? nodeDeflections[i] : {x: 0, y: 0};
                    let nodeX = (node.x + def.x * deflectionScale * 0.01) * scale;
                    let nodeY = (node.y + def.y * deflectionScale * 0.01) * scale;

                    if (node.constraint === 'pin') {
                        p.fill(100);
                        p.noStroke();
                        p.triangle(
                            nodeX - 12, nodeY,
                            nodeX + 12, nodeY,
                            nodeX, nodeY + 18
                        );
                    } else if (node.constraint === 'roller-x') {
                        p.fill(100);
                        p.noStroke();
                        p.triangle(
                            nodeX - 12, nodeY,
                            nodeX + 12, nodeY,
                            nodeX, nodeY + 18
                        );
                        p.ellipse(nodeX, nodeY + 23, 10, 10);
                    } else if (node.constraint === 'roller-y') {
                        p.fill(100);
                        p.noStroke();
                        p.triangle(
                            nodeX, nodeY - 12,
                            nodeX, nodeY + 12,
                            nodeX - 18, nodeY
                        );
                        p.ellipse(nodeX - 23, nodeY, 10, 10);
                    }
                }
            }

            function drawAppliedForces() {
                for (let i = 0; i < nodes.length; i++) {
                    let node = nodes[i];

                    // Apply deflection if enabled
                    let def = deflectionScale > 0 && nodeDeflections[i] ? nodeDeflections[i] : {x: 0, y: 0};
                    let nodeX = (node.x + def.x * deflectionScale * 0.01) * scale;
                    let nodeY = (node.y + def.y * deflectionScale * 0.01) * scale;

                    if (Math.abs(node.fx) > 0.01) {
                        drawForceArrow(nodeX, nodeY, node.fx, 0);
                    }
                    if (Math.abs(node.fy) > 0.01) {
                        drawForceArrow(nodeX, nodeY, 0, node.fy);
                    }
                }
            }

            function drawForceArrow(x, y, fx, fy) {
                p.stroke(255, 150, 0);
                p.strokeWeight(3);
                p.fill(255, 150, 0);

                let arrowLen = 40;
                let mag = Math.sqrt(fx * fx + fy * fy);
                // Note: in canvas coords, Y increases downward
                // But we want positive fy to point upward, negative fy to point downward
                // So we negate fy for the canvas
                let dx = fx / mag * arrowLen;
                let dy = -fy / mag * arrowLen; // Negate to match canvas coordinates

                // Arrow line
                p.line(x - dx, y - dy, x, y);

                // Arrow head
                let angle = Math.atan2(dy, dx);
                p.push();
                p.translate(x, y);
                p.rotate(angle);
                p.triangle(0, 0, -10, -5, -10, 5);
                p.pop();

                // Label - show force components with proper signs
                p.noStroke();
                p.fill(0);
                p.textAlign(p.CENTER);
                p.textSize(11);
                let labelText = '';
                if (Math.abs(fx) > 0.01) labelText = 'Fx: ' + fx.toFixed(1) + ' kN';
                if (Math.abs(fy) > 0.01) {
                    if (labelText) labelText += ', ';
                    labelText += 'Fy: ' + fy.toFixed(1) + ' kN';
                }
                p.text(labelText, x - dx - 15 * Math.cos(angle), y - dy - 15 * Math.sin(angle));
            }

            function updateResults() {
                let maxTension = 0;
                let maxCompression = 0;

                for (let force of memberForces) {
                    if (force > maxTension) maxTension = force;
                    if (force < maxCompression) maxCompression = force;
                }

                // Also calculate deflections
                if (isSolved) {
                    calculateDeflections();
                }
            }

            function drawInfoPanel() {
                // Draw info panel in top-right corner (before translate)
                p.push();
                p.resetMatrix();

                let panelWidth = 240;
                let panelHeight = 140;
                let panelX = p.width - panelWidth - 15;
                let panelY = 15;

                p.fill(255, 255, 255, 250);
                p.stroke(100);
                p.strokeWeight(2);
                p.rect(panelX, panelY, panelWidth, panelHeight, 8);

                p.fill(0);
                p.noStroke();
                p.textAlign(p.LEFT);
                p.textSize(13);
                p.textStyle(p.BOLD);
                p.text('Truss Analysis', panelX + 12, panelY + 22);

                p.textStyle(p.NORMAL);
                p.textSize(11);

                let lineY = panelY + 42;
                let lineSpacing = 16;

                // System status
                let statusColor;
                let statusText = systemStatus.charAt(0).toUpperCase() + systemStatus.slice(1);
                if (systemStatus === 'isostatic') {
                    statusColor = p.color(40, 167, 69);
                } else if (systemStatus === 'hyperstatic') {
                    statusColor = p.color(200, 100, 0);
                } else {
                    statusColor = p.color(220, 50, 50);
                }

                p.fill(statusColor);
                p.text('System: ' + statusText, panelX + 12, lineY);
                p.text('(' + numEquations + ' eq, ' + numMembers + ' members)', panelX + 12, lineY + lineSpacing * 0.8);

                p.fill(0);
                lineY += lineSpacing * 1.8;

                // Force results and solver status
                if (isSolved && memberForces.length > 0) {
                    let maxTension = 0;
                    let maxCompression = 0;
                    for (let force of memberForces) {
                        if (force > maxTension) maxTension = force;
                        if (force < maxCompression) maxCompression = force;
                    }

                    p.text('Max Tension: ' + maxTension.toFixed(2) + ' kN', panelX + 12, lineY);
                    p.text('Max Compression: ' + Math.abs(maxCompression).toFixed(2) + ' kN', panelX + 12, lineY + lineSpacing);

                    p.fill(40, 167, 69);
                    p.textSize(10);
                    p.text('✓ ' + solverMessage, panelX + 12, lineY + lineSpacing * 2 + 3);
                } else {
                    // Show solver message or instructions
                    if (solverMessage) {
                        p.fill(220, 50, 50);
                        p.textSize(10);
                        p.text('✗ ' + solverMessage, panelX + 12, lineY);
                        p.fill(100);
                        p.text('Adjust constraints to solve', panelX + 12, lineY + lineSpacing);
                    } else {
                        p.fill(100);
                        p.textSize(10);
                        p.text('Click nodes to set forces', panelX + 12, lineY);
                        p.text('and constraints', panelX + 12, lineY + lineSpacing);
                    }
                }

                p.pop();
            }

            function calculateDeflections() {
                // Proper virtual work method for deflection calculation
                // Assume E (Young's modulus) = 200 GPa, A (area) = 0.001 m²
                const E = 200e9; // Pa
                const A = 0.001; // m²
                const EA = E * A;

                // Initialize deflections
                nodeDeflections = nodes.map(() => ({x: 0, y: 0}));

                // Store original state
                let originalForces = [...nodes.map(n => ({fx: n.fx, fy: n.fy}))];
                let actualForces = [...memberForces];
                let wasSolved = isSolved;

                // Calculate deflections for each node
                for (let i = 0; i < nodes.length; i++) {
                    let defX = 0, defY = 0;

                    // Calculate horizontal deflection (X direction)
                    // Skip if X is constrained
                    if (nodes[i].constraint !== 'pin' && nodes[i].constraint !== 'roller-x') {
                        // Clear all loads
                        for (let j = 0; j < nodes.length; j++) {
                            nodes[j].fx = 0;
                            nodes[j].fy = 0;
                        }
                        // Apply unit horizontal load at node i (positive = rightward)
                        nodes[i].fx = 1.0; // 1 kN rightward

                        // Solve for virtual forces
                        solveTruss(true);
                        if (isSolved) {
                            let virtualForces = [...memberForces];

                            // Calculate horizontal deflection using virtual work
                            for (let m = 0; m < members.length; m++) {
                                let member = members[m];
                                let n1 = nodes[member.start];
                                let n2 = nodes[member.end];
                                let dx = n2.x - n1.x;
                                let dy = n2.y - n1.y;
                                let L = Math.sqrt(dx * dx + dy * dy);

                                let F_actual = actualForces[m];
                                let f_virtual = virtualForces[m];

                                defX += F_actual * f_virtual * L * 1000 / EA;
                            }
                        }
                    }

                    // Calculate vertical deflection (Y direction)
                    // Skip if Y is constrained
                    if (nodes[i].constraint !== 'pin' && nodes[i].constraint !== 'roller-y') {
                        // Clear all loads
                        for (let j = 0; j < nodes.length; j++) {
                            nodes[j].fx = 0;
                            nodes[j].fy = 0;
                        }
                        // Apply unit vertical load at node i (negative = downward per convention)
                        nodes[i].fy = -1.0; // 1 kN downward

                        // Solve for virtual forces
                        solveTruss(true);
                        if (isSolved) {
                            let virtualForces = [...memberForces];

                            // Calculate vertical deflection using virtual work
                            for (let m = 0; m < members.length; m++) {
                                let member = members[m];
                                let n1 = nodes[member.start];
                                let n2 = nodes[member.end];
                                let dx = n2.x - n1.x;
                                let dy = n2.y - n1.y;
                                let L = Math.sqrt(dx * dx + dy * dy);

                                let F_actual = actualForces[m];
                                let f_virtual = virtualForces[m];

                                defY += F_actual * f_virtual * L * 1000 / EA;
                            }
                        }
                    }

                    // Store deflections (amplified 1000x for visibility)
                    nodeDeflections[i] = {x: defX * 1000, y: defY * 1000};
                }

                // Restore original state
                for (let j = 0; j < nodes.length; j++) {
                    nodes[j].fx = originalForces[j].fx;
                    nodes[j].fy = originalForces[j].fy;
                }
                memberForces = actualForces;
                isSolved = wasSolved;

                // Debug: log deflections
                console.log('Deflections calculated:', nodeDeflections);
            }

            function setupDeflectionSlider() {
                let slider = document.getElementById('deflection-scale');
                let valueDisplay = document.getElementById('deflection-value');

                slider.addEventListener('input', function() {
                    deflectionScale = parseFloat(this.value);
                    valueDisplay.textContent = deflectionScale.toFixed(0);
                });
            }

            function openNodeEditor(nodeIndex) {
                selectedNodeIndex = nodeIndex;
                let node = nodes[nodeIndex];

                document.getElementById('selected-node-id').textContent = nodeIndex;
                document.getElementById('force-x').value = node.fx;
                document.getElementById('force-y').value = node.fy;
                document.getElementById('constraint-type').value = node.constraint;
                document.getElementById('node-editor').style.display = 'block';

                // Create free body diagram
                createFBD(nodeIndex);
            }

            function closeNodeEditor() {
                selectedNodeIndex = -1;
                document.getElementById('node-editor').style.display = 'none';
                if (fbdSketch) {
                    fbdSketch.remove();
                    fbdSketch = null;
                }
            }

            function applyNodeChanges() {
                if (selectedNodeIndex >= 0) {
                    let node = nodes[selectedNodeIndex];
                    node.fx = parseFloat(document.getElementById('force-x').value) || 0;
                    node.fy = parseFloat(document.getElementById('force-y').value) || 0;
                    node.constraint = document.getElementById('constraint-type').value;

                    solveTruss();
                    createFBD(selectedNodeIndex); // Update FBD
                }
            }

            function createFBD(nodeIndex) {
                if (fbdSketch) {
                    fbdSketch.remove();
                }

                fbdSketch = new p5(function(fbd) {
                    fbd.setup = function() {
                        fbd.createCanvas(560, 300).parent('fbd-holder');
                    };

                    fbd.draw = function() {
                        fbd.background(249);
                        fbd.translate(280, 150);

                        let node = nodes[nodeIndex];

                        // Draw central node
                        fbd.fill(40, 167, 69);
                        fbd.noStroke();
                        fbd.ellipse(0, 0, 20, 20);
                        fbd.fill(0);
                        fbd.textAlign(fbd.CENTER, fbd.CENTER);
                        fbd.textSize(12);
                        fbd.text("Node " + nodeIndex, 0, -30);

                        // Find all members connected to this node
                        let connectedMembers = [];
                        for (let i = 0; i < members.length; i++) {
                            if (members[i].start === nodeIndex || members[i].end === nodeIndex) {
                                connectedMembers.push({index: i, member: members[i]});
                            }
                        }

                        // Draw member forces
                        for (let cm of connectedMembers) {
                            let member = cm.member;
                            let force = isSolved ? memberForces[cm.index] : 0;
                            let otherNodeIndex = member.start === nodeIndex ? member.end : member.start;
                            let otherNode = nodes[otherNodeIndex];

                            let dx = otherNode.x - node.x;
                            let dy = otherNode.y - node.y;
                            let angle = Math.atan2(dy, dx);

                            // Calculate arrow endpoints
                            let arrowLen = 70;
                            let arrowDx = arrowLen * Math.cos(angle);
                            let arrowDy = arrowLen * Math.sin(angle);

                            // Set color
                            let arrowColor = force > 0 ? fbd.color(255, 0, 0) : (force < 0 ? fbd.color(0, 0, 255) : fbd.color(0));
                            fbd.stroke(arrowColor);
                            fbd.strokeWeight(3);
                            fbd.fill(arrowColor);

                            // Draw arrow line and head
                            if (force >= 0) {
                                // TENSION: arrow points away from node (along member direction)
                                fbd.line(0, 0, arrowDx, arrowDy);
                                // Arrowhead at far end
                                fbd.push();
                                fbd.translate(arrowDx, arrowDy);
                                fbd.rotate(angle);
                                fbd.triangle(0, 0, -10, -5, -10, 5);
                                fbd.pop();
                            } else {
                                // COMPRESSION: arrow points toward node (opposite to member direction)
                                fbd.line(arrowDx, arrowDy, 0, 0);
                                // Arrowhead at node (origin)
                                fbd.push();
                                fbd.translate(0, 0);
                                fbd.rotate(angle + fbd.PI); // Point opposite direction
                                fbd.triangle(0, 0, -10, -5, -10, 5);
                                fbd.pop();
                            }

                            // Label - position perpendicular to arrow to avoid overlap
                            fbd.noStroke();
                            fbd.fill(0);
                            fbd.textSize(11);
                            fbd.textAlign(fbd.CENTER, fbd.CENTER);

                            // Calculate perpendicular offset based on arrow angle
                            let perpAngle = angle + fbd.PI / 2;
                            let labelDist = 0.55; // Distance along arrow
                            let perpOffset = 20; // Perpendicular offset

                            let labelX = arrowDx * labelDist + Math.cos(perpAngle) * perpOffset;
                            let labelY = arrowDy * labelDist + Math.sin(perpAngle) * perpOffset;

                            fbd.text("F" + cm.index + " = " + Math.abs(force).toFixed(1) + " kN", labelX, labelY);
                            fbd.textSize(9);
                            fbd.text(force > 0 ? "(T)" : (force < 0 ? "(C)" : ""), labelX, labelY + 12);
                        }

                        // Draw applied forces
                        if (Math.abs(node.fx) > 0.01 || Math.abs(node.fy) > 0.01) {
                            let mag = Math.sqrt(node.fx * node.fx + node.fy * node.fy);
                            // Negate fy for canvas coordinates (positive fy = upward, negative canvas dy)
                            let angle = Math.atan2(-node.fy, node.fx);
                            let arrowLen = 80;
                            let arrowDx = arrowLen * Math.cos(angle);
                            let arrowDy = arrowLen * Math.sin(angle);

                            fbd.stroke(255, 150, 0);
                            fbd.strokeWeight(3);
                            fbd.line(0, 0, arrowDx, arrowDy);

                            fbd.fill(255, 150, 0);
                            fbd.push();
                            fbd.translate(arrowDx, arrowDy);
                            fbd.rotate(angle);
                            fbd.triangle(0, 0, -10, -5, -10, 5);
                            fbd.pop();

                            fbd.noStroke();
                            fbd.fill(0);
                            fbd.textSize(11);
                            fbd.textAlign(fbd.CENTER);

                            // Show components with proper signs
                            let labelX = arrowDx * 0.75;
                            let labelY = arrowDy * 0.75;

                            // Position label perpendicular to avoid arrow
                            let perpAngle = angle + fbd.PI / 2;
                            labelX += Math.cos(perpAngle) * 25;
                            labelY += Math.sin(perpAngle) * 25;

                            fbd.text("Applied Force", labelX, labelY - 12);
                            if (Math.abs(node.fx) > 0.01) {
                                fbd.text("Fx: " + node.fx.toFixed(1) + " kN", labelX, labelY + 2);
                            }
                            if (Math.abs(node.fy) > 0.01) {
                                fbd.text("Fy: " + node.fy.toFixed(1) + " kN", labelX, labelY + 14);
                            }
                        }

                        // Draw reaction forces if constrained
                        if (node.constraint !== 'none') {
                            fbd.fill(100);
                            fbd.textSize(11);
                            fbd.textAlign(fbd.CENTER);
                            let labelY = 100;
                            if (node.constraint === 'pin') {
                                fbd.text("Pin support: Rx and Ry reactions", 0, labelY);
                            } else if (node.constraint === 'roller-x') {
                                fbd.text("Horizontal roller: Ry reaction only", 0, labelY);
                            } else if (node.constraint === 'roller-y') {
                                fbd.text("Vertical roller: Rx reaction only", 0, labelY);
                            }
                        }
                    };
                }, 'fbd-holder');
            }

            function setupNodeEditor() {
                document.getElementById('close-node-editor').addEventListener('click', closeNodeEditor);
                document.getElementById('apply-node-changes').addEventListener('click', applyNodeChanges);
            }

            // Expose functions for external use
            window.trussSketch = {
                closeNodeEditor: closeNodeEditor,
                applyNodeChanges: applyNodeChanges
            };

        }, 'sketch-holder');

        // Quiz submission
        document.getElementById('submit-quiz').addEventListener('click', function() {
            const answers = {
                q1: 'b',
                q2: 'b',
                q3: 'a',
                q4: 'b',
                q5: 'b'
            };

            submitQuiz(
                Object.entries(answers).map(([name, correct]) => ({name, correctAnswer: correct})),
                'quiz-results'
            );
        });
    </script>
</body>
</html>
