<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Work and Energy - Interactive Lecture</title>
    <!-- Import p5.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <!-- Import MathJax for LaTeX rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.0/es5/tex-mml-chtml.js"></script>
    <!-- External CSS -->
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="stylesheet" href="/assets/css/simulations.css">

    <style>
        /* Page-specific styles for work and energy simulations */
        .sim-holder {
            width: 100%;
            min-height: 400px;
            position: relative;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
            margin: 10px 0;
            overflow: hidden;
        }

        .energy-bars {
            display: flex;
            gap: 15px;
            margin: 15px 0;
            padding: 10px;
            background-color: #f0f8ff;
            border-radius: 5px;
        }
        
        .energy-bar-container {
            flex: 1;
            text-align: center;
        }
        
        .energy-bar-label {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        
        .energy-bar-wrapper {
            height: 150px;
            width: 40px;
            background-color: #e0e0e0;
            border: 2px solid #333;
            border-radius: 3px;
            margin: 0 auto;
            position: relative;
            display: flex;
            align-items: flex-end;
        }
        
        .energy-bar {
            width: 100%;
            background: linear-gradient(to top, #4CAF50, #8BC34A);
            border-radius: 0 0 3px 3px;
            transition: height 0.3s ease;
        }
        
        .energy-value {
            margin-top: 5px;
            font-size: 0.85em;
            color: #555;
        }
    </style>
</head>
<body>
    <header>
        <h1>Work and Energy</h1>
        <p class="subtitle">Interactive Lecture & Simulation</p>
    </header>

    <div class="content-section">
        <h2>Understanding Work and Energy</h2>
        <p>The principle of work and energy is a fundamental concept in mechanics that relates the work done on a body to the change in its kinetic energy. This principle provides a powerful alternative to Newton's second law for solving dynamics problems.</p>
        
        <div class="key-point">
            <p><strong>Core Insight:</strong> Energy methods often simplify problems by eliminating the need to consider forces that do no work, and by avoiding the direct calculation of acceleration.</p>
        </div>

        <h3>Definition of Work</h3>
        <div class="equation-box">
            <p><strong>Work of a Force:</strong></p>
            <p>For a force \(\vec{F}\) acting through an infinitesimal displacement \(d\vec{s}\) from position \(s_1\) to position \(s_2\):</p>
            <p>\(W = \displaystyle \int_{s_1}^{s_2}\vec{F} \cdot d \vec{s}\)</p>
            <p>where \(\cdot\) is the <em>scalar product</em> between the force and displacement vectors, therefore the work done is a scalar quantity, and its SI unit is the Joule \([\text{J}]=[\text{Nm}]\).</p>
            
            <p><strong>Work of a Couple Moment:</strong></p>
            <p>For a constant couple moment \(M\) acting through an angular displacement \(\theta\):</p>
            <p>\(W = M \theta\)</p>
        </div>

        <h3>Work of a Constant Force</h3>
        <p>When a constant force acts on a particle that moves along a straight line, the work done is simply the product of the force component in the direction of motion and the distance travelled, or alternatively by the product of the force and the component of distance travelled in the same direction of the force.</p>
        
        <div class="equation-box">
            <p>\(W_F = \vec{F} \cdot \Delta\vec{s}=\big(F\cos\theta\big)\Delta s =F\big(\Delta s \cos\theta\big)\)</p>
            <p>where \(\theta\) is the angle between the force vector and the displacement vector.</p>
        </div>

        <h3>Work of the Gravitational Force</h3>
        <p>The gravitational force is a special case of a constant force (near Earth's surface):</p>
        
        <div class="equation-box">
            <p>For a mass \(m\) moving vertically through height \(h\):</p>
            <p>\(W_{g} = -mgh\) (when moving upward)</p>
            <p>\(W_{g} = +mgh\) (when moving downward)</p>
        </div>
        
        <div class="key-point">
            <p><strong>Important:</strong> The work done by gravity depends only on the vertical displacement, not on the path taken. This makes gravity a <strong>conservative force</strong>.</p>
        </div>

        <h3>Work of Spring Forces</h3>
        <p>The force on a spring is proportional on its stiffness (spring coefficient \(k\)) and its displacement (extension)</p>
        <p>\[F_k=-ks\]</p>
        
        <div class="equation-box">
            <p>For a spring being extended from \(s_1\) to \(s_2\):</p>
            <p>\(W_{k} = \displaystyle \int_{s_1}^{s_2}-ks \, ds=-\frac{1}{2}k\big( s_2^2-s_1^2\big) \)</p>
        </div>

        <h3>Work of Reaction Forces</h3>
        <p>Reaction forces \(R\) are always perpendicular to the direction of motion, therefore they do <strong>no work</strong>:</p>
        
        <div class="equation-box">
            <p>Since \(\theta = 90°\) between normal force and displacement:</p>
            <p>\(W_{R} = R \cdot \Delta s \cdot \cos(90°) = 0\)</p>
        </div>
        
        <p>This is why energy methods are particularly useful, we can ignore forces such as all reactions that do not contribute to the energy balance!</p>

        <h3>Work of Friction Forces</h3>
        <p>Friction forces always oppose motion and therefore do negative work:</p>
        
        <div class="equation-box">
            <p>\(W_{f} = -F_f \cdot \Delta s = -\mu_k N \cdot \Delta s\)</p>
        </div>
        
        <div class="key-point">
            <p><strong>Conservative vs Non-Conservative Forces:</strong></p>
            <ul>
                <li><strong>Conservative forces</strong> (gravity, springs): Work depends only on initial and final positions</li>
                <li><strong>Non-conservative forces</strong> (friction, drag): Work depends on the path taken</li>
            </ul>
        </div>

        <h3>Potential Energy</h3>
        <p>For conservative forces, we can define a potential energy function:</p>
        
        <div class="equation-box">
            <p><strong>Gravitational Potential Energy:</strong> \(U_g = mgh\)</p>
            <p><strong>Elastic Potential Energy:</strong> \(U_e = \frac{1}{2}kx^2\)</p>
            <p>The work done by a conservative force equals the negative change in potential energy:</p>
            <p>\(W_{\text{cons}} = -\Delta U\)</p>
        </div>

        <h3>The Principle of Work and Energy</h3>
        <p>By integrating Newton's second law with respect to displacement</p>
        <p>\[\displaystyle \int \sum F \, ds=\displaystyle \int ma \, ds\]</p>
        <p>\[\displaystyle \sum \int  F \, ds=\displaystyle \int mv \, dv\]</p>
        <p>\[\displaystyle \sum W = \frac{1}{2}mv_2^2 - \frac{1}{2}mv_1^2\]</p>
        <p>hence we define the quantity <em>kinetic energy</em> \(E_k=\frac{1}{2}mv^2\) </p>
        <p>and we arrive at</p>
        <div class="equation-box">
            <p><strong>The Work-Energy Theorem:</strong></p>
            <p>\[\sum W = \Delta E_k\]</p>
            <p>The total work done on a particle equals the change in its kinetic energy.</p>
        </div>

        <h3>Rotational Work and Energy</h3>
        <p>For rotating rigid bodies:</p>
        
        <div class="equation-box">
            <p><strong>Rotational Kinetic Energy:</strong> \(E_{k,\text{rot}} = \frac{1}{2}I\omega^2\)</p>
            <p>where \(I\) is the moment of inertia and \(\omega\) is the angular velocity.</p>
            
            <p><strong>Total Energy for Rolling Motion:</strong></p>
            <p>\(E_{k,\text{tot}} = E_{k,\text{trans}} + E_{k,\text{rot}} = \frac{1}{2}mv^2 + \frac{1}{2}I\omega^2\)</p>
        </div>

        <h3>Other forms of the Work-Energy theorem</h3>
        <p>starting from the previous form:</p>
        <p>\[\sum W = \Delta E_k\]</p>
        <p>we can split the sum of work into work done by conservative forces \(W_{\text{cons}}\) and work done by non-conservative forces  \(W_{\text{nc}}\)</p>
        <p>\[W_{\text{cons}}+W_{\text{nc}} = \Delta E_k\]</p>
        <p>recalling the definition of potential energy for conservative forces \(W_{\text{cons}}=-\Delta U\)</p>
        <p>\[-\Delta U+W_{\text{nc}} = \Delta E_k\]</p>
        <p>finally, by noting that \(\Delta U=U_2-U_1\,\) and \(\,\Delta E_k=E_{k2}-E_{k1}\,\) we arrive at an alternative form of the Work-Energy theorem</p>
        <div class="equation-box">
            <p>\[E_{k_1}+U_1+W_{\text{nc}} = E_{k_2}+U_2\]</p>
            <p><em>The final mechanical (kinetic and potential) energy of the system is equal to the initial mechanical energy of the system plus (minus) the contribution of non-conservative forces.</em></p>
            <p>\[E_1+W_{\text{nc}} = E_2\]</p>
            <p><strong>corollary:</strong> in the absence of non-conservative forces (such as friction and drag), the total mechanical energy of the system is conserved \(E_1=E_2\).</p>
        </div>
    </div>

    <!-- Simulation 1: U-shaped slide -->
    <div class="simulation-container">
        <h2>Simulation 1: Energy Conservation in a U-Shaped Slide</h2>
        <p>Release the bead from different heights and observe how friction affects the maximum height reached. Toggle friction to see the difference between conservative and non-conservative systems.</p>
        
        <div id="slide-sim" class="sim-holder"></div>
        
        <div class="controls-panel">
            <button id="slide-reset">Reset</button>
            <button id="slide-release">Release Bead</button>
            <div class="control-item">
                <label>Initial Height:</label>
                <input type="range" id="slide-height" min="50" max="150" value="100">
                <div class="control-value">Height: <span id="height-value">100</span> mm</div>
            </div>
            <div class="control-item">
                <label>Friction Force:</label>
                <input type="range" id="slide-friction" min="0" max="2" step="0.1" value="0">
                <div class="control-value">Friction: <span id="friction-force-value">0.0</span> N</div>
            </div>
        </div>
        
        <div class="key-point">
            <p><strong>Observation:</strong> Without friction, the bead returns to its initial height (energy is conserved). With friction, some energy is dissipated as heat, and the bead doesn't reach the initial height.</p>
        </div>
    </div>

    <!-- Simulation 2: Block on incline -->
    <div class="simulation-container">
        <h2>Simulation 2: Block Sliding Down an Incline</h2>
        <p>Watch how potential energy converts to kinetic energy as the block slides down. The energy bars show both absolute (Joules) and percentage values, including energy dissipated by friction.</p>
        
        <div id="incline-sim" class="sim-holder"></div>
        
        <div class="controls-panel">
            <button id="incline-reset">Reset</button>
            <button id="incline-start">Start</button>
            <div class="control-item">
                <label>Incline Angle:</label>
                <input type="range" id="incline-angle" min="15" max="60" value="30">
                <div class="control-value">Angle: <span id="angle-value">30</span>°</div>
            </div>
            <div class="control-item">
                <label>Coefficient of Friction:</label>
                <input type="range" id="incline-friction" min="0" max="0.5" step="0.05" value="0.1">
                <div class="control-value">μ: <span id="friction-value">0.10</span></div>
            </div>
        </div>
    </div>

    <!-- Simulation 3: Rolling race -->
    <div class="simulation-container">
        <h2>Simulation 3: Rolling Race - Different Objects</h2>
        <p>Compare how different shaped objects roll down an incline. Each object has the same mass and radius, but a different moment of inertia, leading to a different distribution of rotational and translational kinetic energy.</p>
        
        <div id="race-sim" class="sim-holder"></div>
        
        <div class="controls-panel">
            <button id="race-reset">Reset</button>
            <button id="race-start">Start Race</button>
        </div>
        
        <div class="key-point">
            <p><strong>Physics Insight:</strong> Objects with lower moments of inertia (like solid spheres) accelerate faster down the incline because less energy goes into rotation. The acceleration is independent of mass and radius!</p>
        </div>
    </div>

    <div class="content-section">
        <h2>Applications of Work-Energy Principle</h2>
        
        <h3>Engineering Applications</h3>
        <ul>
            <li><strong>Vehicle Design:</strong> Calculating braking distances and impact forces</li>
            <li><strong>Roller Coaster Design:</strong> Determining maximum speeds and loop sizes</li>
            <li><strong>Power Generation:</strong> Hydroelectric dams converting potential to electrical energy</li>
            <li><strong>Manufacturing:</strong> Flywheel energy storage in presses and punches</li>
            <li><strong>Sports Equipment:</strong> Optimising energy transfer in golf clubs, tennis rackets</li>
        </ul>

        <h3>Problem-Solving Strategy</h3>
        <div class="equation-box">
            <ol>
                <li>Identify the system and draw a free-body diagram</li>
                <li>Choose reference levels for potential energy</li>
                <li>Calculate initial kinetic and potential energies</li>
                <li>Calculate work done by non-conservative forces</li>
                <li>Apply the work-energy equation</li>
                <li>Solve for the unknown quantity</li>
            </ol>
        </div>

        <h2>Practice Problems</h2>
        
        <div class="practice-problems">
            <h3>Problem 1: Sliding Block</h3>
            <p>A 5 kg block starts from rest at the top of a 30° incline that is 2 metres long. If the coefficient of kinetic friction is 0.2, find the speed of the block at the bottom.</p>
            
            <p class="toggle-section" onclick="toggleSolution('solution1')">Show Solution</p>
            <div id="solution1" class="hidden">
                <p>Given: \(m = 5\) kg, \(\theta = 30°\), \(s = 2\) m, \(\mu_k = 0.2\), \(v_1 = 0\)</p>
                
                <p>Height change: \(h = s \sin\theta = 2 \sin 30° = 1\) m</p>
                
                <p>Normal force: \(N = mg\cos\theta = 5 \times 9.81 \times \cos 30° = 42.5\) N</p>
                
                <p>Work by friction: \(W_f = -\mu_k N s = -0.2 \times 42.5 \times 2 = -17\) J</p>
                
                <p>Using work-energy theorem:</p>
                <p>\(mgh + W_f = \frac{1}{2}mv_2^2\)</p>
                <p>\(5 \times 9.81 \times 1 - 17 = \frac{1}{2} \times 5 \times v_2^2\)</p>
                <p>\(49.05 - 17 = 2.5v_2^2\)</p>
                <p>\(v_2 = \sqrt{\frac{32.05}{2.5}} = 3.58\) m/s</p>
            </div>
        </div>

        <div class="practice-problems">
            <h3>Problem 2: Rolling Cylinder</h3>
            <p>A solid cylinder of mass 10 kg and radius 0.2 m rolls without slipping down a 45° incline. If it starts from rest and rolls 3 metres along the incline, find its final linear velocity.</p>
            
            <p class="toggle-section" onclick="toggleSolution('solution2')">Show Solution</p>
            <div id="solution2" class="hidden">
                <p>Given: \(m = 10\) kg, \(R = 0.2\) m, \(\theta = 45°\), \(s = 3\) m</p>
                
                <p>For a solid cylinder: \(I = \frac{1}{2}mR^2\)</p>
                
                <p>Height change: \(h = s\sin\theta = 3\sin 45° = 2.12\) m</p>
                
                <p>For rolling without slipping: \(v = R\omega\)</p>
                
                <p>Energy equation:</p>
                <p>\(mgh = \frac{1}{2}mv^2 + \frac{1}{2}I\omega^2\)</p>
                <p>\(mgh = \frac{1}{2}mv^2 + \frac{1}{2} \times \frac{1}{2}mR^2 \times \frac{v^2}{R^2}\)</p>
                <p>\(gh = \frac{1}{2}v^2 + \frac{1}{4}v^2 = \frac{3}{4}v^2\)</p>
                <p>\(v = \sqrt{\frac{4gh}{3}} = \sqrt{\frac{4 \times 9.81 \times 2.12}{3}} = 5.27\) m/s</p>
            </div>
        </div>

        <h2>Summary</h2>
        <div class="key-point">
            <h3>Key Takeaways</h3>
            <ol>
                <li>Work is the dot product of force and displacement</li>
                <li>The work-energy theorem states: Total work = Change in kinetic energy</li>
                <li>Conservative forces (gravity, springs) have associated potential energies</li>
                <li>Non-conservative forces (friction) dissipate mechanical energy</li>
                <li>For systems with rotation, total energy includes both translational and rotational kinetic energy</li>
                <li>Energy methods often simplify problems by avoiding acceleration calculations</li>
            </ol>
        </div>

        <div class="equation-table">
            <table>
                <thead>
                    <tr>
                        <th>Concept</th>
                        <th>Equation</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Work of a Force</td>
                        <td>\(W = \vec{F} \cdot \vec{s}\)</td>
                        <td>Scalar product of force and displacement</td>
                    </tr>
                    <tr>
                        <td>Kinetic Energy (Translation)</td>
                        <td>\(E_k = \frac{1}{2}mv^2\)</td>
                        <td>Energy due to linear motion</td>
                    </tr>
                    <tr>
                        <td>Kinetic Energy (Rotation)</td>
                        <td>\(E_{k,\text{rot}} = \frac{1}{2}I\omega^2\)</td>
                        <td>Energy due to rotational motion</td>
                    </tr>
                    <tr>
                        <td>Gravitational PE</td>
                        <td>\(U_g = mgh\)</td>
                        <td>Potential energy due to height</td>
                    </tr>
                    <tr>
                        <td>Elastic PE</td>
                        <td>\(U_k = \frac{1}{2}kx^2\)</td>
                        <td>Energy stored in springs</td>
                    </tr>
                    <tr>
                        <td>Work-Energy Theorem</td>
                        <td>\(\sum W = \Delta E_k\)</td>
                        <td>Fundamental principle</td>
                    </tr>
                    <tr>
                        <td>Conservation of Energy</td>
                        <td>\(E_1 + W_{\text{nc}} = E_2\)</td>
                        <td>Including non-conservative work</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <footer>
        <script src="/assets/common/footer.js"></script>
    </footer>

    <script>
        // Toggle solution visibility
        function toggleSolution(id) {
            const solution = document.getElementById(id);
            if (solution.classList.contains('hidden')) {
                solution.classList.remove('hidden');
                solution.previousElementSibling.textContent = "Hide Solution";
            } else {
                solution.classList.add('hidden');
                solution.previousElementSibling.textContent = "Show Solution";
            }
        }

// Simulation 1: U-shaped slide (vertical – semicircle – vertical)
// Physics in SI units (m, s, N, J). Rendering converts to pixels.

let slideSketch = function(p) {
  // --- Constants & settings ---
  const g = 9.81;            // m/s^2
  const mass = 1;            // kg
  const scale = 100;         // px per metre
  const slideRadiusPx = 80;  // px
  const slideBottomPx = 350; // y pixel for the bottom of the semicircle
  const maxHeightPx = 200;   // vertical leg length in px (each side)
  const vEps = 1e-3;         // m/s threshold for "at rest"
  const aEps = 5e-2;         // m/s^2 threshold to prevent false sticking

  // --- State (physics in metres, seconds) ---
  let beadPos_m = 0;     // arclength position along track [0, totalLength_m]
  let beadVel_mps = 0;   // tangential velocity along track
  let frictionForce_N = 0; // constant kinetic friction magnitude (N)
  let isReleased = false;

  // UI-provided: initial height from top of left vertical (in PX for slider), convert on reset
  let initialHeightPx = 100;

  // Track geometry (metres)
  let R_m, leftVertical_m, rightVertical_m, arcLength_m, totalLength_m;

  // Energy bookkeeping
  let energyLost_J = 0;
  let initialEnergy_J = 0; // computed at reset from actual start height

  // --- Helpers (geometry & kinematics) ---

  function slideTopPx() {
    // top y of the vertical legs (they end at the top of the semicircle)
    return slideBottomPx - (leftVertical_m * scale) - (R_m * scale);
  }

  // Return bead (x,y) in pixels from a position s (metres) along the track
  function getBeadCoordinatesPx(s_m) {
    const topPx = slideTopPx();

    if (s_m <= leftVertical_m) {
      // Left vertical (downwards along +s)
      return {
        x: p.width / 2 - 50 - R_m * scale,
        y: topPx + s_m * scale
      };
    }

    if (s_m <= leftVertical_m + arcLength_m) {
      // Bottom semicircle from leftmost (angle π) to rightmost (angle 0)
      const arcPos_m = s_m - leftVertical_m;
      const angle = Math.PI - (arcPos_m / R_m); // s increases as angle decreases
      const cx = p.width / 2 - 50;
      const cy = slideBottomPx - R_m * scale;
      const x = cx + (R_m * scale) * Math.cos(angle);
      const y = cy + (R_m * scale) * Math.sin(angle);
      return { x, y };
    }

    // Right vertical (upwards along +s)
    const vertPos_m = s_m - leftVertical_m - arcLength_m;
    return {
      x: p.width / 2 - 50 + R_m * scale,
      y: slideBottomPx - R_m * scale - vertPos_m * scale
    };
  }

  // Tangential component of gravity along +s (metres-based)
  function gravityAlongTrack_mps2(s_m) {
    if (s_m <= leftVertical_m) {
      // +s downward: gravity aids motion
      return +g;
    }
    if (s_m <= leftVertical_m + arcLength_m) {
      // Semicircle: angle as in getBeadCoordinatesPx
      const arcPos_m = s_m - leftVertical_m;
      const angle = Math.PI - (arcPos_m / R_m);

      // IMPORTANT: sign! For +s defined from leftmost (π) to rightmost (0),
      // the unit tangent is (sinθ, -cosθ). Dot with gravity (0, +g) gives -g*cosθ.
      return -g * Math.cos(angle);
    }
    // Right vertical: +s is upward, gravity opposes motion
    return -g;
  }

  // --- Setup & reset ---

  p.setup = function() {
    const canvas = p.createCanvas(800, 400);
    canvas.parent('slide-sim');
    resetSimulation();
  };

  function resetSimulation() {
    R_m = slideRadiusPx / scale;
    leftVertical_m = maxHeightPx / scale;
    rightVertical_m = maxHeightPx / scale;
    arcLength_m = Math.PI * R_m;
    totalLength_m = leftVertical_m + arcLength_m + rightVertical_m;

    // Clamp UI height to [0, leftVertical] in px
    const clampedInitPx = p.constrain(initialHeightPx, 0, maxHeightPx);
    const initHeight_m = clampedInitPx / scale;

    // Start on left vertical at given height from the top
    beadPos_m = leftVertical_m - initHeight_m; // metres along track
    beadVel_mps = 0;
    isReleased = false;
    energyLost_J = 0;

    // Compute initial energy from actual starting height (relative to the very bottom)
    const startXY = getBeadCoordinatesPx(beadPos_m);
    const startHeight_m = (slideBottomPx - startXY.y) / scale; // vertical height above bottom
    initialEnergy_J = mass * g * startHeight_m; // initial KE = 0
  }

  // --- Draw loop ---

  p.draw = function() {
    p.background(245);

    // Draw track
    const topPx = slideTopPx();
    p.stroke(50);
    p.strokeWeight(4);
    p.noFill();

    // left vertical
    p.line(p.width / 2 - 50 - R_m * scale, topPx, p.width / 2 - 50 - R_m * scale, slideBottomPx - R_m * scale);
    // semicircle (bottom half)
    p.arc(p.width / 2 -50 , slideBottomPx - R_m * scale, 2 * R_m * scale, 2 * R_m * scale, 0, Math.PI);
    // right vertical
    p.line(p.width / 2 - 50 + R_m * scale, slideBottomPx - R_m * scale, p.width / 2 -50 + R_m * scale, topPx);

    // Physics step (semi-implicit Euler; uses frame time for stability)
    if (isReleased) {
      const dt = Math.min(0.03, p.deltaTime / 1000); // clamp dt for stability

      const a_g = gravityAlongTrack_mps2(beadPos_m);

      // Kinetic friction opposing motion (constant magnitude), off when essentially stopped
      let a_f = 0;
      if (frictionForce_N > 0 && Math.abs(beadVel_mps) > 1e-5) {
        a_f = -(frictionForce_N / mass) * Math.sign(beadVel_mps);
      }

      const a_total = a_g + a_f;

      // Update
      const oldPos_m = beadPos_m;
      beadVel_mps += a_total * dt;
      beadPos_m += beadVel_mps * dt;

      // Work done by friction (always dissipative)
      if (frictionForce_N > 0) {
        energyLost_J += Math.abs(frictionForce_N * (beadPos_m - oldPos_m));
      }

      // Keep bead on the track
      if (beadPos_m < 0) {
        beadPos_m = 0;
        beadVel_mps = 0; // stop at hard end
      } else if (beadPos_m > totalLength_m) {
        beadPos_m = totalLength_m;
        beadVel_mps = 0;
      }

      // Only consider "rest" if both almost zero velocity and near-zero tangential accel
      if (Math.abs(beadVel_mps) < vEps && Math.abs(a_total) < aEps) {
        beadVel_mps = 0;
        isReleased = false;
      }
    }

    // Draw bead
    const beadXY = getBeadCoordinatesPx(beadPos_m);
    p.fill(255, 100, 100);
    p.noStroke();
    p.ellipse(beadXY.x, beadXY.y, 20);

    // Energies
    const height_m = (slideBottomPx - beadXY.y) / scale;
    const KE = 0.5 * mass * beadVel_mps * beadVel_mps;
    const PE = mass * g * height_m;
    const totalE = KE + PE;

    // UI text
    p.fill(0);
    p.noStroke();
    p.textAlign(p.LEFT);
    p.text(`Kinetic Energy: ${KE.toFixed(2)} J`, 10, 20);
    p.text(`Potential Energy: ${PE.toFixed(2)} J`, 10, 40);
    p.text(`Total Mechanical Energy: ${totalE.toFixed(2)} J`, 10, 60);
    p.text(`Initial Energy: ${initialEnergy_J.toFixed(2)} J`, 10, 80);
    p.text(`Energy Lost to Friction: ${energyLost_J.toFixed(2)} J`, 10, 100);
    p.text(`Friction Force: ${frictionForce_N.toFixed(2)} N`, 10, 120);

    // Reference lines: initial height & current height
    p.stroke(200);
    p.strokeWeight(1);
    p.drawingContext.setLineDash([5, 5]);

    const initXY = getBeadCoordinatesPx(leftVertical_m - (initialHeightPx / scale));
    p.line(p.width / 2 - 50 - R_m * scale - 20, initXY.y, p.width / 2 - 50 + R_m * scale + 20, initXY.y);
    p.line(beadXY.x - 30, beadXY.y, beadXY.x + 30, beadXY.y);

    p.drawingContext.setLineDash([]);
  };

  // --- Controls wiring (keep existing element IDs) ---

  document.getElementById('slide-reset').onclick = function () {
    resetSimulation();
  };

  document.getElementById('slide-release').onclick = function () {
    isReleased = true;
  };

  document.getElementById('slide-height').oninput = function () {
    // This slider is assumed to be in PIXELS (0..200). We clamp and convert on reset.
    initialHeightPx = parseFloat(this.value);
    document.getElementById('height-value').textContent = this.value;
    resetSimulation();
  };

  document.getElementById('slide-friction').oninput = function () {
    frictionForce_N = parseFloat(this.value);
    document.getElementById('friction-force-value').textContent = this.value;
  };
};

        
        // Simulation 2: Block on incline with no-slip condition indicator
        let inclineSketch = function(p) {
            let blockX, blockY;
            let velocity = 0;
            let angle = 30;
            let friction = 0.1;
            let isMoving = false;
            let inclineLength = 350;
            let blockSize = 30;
            let mass = 5; // kg
            let g = 9.81; // m/s²
            let scale = 100; // pixels per metre
            let startHeight;
            let initialPE;
            let dissipatedEnergy = 0;
            let startX, startY;
            let endX, endY;
            let distance = 0;
            let groundY = 400;
            let cannotSlide = false;
            
            p.setup = function() {
                let canvas = p.createCanvas(800, 500);
                canvas.parent('incline-sim');
                p.resetSimulation();
            };
            
            p.resetSimulation = function() {
                // Calculate incline endpoints - end point is on the ground
                endX = 500;
                endY = groundY;
                
                // Start point is calculated based on angle and length
                startX = endX - inclineLength * Math.cos(angle * Math.PI / 180);
                startY = endY - inclineLength * Math.sin(angle * Math.PI / 180);
                
                // Position block at top of incline, properly sitting on the surface
                blockX = startX + blockSize/2 * Math.sin(angle * Math.PI / 180);
                blockY = startY - blockSize/2 * Math.cos(angle * Math.PI / 180);
                
                velocity = 0;
                distance = 0;
                isMoving = false;
                dissipatedEnergy = 0;
                
                // Check if sliding is possible
                cannotSlide = (friction >= Math.tan(angle * Math.PI / 180));
                
                // Calculate initial height
                startHeight = (groundY - blockY) / scale; // in metres
                initialPE = mass * g * startHeight;
            };
            
            p.draw = function() {
                p.background(245);
                
                // Draw ground
                p.stroke(50);
                p.strokeWeight(2);
                p.line(0, groundY, p.width, groundY);
                
                // Draw incline
                p.stroke(50);
                p.strokeWeight(4);
                p.line(startX, startY, endX, endY);
                
                // Show warning if cannot slide
                if(cannotSlide && distance < 1) {
                    // Draw warning box
                    p.push();
                    p.fill(255, 230, 230);
                    p.stroke(200, 0, 0);
                    p.strokeWeight(2);
                    p.rect(200, 50, 350, 120, 10);
                    
                    p.fill(200, 0, 0);
                    p.noStroke();
                    p.textAlign(p.CENTER);
                    p.textSize(16);
                    p.text('⚠ NO SLIDING CONDITION', 370, 70);
                    p.textSize(14);
                    p.text(`μ ≥ tan(θ)`, 370, 100);
                    p.text(`${friction.toFixed(2)} ≥ ${Math.tan(angle * Math.PI / 180).toFixed(2)}`, 370, 130);
                    p.textSize(12);
                    p.text('Block will not slide: friction balances gravity', 370, 160);
                    p.pop();
                }
                
                // Update physics
                if(isMoving && !cannotSlide) {
                    let dt = 1/60;
                    let sinTheta = Math.sin(angle * Math.PI / 180);
                    let cosTheta = Math.cos(angle * Math.PI / 180);
                    
                    // Calculate acceleration
                    let a = g * (sinTheta - friction * cosTheta);
                    
                    if(a > 0 && distance < inclineLength) {
                        velocity += a * dt;
                        let ds = velocity * dt * scale; // displacement in pixels
                        distance += ds;
                        
                        // Update block position along incline
                        let distFromStart = distance;
                        blockX = startX + distFromStart * cosTheta + blockSize/2 * sinTheta;
                        blockY = startY + distFromStart * sinTheta - blockSize/2 * cosTheta;
                        
                        // Calculate energy dissipated by friction
                        let frictionWork = friction * mass * g * cosTheta * ds / scale;
                        dissipatedEnergy += frictionWork;
                    }
                    
                    // Stop at bottom
                    if(distance >= inclineLength || blockY >= groundY - blockSize/2) {
                        isMoving = false;
                        if(blockY > groundY - blockSize/2) {
                            blockY = groundY - blockSize/2;
                            blockX = endX;
                        }
                    }
                }
                
                // Calculate current energies
                let currentHeight = (groundY - blockY) / scale;
                let pe = mass * g * currentHeight;
                let ke = 0.5 * mass * velocity * velocity;
                let total = pe + ke + dissipatedEnergy;
                
                // Draw block
                p.push();
                p.translate(blockX, blockY);
                p.rotate(angle * Math.PI / 180);
                p.fill(cannotSlide ? [255, 150, 150] : [100, 150, 255]);
                p.stroke(50);
                p.strokeWeight(2);
                p.rectMode(p.CENTER);
                p.rect(0, 0, blockSize, blockSize);
                p.pop();
                
                // Draw force vectors if not moving
                if(!isMoving && distance < inclineLength - 1) {
                    p.strokeWeight(2);
                    
                    // Weight (mg)
                    p.stroke(255, 0, 0);
                    p.fill(255, 0, 0);
                    p.drawArrow(blockX, blockY, blockX, blockY + 80);
                    p.noStroke();
                    p.text('mg', blockX + 10, blockY + 75);
                    
                    // Normal force
                    p.stroke(0, 255, 0);
                    p.fill(0, 255, 0);
                    let normalAngle = angle - 90;
                    let nx = blockX + 60 * Math.cos(normalAngle * Math.PI / 180);
                    let ny = blockY + 60 * Math.sin(normalAngle * Math.PI / 180);
                    p.drawArrow(blockX, blockY, nx, ny);
                    p.noStroke();
                    p.text('N', nx + 5, ny - 5);
                    
                    // Friction force (if present)
                    if(friction > 0) {
                        p.stroke(255, 165, 0);
                        p.fill(255, 165, 0);
                        let fx = blockX - 50 * Math.cos(angle * Math.PI / 180);
                        let fy = blockY - 50 * Math.sin(angle * Math.PI / 180);
                        p.drawArrow(blockX, blockY, fx, fy);
                        p.noStroke();
                        p.text('f', fx - 10, fy);
                    }
                }
                
                // Draw energy bars on canvas
                p.drawEnergyBars(pe, ke, dissipatedEnergy, initialPE);
                
                // Draw info panel
                p.fill(0);
                p.noStroke();
                p.textAlign(p.LEFT);
                p.text(`Angle: ${angle}°`, 10, 20);
                p.text(`Coefficient of Friction: ${friction.toFixed(2)}`, 10, 40);
                p.text(`Velocity: ${velocity.toFixed(2)} m/s`, 10, 60);
                p.text(`Distance: ${(distance/scale).toFixed(2)} m`, 10, 80);
                
                // Show sliding condition status
                if(cannotSlide) {
                    p.fill(200, 0, 0);
                    p.text(`Status: Block will NOT slide`, 10, 100);
                } else {
                    p.fill(0, 150, 0);
                    p.text(`Status: Block can slide`, 10, 100);
                }
            };
            
            p.drawArrow = function(x1, y1, x2, y2) {
                p.line(x1, y1, x2, y2);
                let angle = Math.atan2(y2 - y1, x2 - x1);
                p.push();
                p.translate(x2, y2);
                p.rotate(angle);
                p.triangle(0, 0, -8, -4, -8, 4);
                p.pop();
            };
            
            p.drawEnergyBars = function(pe, ke, dissipated, initial) {
                // Energy bar dimensions
                let barX = 600;
                let barY = 100;
                let barWidth = 40;
                let barHeight = 200;
                let barSpacing = 60;
                
                // Background for bars
                p.fill(240);
                p.noStroke();
                p.rect(barX - 20, barY - 40, barWidth * 3 + barSpacing * 2 + 40, barHeight + 100);
                
                // Title
                p.fill(0);
                p.textAlign(p.CENTER);
                p.text('Energy Distribution', barX + barWidth * 1.5 + barSpacing, barY - 20);
                
                // Calculate percentages
                let pePercent = (pe / initial) * 100;
                let kePercent = (ke / initial) * 100;
                let dissPercent = (dissipated / initial) * 100;
                
                // PE Bar
                p.fill(200);
                p.stroke(50);
                p.strokeWeight(2);
                p.rect(barX, barY, barWidth, barHeight);
                p.fill(33, 150, 243);
                p.noStroke();
                let peHeight = (pePercent / 100) * barHeight;
                p.rect(barX, barY + barHeight - peHeight, barWidth, peHeight);
                
                // KE Bar
                p.fill(200);
                p.stroke(50);
                p.strokeWeight(2);
                p.rect(barX + barSpacing, barY, barWidth, barHeight);
                p.fill(76, 175, 80);
                p.noStroke();
                let keHeight = (kePercent / 100) * barHeight;
                p.rect(barX + barSpacing, barY + barHeight - keHeight, barWidth, keHeight);
                
                // Dissipated Energy Bar
                p.fill(200);
                p.stroke(50);
                p.strokeWeight(2);
                p.rect(barX + barSpacing * 2, barY, barWidth, barHeight);
                p.fill(255, 152, 0);
                p.noStroke();
                let dissHeight = (dissPercent / 100) * barHeight;
                p.rect(barX + barSpacing * 2, barY + barHeight - dissHeight, barWidth, dissHeight);
                
                // Labels
                p.fill(0);
                p.textAlign(p.CENTER);
                p.text('PE', barX + barWidth/2, barY + barHeight + 20);
                p.text(`${pe.toFixed(1)} J`, barX + barWidth/2, barY + barHeight + 35);
                p.text(`${pePercent.toFixed(0)}%`, barX + barWidth/2, barY + barHeight + 50);
                
                p.text('KE', barX + barSpacing + barWidth/2, barY + barHeight + 20);
                p.text(`${ke.toFixed(1)} J`, barX + barSpacing + barWidth/2, barY + barHeight + 35);
                p.text(`${kePercent.toFixed(0)}%`, barX + barSpacing + barWidth/2, barY + barHeight + 50);
                
                p.text('Lost', barX + barSpacing * 2 + barWidth/2, barY + barHeight + 20);
                p.text(`${dissipated.toFixed(1)} J`, barX + barSpacing * 2 + barWidth/2, barY + barHeight + 35);
                p.text(`${dissPercent.toFixed(0)}%`, barX + barSpacing * 2 + barWidth/2, barY + barHeight + 50);
            };
            
            document.getElementById('incline-reset').onclick = function() {
                p.resetSimulation();
            };
            
            document.getElementById('incline-start').onclick = function() {
                if(!cannotSlide) {
                    isMoving = true;
                }
            };
            
            document.getElementById('incline-angle').oninput = function() {
                angle = parseInt(this.value);
                document.getElementById('angle-value').textContent = this.value;
                p.resetSimulation();
            };
            
            document.getElementById('incline-friction').oninput = function() {
                friction = parseFloat(this.value);
                document.getElementById('friction-value').textContent = this.value;
                p.resetSimulation();
            };
        };
        
        // Simulation 3: Rolling race - All objects race simultaneously
        let raceSketch = function(p) {
            let angle = 30;
            let isRacing = false;
            let inclineLength = 300;
            let objectRadius = 15;
            let startHeight;
            let startX, startY;
            let endX, endY;
            let groundY = 350;
            
            // Objects data
            let objects = [
                {type: 'sphere', momentCoeff: 2/5, colour: [100, 150, 255], label: 'Solid   Sphere', hollow: false},
                {type: 'hollow-sphere', momentCoeff: 2/3, colour: [150, 100, 255], label: 'Hollow  Sphere', hollow: true},
                {type: 'cylinder', momentCoeff: 1/2, colour: [255, 150, 100], label: 'Solid  Cylinder', hollow: false},
                {type: 'hollow-cylinder', momentCoeff: 1, colour: [150, 255, 100], label: 'Hollow Cylinder', hollow: true}
            ];
            
            // Track each object's state
            let objectStates = [];
            
            p.setup = function() {
                let canvas = p.createCanvas(800, 450);
                canvas.parent('race-sim');
                p.resetSimulation();
            };
            
            p.resetSimulation = function() {
                // Calculate incline endpoints
                endX = 350;
                endY = groundY;
                
                startX = endX - inclineLength * Math.cos(angle * Math.PI / 180);
                startY = endY - inclineLength * Math.sin(angle * Math.PI / 180);
                
                isRacing = false;
                startHeight = groundY - (startY - objectRadius * Math.cos(angle * Math.PI / 180));
                
                // Initialize states for each object
                objectStates = objects.map((obj, index) => ({
                    x: startX + objectRadius * Math.sin(angle * Math.PI / 180),
                    y: startY - objectRadius * Math.cos(angle * Math.PI / 180) - index * 40,
                    velocity: 0,
                    omega: 0,
                    distance: 0,
                    pe: 100,
                    tke: 0,
                    rke: 0
                }));
            };
            
            p.draw = function() {
                p.background(245);
                
                // Draw ground
                p.stroke(50);
                p.strokeWeight(2);
                p.line(0, groundY, p.width, groundY);
                
                // Draw multiple inclines for each object
                p.stroke(50);
                p.strokeWeight(4);
                for(let i = 0; i < objects.length; i++) {
                    let offsetY = -i * 40;
                    p.line(startX, startY + offsetY, endX, endY + offsetY);
                }
                
                // Update physics for all objects
                if(isRacing) {
                    let g = 0.3;
                    let sinTheta = Math.sin(angle * Math.PI / 180);
                    let cosTheta = Math.cos(angle * Math.PI / 180);
                    
                    objects.forEach((obj, index) => {
                        let state = objectStates[index];
                        
                        // Acceleration for rolling object
                        let a = g * sinTheta / (1 + obj.momentCoeff);

                        // Only update if not at bottom
                        if(state.distance < inclineLength) {
                            state.velocity += a;
                            state.omega = state.velocity / objectRadius;
                            state.distance += state.velocity;
                            
                            // Update position
                            state.x = startX + state.distance * cosTheta + objectRadius * sinTheta;
                            state.y = startY + state.distance * sinTheta - objectRadius * cosTheta - index * 40;
                            
                            // Calculate energies
                            let currentHeight = groundY - state.y - index * 40;
                            state.pe = Math.max(0, (currentHeight / startHeight) * 100);
                            let totalKE = 100 - state.pe;
                            state.tke = totalKE / (1 + obj.momentCoeff);
                            state.rke = totalKE * obj.momentCoeff / (1 + obj.momentCoeff);
                        } else {
                            // Stop at bottom - freeze everything
                            state.velocity = 0;
                            state.omega = 0;
                            state.x = endX;
                            state.y = groundY - objectRadius - index * 40;
                            state.pe = 0;
                            state.tke = 100 / (1 + obj.momentCoeff);
                            state.rke = 100 * obj.momentCoeff / (1 + obj.momentCoeff);
                        }
                    });
                }
                
                // Draw all objects
                objects.forEach((obj, index) => {
                    let state = objectStates[index];
                    
                    p.push();
                    p.translate(state.x, state.y);
                    p.rotate(state.distance / objectRadius);
                    
                    // Draw as circles with different styles
                    p.fill(obj.colour);
                    p.stroke(50);
                    p.strokeWeight(2);
                    p.ellipse(0, 0, objectRadius * 2);
                    
                    // Inner circle for hollow objects
                    if(obj.hollow) {
                        p.fill(255);
                        p.ellipse(0, 0, objectRadius * 1.2);
                    }
                    
                    // Reference mark for rotation
                    p.stroke(255, 0, 0);
                    p.strokeWeight(2);
                    p.line(0, 0, objectRadius - 2, 0);
                    p.pop();
                });
                
                // Draw energy bars matrix (4x3)
                p.drawEnergyMatrix();
                
                // Draw labels
                p.fill(0);
                p.noStroke();
                p.textAlign(p.LEFT);
                p.textSize(10);
                objects.forEach((obj, i) => {
                    p.text(obj.label + ` (I = ${obj.momentCoeff === 1 ? '' : 
                        obj.momentCoeff === 0.5 ? '1/2' : 
                        obj.momentCoeff === 2/3 ? '2/3' : '2/5'} MR²)`, 
                        10, startY- 25 - i * 40 + 5,73);
                });
                
                // Title for energy bars
                p.textAlign(p.CENTER);
                p.textSize(12);
                p.text('Energy Distribution (%)', 500, 15);
            };
            
            p.drawEnergyMatrix = function() {
                // Matrix position and dimensions
                let matrixX = 450;
                let matrixY = 45;
                let barWidth = 25;
                let barHeight = 60;
                let colSpacing = 40;
                let rowSpacing = 75;
                
                // Column headers
                p.fill(0);
                p.textAlign(p.CENTER);
                p.noStroke();
                p.textSize(10);
                p.text('PE', matrixX + barWidth/2, matrixY - 10);
                p.text('Trans', matrixX + colSpacing + barWidth/2, matrixY - 10);
                p.text('Rot', matrixX + colSpacing * 2 + barWidth/2, matrixY - 10);
                
                // Draw bars for each object
                objectStates.toReversed().forEach((state, row) => {
                    let y = matrixY + row * rowSpacing;
                    
                    // Row label
                    p.fill(objects.toReversed()[row].colour);
                    p.noStroke();
                    p.ellipse(matrixX - 20, y + barHeight/2, 12);
                    
                    // PE bar
                    p.fill(200);
                    p.stroke(50);
                    p.strokeWeight(1);
                    p.rect(matrixX, y, barWidth, barHeight);
                    p.fill(33, 150, 243);
                    p.noStroke();
                    let peHeight = (state.pe / 100) * barHeight;
                    p.rect(matrixX, y + barHeight - peHeight, barWidth, peHeight);
                    p.fill(0);
                    p.textAlign(p.CENTER);
                    p.textSize(9);
                    p.text(Math.round(state.pe), matrixX + barWidth/2, y + barHeight + 12);
                    
                    // Translational KE bar
                    p.fill(200);
                    p.stroke(50);
                    p.strokeWeight(1);
                    p.rect(matrixX + colSpacing, y, barWidth, barHeight);
                    p.fill(76, 175, 80);
                    p.noStroke();
                    let tkeHeight = (state.tke / 100) * barHeight;
                    p.rect(matrixX + colSpacing, y + barHeight - tkeHeight, barWidth, tkeHeight);
                    p.fill(0);
                    p.textSize(9);
                    p.text(Math.round(state.tke), matrixX + colSpacing + barWidth/2, y + barHeight + 12);
                    
                    // Rotational KE bar
                    p.fill(200);
                    p.stroke(50);
                    p.strokeWeight(1);
                    p.rect(matrixX + colSpacing * 2, y, barWidth, barHeight);
                    p.fill(255, 152, 0);
                    p.noStroke();
                    let rkeHeight = (state.rke / 100) * barHeight;
                    p.rect(matrixX + colSpacing * 2, y + barHeight - rkeHeight, barWidth, rkeHeight);
                    p.fill(0);
                    p.textSize(9);
                    p.text(Math.round(state.rke), matrixX + colSpacing * 2 + barWidth/2, y + barHeight + 12);
                });
            };
            
            document.getElementById('race-reset').onclick = function() {
                p.resetSimulation();
            };
            
            document.getElementById('race-start').onclick = function() {
                isRacing = true;
            };
        };
        
        // Initialize all simulations
        new p5(slideSketch);
        new p5(inclineSketch);
        new p5(raceSketch);
    </script>
</body>
</html>